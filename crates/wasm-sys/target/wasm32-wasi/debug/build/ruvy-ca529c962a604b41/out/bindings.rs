/* automatically generated by rust-bindgen 0.63.0 */

pub const RUBY_H: u32 = 1;
pub const HAVE_RUBY_ATOMIC_H: u32 = 1;
pub const HAVE_RUBY_DEBUG_H: u32 = 1;
pub const HAVE_RUBY_DEFINES_H: u32 = 1;
pub const HAVE_RUBY_ENCODING_H: u32 = 1;
pub const HAVE_RUBY_FIBER_SCHEDULER_H: u32 = 1;
pub const HAVE_RUBY_INTERN_H: u32 = 1;
pub const HAVE_RUBY_IO_H: u32 = 1;
pub const HAVE_RUBY_MEMORY_VIEW_H: u32 = 1;
pub const HAVE_RUBY_MISSING_H: u32 = 1;
pub const HAVE_RUBY_ONIGMO_H: u32 = 1;
pub const HAVE_RUBY_ONIGURUMA_H: u32 = 1;
pub const HAVE_RUBY_RACTOR_H: u32 = 1;
pub const HAVE_RUBY_RANDOM_H: u32 = 1;
pub const HAVE_RUBY_RE_H: u32 = 1;
pub const HAVE_RUBY_REGEX_H: u32 = 1;
pub const HAVE_RUBY_RUBY_H: u32 = 1;
pub const HAVE_RUBY_ST_H: u32 = 1;
pub const HAVE_RUBY_THREAD_H: u32 = 1;
pub const HAVE_RUBY_THREAD_NATIVE_H: u32 = 1;
pub const HAVE_RUBY_UTIL_H: u32 = 1;
pub const HAVE_RUBY_VERSION_H: u32 = 1;
pub const HAVE_RUBY_VM_H: u32 = 1;
pub const RUBY_RUBY_H: u32 = 1;
pub const INCLUDE_RUBY_CONFIG_H: u32 = 1;
pub const RUBY_ABI_VERSION: u32 = 3;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const HAVE_STMT_AND_DECL_IN_EXPR: u32 = 1;
pub const THREAD_IMPL_H: &[u8; 14usize] = b"thread_none.h\0";
pub const THREAD_IMPL_SRC: &[u8; 14usize] = b"thread_none.c\0";
pub const HAVE_LIBCRYPT: u32 = 1;
pub const HAVE_DIRENT_H: u32 = 1;
pub const HAVE__BOOL: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_FCNTL_H: u32 = 1;
pub const HAVE_FLOAT_H: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_LOCALE_H: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_STDALIGN_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_SYS_EVENTFD_H: u32 = 1;
pub const HAVE_SYS_FCNTL_H: u32 = 1;
pub const HAVE_SYS_FILE_H: u32 = 1;
pub const HAVE_SYS_IOCTL_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_RANDOM_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_SYSCALL_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TIMES_H: u32 = 1;
pub const HAVE_SYS_UIO_H: u32 = 1;
pub const HAVE_SYSCALL_H: u32 = 1;
pub const HAVE_TIME_H: u32 = 1;
pub const HAVE_UTIME_H: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_LONG_LONG: u32 = 1;
pub const HAVE_OFF_T: u32 = 1;
pub const SIZEOF_INT: u32 = 4;
pub const SIZEOF_SHORT: u32 = 2;
pub const SIZEOF_LONG: u32 = 4;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const SIZEOF___INT64: u32 = 0;
pub const SIZEOF___INT128: u32 = 16;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_VOIDP: u32 = 4;
pub const SIZEOF_FLOAT: u32 = 4;
pub const SIZEOF_DOUBLE: u32 = 8;
pub const SIZEOF_TIME_T: u32 = 8;
pub const SIZEOF_CLOCK_T: u32 = 8;
pub const USE_UNALIGNED_MEMBER_ACCESS: u32 = 1;
pub const PRI_LL_PREFIX: &[u8; 3usize] = b"ll\0";
pub const HAVE_PID_T: u32 = 1;
pub const SIGNEDNESS_OF_PID_T: i32 = -1;
pub const HAVE_UID_T: u32 = 1;
pub const SIGNEDNESS_OF_UID_T: u32 = 1;
pub const HAVE_GID_T: u32 = 1;
pub const SIGNEDNESS_OF_GID_T: u32 = 1;
pub const HAVE_TIME_T: u32 = 1;
pub const SIGNEDNESS_OF_TIME_T: i32 = -1;
pub const PRI_TIMET_PREFIX: &[u8; 3usize] = b"ll\0";
pub const HAVE_DEV_T: u32 = 1;
pub const SIGNEDNESS_OF_DEV_T: u32 = 1;
pub const PRI_DEVT_PREFIX: &[u8; 3usize] = b"ll\0";
pub const HAVE_MODE_T: u32 = 1;
pub const SIGNEDNESS_OF_MODE_T: u32 = 1;
pub const SIGNEDNESS_OF_RLIM_T: i32 = -1;
pub const SIGNEDNESS_OF_OFF_T: i32 = -1;
pub const PRI_OFFT_PREFIX: &[u8; 3usize] = b"ll\0";
pub const HAVE_CLOCKID_T: u32 = 1;
pub const HAVE_VA_ARGS_MACRO: u32 = 1;
pub const HAVE__ALIGNOF: u32 = 1;
pub const HAVE_FUNC_WEAK: u32 = 1;
pub const HAVE_NULLPTR: u32 = 1;
pub const HAVE_ATTRIBUTE_FUNCTION_ALIAS: u32 = 1;
pub const HAVE_GCC_ATOMIC_BUILTINS: u32 = 1;
pub const HAVE_GCC_SYNC_BUILTINS: u32 = 1;
pub const HAVE___BUILTIN_UNREACHABLE: u32 = 1;
pub const ENUM_OVER_INT: u32 = 1;
pub const HAVE_DECL_SYS_NERR: u32 = 0;
pub const HAVE_DECL_GETENV: u32 = 1;
pub const SIZEOF_SIZE_T: u32 = 4;
pub const SIZEOF_PTRDIFF_T: u32 = 4;
pub const SIZEOF_DEV_T: u32 = 8;
pub const PRI_SIZE_PREFIX: &[u8; 2usize] = b"z\0";
pub const PRI_PTRDIFF_PREFIX: &[u8; 2usize] = b"t\0";
pub const HAVE_STRUCT_STAT_ST_BLKSIZE: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_BLOCKS: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_RDEV: u32 = 1;
pub const SIZEOF_STRUCT_STAT_ST_SIZE: u32 = 8;
pub const SIZEOF_STRUCT_STAT_ST_BLOCKS: u32 = 8;
pub const SIZEOF_STRUCT_STAT_ST_INO: u32 = 8;
pub const SIZEOF_STRUCT_STAT_ST_DEV: u32 = 8;
pub const SIZEOF_STRUCT_STAT_ST_RDEV: u32 = 8;
pub const HAVE_STRUCT_STAT_ST_ATIM: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_MTIM: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_CTIM: u32 = 1;
pub const HAVE_STRUCT_TIMEVAL: u32 = 1;
pub const SIZEOF_STRUCT_TIMEVAL_TV_SEC: u32 = 8;
pub const HAVE_STRUCT_TIMESPEC: u32 = 1;
pub const HAVE_STRUCT_TIMEZONE: u32 = 1;
pub const HAVE_INT8_T: u32 = 1;
pub const SIZEOF_INT8_T: u32 = 1;
pub const HAVE_UINT8_T: u32 = 1;
pub const SIZEOF_UINT8_T: u32 = 1;
pub const HAVE_INT16_T: u32 = 1;
pub const SIZEOF_INT16_T: u32 = 2;
pub const HAVE_UINT16_T: u32 = 1;
pub const SIZEOF_UINT16_T: u32 = 2;
pub const HAVE_INT32_T: u32 = 1;
pub const SIZEOF_INT32_T: u32 = 4;
pub const HAVE_UINT32_T: u32 = 1;
pub const SIZEOF_UINT32_T: u32 = 4;
pub const HAVE_INT64_T: u32 = 1;
pub const SIZEOF_INT64_T: u32 = 8;
pub const HAVE_UINT64_T: u32 = 1;
pub const SIZEOF_UINT64_T: u32 = 8;
pub const HAVE_INT128_T: u32 = 1;
pub const SIZEOF_INT128_T: u32 = 16;
pub const HAVE_UINT128_T: u32 = 1;
pub const SIZEOF_UINT128_T: u32 = 16;
pub const HAVE_INTPTR_T: u32 = 1;
pub const SIZEOF_INTPTR_T: u32 = 4;
pub const HAVE_UINTPTR_T: u32 = 1;
pub const SIZEOF_UINTPTR_T: u32 = 4;
pub const PRI_PTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const HAVE_SSIZE_T: u32 = 1;
pub const SIZEOF_SSIZE_T: u32 = 4;
pub const PRI_64_PREFIX: &[u8; 3usize] = b"ll\0";
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_ALLOCA: u32 = 1;
pub const HAVE_ACOSH: u32 = 1;
pub const HAVE_CBRT: u32 = 1;
pub const HAVE_CRYPT: u32 = 1;
pub const HAVE_ERF: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_FFS: u32 = 1;
pub const HAVE_HYPOT: u32 = 1;
pub const HAVE_LGAMMA_R: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_NAN: u32 = 1;
pub const HAVE_NEXTAFTER: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRERROR: u32 = 1;
pub const HAVE_STRLCAT: u32 = 1;
pub const HAVE_STRLCPY: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_TGAMMA: u32 = 1;
pub const HAVE_ISFINITE: u32 = 1;
pub const HAVE_SIGNBIT: u32 = 1;
pub const HAVE_ARC4RANDOM_BUF: u32 = 1;
pub const HAVE_ATAN2L: u32 = 1;
pub const HAVE_ATAN2F: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_COSH: u32 = 1;
pub const HAVE_CRYPT_R: u32 = 1;
pub const HAVE_DIRFD: u32 = 1;
pub const HAVE_FCNTL: u32 = 1;
pub const HAVE_FDATASYNC: u32 = 1;
pub const HAVE_FDOPENDIR: u32 = 1;
pub const HAVE_FMOD: u32 = 1;
pub const HAVE_FSTATAT: u32 = 1;
pub const HAVE_FSYNC: u32 = 1;
pub const HAVE_FTRUNCATE: u32 = 1;
pub const HAVE_GETCWD: u32 = 1;
pub const HAVE_GETENTROPY: u32 = 1;
pub const HAVE_GETTIMEOFDAY: u32 = 1;
pub const HAVE_GMTIME_R: u32 = 1;
pub const HAVE_IOCTL: u32 = 1;
pub const HAVE_LINK: u32 = 1;
pub const HAVE_LLABS: u32 = 1;
pub const HAVE_LOG2: u32 = 1;
pub const HAVE_LSTAT: u32 = 1;
pub const HAVE_MALLOC_USABLE_SIZE: u32 = 1;
pub const HAVE_MBLEN: u32 = 1;
pub const HAVE_WRITEV: u32 = 1;
pub const HAVE_MEMRCHR: u32 = 1;
pub const HAVE_MEMMEM: u32 = 1;
pub const HAVE_MKTIME: u32 = 1;
pub const HAVE_MMAP: u32 = 1;
pub const HAVE_OPENAT: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POSIX_FADVISE: u32 = 1;
pub const HAVE_POSIX_MEMALIGN: u32 = 1;
pub const HAVE_PREAD: u32 = 1;
pub const HAVE_PWRITE: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_ROUND: u32 = 1;
pub const HAVE_SEEKDIR: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_SINH: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_TANH: u32 = 1;
pub const HAVE_TELLDIR: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TIMES: u32 = 1;
pub const HAVE_TRUNCATE: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_UTIMENSAT: u32 = 1;
pub const NO_GETCWD_MALLOC: u32 = 1;
pub const HAVE_CRYPT_H: u32 = 1;
pub const HAVE_STRUCT_CRYPT_DATA_INITIALIZED: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_ALLOCA_WITH_ALIGN: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_ASSUME_ALIGNED: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_BSWAP16: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_BSWAP32: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_BSWAP64: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_POPCOUNT: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_POPCOUNTLL: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CLZ: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CLZL: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CLZLL: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CTZ: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CTZLL: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_ADD_OVERFLOW: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_SUB_OVERFLOW: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_MUL_OVERFLOW: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CONSTANT_P: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CHOOSE_EXPR: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_CHOOSE_EXPR_CONSTANT_P: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_TYPES_COMPATIBLE_P: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_TRAP: u32 = 1;
pub const HAVE_BUILTIN___BUILTIN_EXPECT: u32 = 1;
pub const ATAN2_INF_C99: u32 = 1;
pub const HAVE_CLOCK_GETRES: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_TM_ZONE: u32 = 1;
pub const HAVE_STRUCT_TM_TM_GMTOFF: u32 = 1;
pub const NEGATIVE_TIME_T: u32 = 1;
pub const LOCALTIME_OVERFLOW_PROBLEM: u32 = 1;
pub const HAVE_SIG_T: u32 = 1;
pub const HAVE__SC_CLK_TCK: u32 = 1;
pub const STACK_GROW_DIRECTION: u32 = 0;
pub const COROUTINE_H: &[u8; 29usize] = b"coroutine/asyncify/Context.h\0";
pub const HAVE_CONST_PAGE_SIZE: u32 = 0;
pub const EXTSTATIC: u32 = 1;
pub const DLEXT_MAXLEN: u32 = 3;
pub const DLEXT: &[u8; 4usize] = b".so\0";
pub const CROSS_COMPILING: u32 = 1;
pub const USE_MJIT: u32 = 0;
pub const USE_YJIT: u32 = 0;
pub const RUBY_PLATFORM: &[u8; 12usize] = b"wasm32-wasi\0";
pub const RBIMPL_COMPILER_IS_Apple: u32 = 0;
pub const RBIMPL_COMPILER_IS_Clang: u32 = 1;
pub const RBIMPL_COMPILER_IS_Intel: u32 = 0;
pub const RBIMPL_COMPILER_IS_GCC: u32 = 0;
pub const RBIMPL_COMPILER_IS_MSVC: u32 = 0;
pub const RBIMPL_COMPILER_IS_SunPro: u32 = 0;
pub const HAVE_PROTOTYPES: u32 = 1;
pub const HAVE_STDARG_PROTOTYPES: u32 = 1;
pub const UNALIGNED_WORD_ACCESS: u32 = 0;
pub const USE_RVARGC: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RUBY_DEFINES_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const EOF: i32 = -1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const L_ctermid: u32 = 20;
pub const L_cuserid: u32 = 20;
pub const __PDP_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 4321;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const PDP_ENDIAN: u32 = 3412;
pub const FD_SETSIZE: u32 = 1024;
pub const S_IFBLK: u32 = 24576;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFIFO: u32 = 49152;
pub const S_IXOTH: u32 = 1;
pub const S_IWOTH: u32 = 2;
pub const S_IROTH: u32 = 4;
pub const S_IRWXO: u32 = 7;
pub const S_IXGRP: u32 = 8;
pub const S_IWGRP: u32 = 16;
pub const S_IRGRP: u32 = 32;
pub const S_IRWXG: u32 = 56;
pub const S_IXUSR: u32 = 64;
pub const S_IWUSR: u32 = 128;
pub const S_IRUSR: u32 = 256;
pub const S_IRWXU: u32 = 448;
pub const S_ISVTX: u32 = 512;
pub const S_ISGID: u32 = 1024;
pub const S_ISUID: u32 = 2048;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const POSIX_CLOSE_RESTART: u32 = 0;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_VDISABLE: u32 = 0;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_CPUTIME: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_SYNC_IO: u32 = 9;
pub const _PC_ASYNC_IO: u32 = 10;
pub const _PC_PRIO_IO: u32 = 11;
pub const _PC_SOCK_MAXBUF: u32 = 12;
pub const _PC_FILESIZEBITS: u32 = 13;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 14;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 15;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 16;
pub const _PC_REC_XFER_ALIGN: u32 = 17;
pub const _PC_ALLOC_SIZE_MIN: u32 = 18;
pub const _PC_SYMLINK_MAX: u32 = 19;
pub const _PC_2_SYMLINKS: u32 = 20;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_STREAM_MAX: u32 = 5;
pub const _SC_TZNAME_MAX: u32 = 6;
pub const _SC_JOB_CONTROL: u32 = 7;
pub const _SC_SAVED_IDS: u32 = 8;
pub const _SC_REALTIME_SIGNALS: u32 = 9;
pub const _SC_PRIORITY_SCHEDULING: u32 = 10;
pub const _SC_TIMERS: u32 = 11;
pub const _SC_ASYNCHRONOUS_IO: u32 = 12;
pub const _SC_PRIORITIZED_IO: u32 = 13;
pub const _SC_SYNCHRONIZED_IO: u32 = 14;
pub const _SC_FSYNC: u32 = 15;
pub const _SC_MAPPED_FILES: u32 = 16;
pub const _SC_MEMLOCK: u32 = 17;
pub const _SC_MEMLOCK_RANGE: u32 = 18;
pub const _SC_MEMORY_PROTECTION: u32 = 19;
pub const _SC_MESSAGE_PASSING: u32 = 20;
pub const _SC_SEMAPHORES: u32 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 22;
pub const _SC_AIO_LISTIO_MAX: u32 = 23;
pub const _SC_AIO_MAX: u32 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 25;
pub const _SC_DELAYTIMER_MAX: u32 = 26;
pub const _SC_MQ_OPEN_MAX: u32 = 27;
pub const _SC_MQ_PRIO_MAX: u32 = 28;
pub const _SC_VERSION: u32 = 29;
pub const _SC_PAGE_SIZE: u32 = 30;
pub const _SC_PAGESIZE: u32 = 30;
pub const _SC_RTSIG_MAX: u32 = 31;
pub const _SC_SEM_NSEMS_MAX: u32 = 32;
pub const _SC_SEM_VALUE_MAX: u32 = 33;
pub const _SC_SIGQUEUE_MAX: u32 = 34;
pub const _SC_TIMER_MAX: u32 = 35;
pub const _SC_BC_BASE_MAX: u32 = 36;
pub const _SC_BC_DIM_MAX: u32 = 37;
pub const _SC_BC_SCALE_MAX: u32 = 38;
pub const _SC_BC_STRING_MAX: u32 = 39;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 40;
pub const _SC_EXPR_NEST_MAX: u32 = 42;
pub const _SC_LINE_MAX: u32 = 43;
pub const _SC_RE_DUP_MAX: u32 = 44;
pub const _SC_2_VERSION: u32 = 46;
pub const _SC_2_C_BIND: u32 = 47;
pub const _SC_2_C_DEV: u32 = 48;
pub const _SC_2_FORT_DEV: u32 = 49;
pub const _SC_2_FORT_RUN: u32 = 50;
pub const _SC_2_SW_DEV: u32 = 51;
pub const _SC_2_LOCALEDEF: u32 = 52;
pub const _SC_UIO_MAXIOV: u32 = 60;
pub const _SC_IOV_MAX: u32 = 60;
pub const _SC_THREADS: u32 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 68;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 69;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 70;
pub const _SC_LOGIN_NAME_MAX: u32 = 71;
pub const _SC_TTY_NAME_MAX: u32 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 73;
pub const _SC_THREAD_KEYS_MAX: u32 = 74;
pub const _SC_THREAD_STACK_MIN: u32 = 75;
pub const _SC_THREAD_THREADS_MAX: u32 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 79;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 80;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 81;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 82;
pub const _SC_NPROCESSORS_CONF: u32 = 83;
pub const _SC_NPROCESSORS_ONLN: u32 = 84;
pub const _SC_PHYS_PAGES: u32 = 85;
pub const _SC_AVPHYS_PAGES: u32 = 86;
pub const _SC_ATEXIT_MAX: u32 = 87;
pub const _SC_PASS_MAX: u32 = 88;
pub const _SC_XOPEN_VERSION: u32 = 89;
pub const _SC_XOPEN_XCU_VERSION: u32 = 90;
pub const _SC_XOPEN_UNIX: u32 = 91;
pub const _SC_XOPEN_CRYPT: u32 = 92;
pub const _SC_XOPEN_ENH_I18N: u32 = 93;
pub const _SC_XOPEN_SHM: u32 = 94;
pub const _SC_2_CHAR_TERM: u32 = 95;
pub const _SC_2_UPE: u32 = 97;
pub const _SC_XOPEN_XPG2: u32 = 98;
pub const _SC_XOPEN_XPG3: u32 = 99;
pub const _SC_XOPEN_XPG4: u32 = 100;
pub const _SC_NZERO: u32 = 109;
pub const _SC_XBS5_ILP32_OFF32: u32 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 126;
pub const _SC_XBS5_LP64_OFF64: u32 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 128;
pub const _SC_XOPEN_LEGACY: u32 = 129;
pub const _SC_XOPEN_REALTIME: u32 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 131;
pub const _SC_ADVISORY_INFO: u32 = 132;
pub const _SC_BARRIERS: u32 = 133;
pub const _SC_CLOCK_SELECTION: u32 = 137;
pub const _SC_CPUTIME: u32 = 138;
pub const _SC_THREAD_CPUTIME: u32 = 139;
pub const _SC_MONOTONIC_CLOCK: u32 = 149;
pub const _SC_READER_WRITER_LOCKS: u32 = 153;
pub const _SC_SPIN_LOCKS: u32 = 154;
pub const _SC_REGEXP: u32 = 155;
pub const _SC_SHELL: u32 = 157;
pub const _SC_SPAWN: u32 = 159;
pub const _SC_SPORADIC_SERVER: u32 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 161;
pub const _SC_TIMEOUTS: u32 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 165;
pub const _SC_2_PBS: u32 = 168;
pub const _SC_2_PBS_ACCOUNTING: u32 = 169;
pub const _SC_2_PBS_LOCATE: u32 = 170;
pub const _SC_2_PBS_MESSAGE: u32 = 171;
pub const _SC_2_PBS_TRACK: u32 = 172;
pub const _SC_SYMLOOP_MAX: u32 = 173;
pub const _SC_STREAMS: u32 = 174;
pub const _SC_2_PBS_CHECKPOINT: u32 = 175;
pub const _SC_V6_ILP32_OFF32: u32 = 176;
pub const _SC_V6_ILP32_OFFBIG: u32 = 177;
pub const _SC_V6_LP64_OFF64: u32 = 178;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 179;
pub const _SC_HOST_NAME_MAX: u32 = 180;
pub const _SC_TRACE: u32 = 181;
pub const _SC_TRACE_EVENT_FILTER: u32 = 182;
pub const _SC_TRACE_INHERIT: u32 = 183;
pub const _SC_TRACE_LOG: u32 = 184;
pub const _SC_IPV6: u32 = 235;
pub const _SC_RAW_SOCKETS: u32 = 236;
pub const _SC_V7_ILP32_OFF32: u32 = 237;
pub const _SC_V7_ILP32_OFFBIG: u32 = 238;
pub const _SC_V7_LP64_OFF64: u32 = 239;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 240;
pub const _SC_SS_REPL_MAX: u32 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 242;
pub const _SC_TRACE_NAME_MAX: u32 = 243;
pub const _SC_TRACE_SYS_MAX: u32 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 245;
pub const _SC_XOPEN_STREAMS: u32 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 248;
pub const _CS_PATH: u32 = 0;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 1;
pub const _CS_GNU_LIBC_VERSION: u32 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: u32 = 3;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: u32 = 4;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: u32 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: u32 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: u32 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: u32 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: u32 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: u32 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: u32 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: u32 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: u32 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: u32 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: u32 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: u32 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: u32 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: u32 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: u32 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: u32 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: u32 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: u32 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: u32 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: u32 = 1147;
pub const _CS_V6_ENV: u32 = 1148;
pub const _CS_V7_ENV: u32 = 1149;
pub const RBIMPL_HAVE___HAS_ATTRIBUTE: u32 = 1;
pub const USE_GC_MALLOC_OBJ_INFO_DETAILS: u32 = 0;
pub const RBIMPL_HAVE___HAS_BUILTIN: u32 = 1;
pub const RBIMPL_RUBY_DEBUG: u32 = 0;
pub const RBIMPL_NDEBUG: u32 = 0;
pub const RUBY_DEBUG: u32 = 0;
pub const RUBY_NDEBUG: u32 = 1;
pub const HAVE_ATTRIBUTE_ERRORFUNC: u32 = 1;
pub const HAVE_ATTRIBUTE_WARNINGFUNC: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const HAVE_TRUE_LONG_LONG: u32 = 1;
pub const PATH_SEP: &[u8; 2usize] = b":\0";
pub const PATH_ENV: &[u8; 5usize] = b"PATH\0";
pub const CASEFOLD_FILESYSTEM: u32 = 0;
pub const RUBY_MISSING_H: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const TIME_UTC: u32 = 1;
pub const HAVE_FINITE: u32 = 1;
pub const WNOHANG: u32 = 0;
pub const HAVE_WAITPID: u32 = 1;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PAGESIZE: u32 = 65536;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 32;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const PAGE_SIZE: u32 = 65536;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const SIZEOF_VALUE: u32 = 4;
pub const PRI_VALUE_PREFIX: &[u8; 2usize] = b"l\0";
pub const RBIMPL_VALUE_NULL: u32 = 0;
pub const RBIMPL_VALUE_ONE: u32 = 1;
pub const HAVE_RB_DEFINE_ALLOC_FUNC: u32 = 1;
pub const RBIMPL_HAS_ATTR_CONSTEXPR_CXX11: u32 = 0;
pub const RBIMPL_HAS_ATTR_CONSTEXPR_CXX14: u32 = 0;
pub const USE_FLONUM: u32 = 0;
pub const RBIMPL_RVALUE_EMBED_LEN_MAX: u32 = 3;
pub const RBIMPL_HAVE_ENUM_ATTRIBUTE: u32 = 1;
pub const RBIMPL_WIDER_ENUM: u32 = 1;
pub const RUBY_ST_H: u32 = 1;
pub const SIZEOF_ST_INDEX_T: u32 = 4;
pub const ST_INDEX_BITS: u32 = 32;
pub const USE_RGENGC: u32 = 1;
pub const USE_RINCGC: u32 = 1;
pub const USE_RGENGC_LOGGING_WB_UNPROTECT: u32 = 0;
pub const RGENGC_WB_PROTECTED_ARRAY: u32 = 1;
pub const RGENGC_WB_PROTECTED_HASH: u32 = 1;
pub const RGENGC_WB_PROTECTED_STRUCT: u32 = 1;
pub const RGENGC_WB_PROTECTED_STRING: u32 = 1;
pub const RGENGC_WB_PROTECTED_OBJECT: u32 = 1;
pub const RGENGC_WB_PROTECTED_REGEXP: u32 = 1;
pub const RGENGC_WB_PROTECTED_CLASS: u32 = 1;
pub const RGENGC_WB_PROTECTED_FLOAT: u32 = 1;
pub const RGENGC_WB_PROTECTED_COMPLEX: u32 = 1;
pub const RGENGC_WB_PROTECTED_RATIONAL: u32 = 1;
pub const RGENGC_WB_PROTECTED_BIGNUM: u32 = 1;
pub const RGENGC_WB_PROTECTED_NODE_CREF: u32 = 1;
pub const USE_TRANSIENT_HEAP: u32 = 1;
pub const RUBY_UNTYPED_DATA_WARNING: u32 = 0;
pub const RUBY_RUBY_BACKWARD_H: u32 = 1;
pub const HAVE_TYPE_RB_DATA_TYPE_T: u32 = 1;
pub const HAVE_RB_DATA_TYPE_T_FUNCTION: u32 = 1;
pub const HAVE_RB_DATA_TYPE_T_PARENT: u32 = 1;
pub const RUBY_EVENT_NONE: u32 = 0;
pub const RUBY_EVENT_LINE: u32 = 1;
pub const RUBY_EVENT_CLASS: u32 = 2;
pub const RUBY_EVENT_END: u32 = 4;
pub const RUBY_EVENT_CALL: u32 = 8;
pub const RUBY_EVENT_RETURN: u32 = 16;
pub const RUBY_EVENT_C_CALL: u32 = 32;
pub const RUBY_EVENT_C_RETURN: u32 = 64;
pub const RUBY_EVENT_RAISE: u32 = 128;
pub const RUBY_EVENT_ALL: u32 = 255;
pub const RUBY_EVENT_B_CALL: u32 = 256;
pub const RUBY_EVENT_B_RETURN: u32 = 512;
pub const RUBY_EVENT_THREAD_BEGIN: u32 = 1024;
pub const RUBY_EVENT_THREAD_END: u32 = 2048;
pub const RUBY_EVENT_FIBER_SWITCH: u32 = 4096;
pub const RUBY_EVENT_SCRIPT_COMPILED: u32 = 8192;
pub const RUBY_EVENT_TRACEPOINT_ALL: u32 = 65535;
pub const RUBY_EVENT_RESERVED_FOR_INTERNAL_USE: u32 = 196608;
pub const RUBY_INTERNAL_EVENT_SWITCH: u32 = 262144;
pub const RUBY_EVENT_SWITCH: u32 = 262144;
pub const RUBY_INTERNAL_EVENT_NEWOBJ: u32 = 1048576;
pub const RUBY_INTERNAL_EVENT_FREEOBJ: u32 = 2097152;
pub const RUBY_INTERNAL_EVENT_GC_START: u32 = 4194304;
pub const RUBY_INTERNAL_EVENT_GC_END_MARK: u32 = 8388608;
pub const RUBY_INTERNAL_EVENT_GC_END_SWEEP: u32 = 16777216;
pub const RUBY_INTERNAL_EVENT_GC_ENTER: u32 = 33554432;
pub const RUBY_INTERNAL_EVENT_GC_EXIT: u32 = 67108864;
pub const RUBY_INTERNAL_EVENT_OBJSPACE_MASK: u32 = 133169152;
pub const RUBY_INTERNAL_EVENT_MASK: u32 = 4294901760;
pub const RB_EVENT_HOOKS_HAVE_CALLBACK_DATA: u32 = 1;
pub const RUBY_INTEGER_UNIFICATION: u32 = 1;
pub const RB_BLOCK_CALL_FUNC_STRICT: u32 = 1;
pub const RUBY_BLOCK_CALL_FUNC_TAKES_BLOCKARG: u32 = 1;
pub const RUBY_ALLOCV_LIMIT: u32 = 1024;
pub const UNLIMITED_ARGUMENTS: i32 = -1;
pub const RB_SCAN_ARGS_PASS_CALLED_KEYWORDS: u32 = 0;
pub const RB_SCAN_ARGS_KEYWORDS: u32 = 1;
pub const RB_SCAN_ARGS_LAST_HASH_KEYWORDS: u32 = 3;
pub const RB_NO_KEYWORDS: u32 = 0;
pub const RB_PASS_KEYWORDS: u32 = 1;
pub const HAVE_RB_SCAN_ARGS_OPTIONAL_HASH: u32 = 1;
pub const PRI_INT_PREFIX: &[u8; 1usize] = b"\0";
pub const PRI_LONG_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRI_SHORT_PREFIX: &[u8; 2usize] = b"h\0";
pub const RUBY_PRI_VALUE_MARK: &[u8; 2usize] = b"\x0B\0";
pub const PRIdVALUE: &[u8; 3usize] = b"ld\0";
pub const PRIoVALUE: &[u8; 3usize] = b"lo\0";
pub const PRIuVALUE: &[u8; 3usize] = b"lu\0";
pub const PRIxVALUE: &[u8; 3usize] = b"lx\0";
pub const PRIXVALUE: &[u8; 3usize] = b"lX\0";
pub const PRIsVALUE: &[u8; 4usize] = b"li\x0B\0";
pub const PRIdPTRDIFF: &[u8; 3usize] = b"td\0";
pub const PRIiPTRDIFF: &[u8; 3usize] = b"ti\0";
pub const PRIoPTRDIFF: &[u8; 3usize] = b"to\0";
pub const PRIuPTRDIFF: &[u8; 3usize] = b"tu\0";
pub const PRIxPTRDIFF: &[u8; 3usize] = b"tx\0";
pub const PRIXPTRDIFF: &[u8; 3usize] = b"tX\0";
pub const PRIdSIZE: &[u8; 3usize] = b"zd\0";
pub const PRIiSIZE: &[u8; 3usize] = b"zi\0";
pub const PRIoSIZE: &[u8; 3usize] = b"zo\0";
pub const PRIuSIZE: &[u8; 3usize] = b"zu\0";
pub const PRIxSIZE: &[u8; 3usize] = b"zx\0";
pub const PRIXSIZE: &[u8; 3usize] = b"zX\0";
pub const USE_SYMBOL_AS_METHOD_NAME: u32 = 1;
pub const RUBY_INTERN_H: u32 = 1;
pub const INTEGER_PACK_MSWORD_FIRST: u32 = 1;
pub const INTEGER_PACK_LSWORD_FIRST: u32 = 2;
pub const INTEGER_PACK_MSBYTE_FIRST: u32 = 16;
pub const INTEGER_PACK_LSBYTE_FIRST: u32 = 32;
pub const INTEGER_PACK_NATIVE_BYTE_ORDER: u32 = 64;
pub const INTEGER_PACK_2COMP: u32 = 128;
pub const INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION: u32 = 1024;
pub const INTEGER_PACK_FORCE_BIGNUM: u32 = 256;
pub const INTEGER_PACK_NEGATIVE: u32 = 512;
pub const INTEGER_PACK_LITTLE_ENDIAN: u32 = 34;
pub const INTEGER_PACK_BIG_ENDIAN: u32 = 17;
pub const HAVE_RB_EXT_RACTOR_SAFE: u32 = 1;
pub const RB_NUM_COERCE_FUNCS_NEED_OPID: u32 = 1;
pub const HAVE_RB_REG_NEW_STR: u32 = 1;
pub const RUBY_VM: u32 = 1;
pub const RUBY_SUBST_H: u32 = 1;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type off_t = ::std::os::raw::c_longlong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type __isoc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        8usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        4usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type __wasi_size_t = ::std::os::raw::c_ulong;
pub type __wasi_filesize_t = u64;
pub type __wasi_timestamp_t = u64;
pub type __wasi_clockid_t = u32;
pub type __wasi_errno_t = u16;
pub type __wasi_rights_t = u64;
pub type __wasi_fd_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_iovec_t {
    pub buf: *mut u8,
    pub buf_len: __wasi_size_t,
}
#[test]
fn bindgen_test_layout___wasi_iovec_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_iovec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_iovec_t>(),
        8usize,
        concat!("Size of: ", stringify!(__wasi_iovec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_iovec_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__wasi_iovec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_iovec_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_iovec_t),
            "::",
            stringify!(buf_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_ciovec_t {
    pub buf: *const u8,
    pub buf_len: __wasi_size_t,
}
#[test]
fn bindgen_test_layout___wasi_ciovec_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_ciovec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_ciovec_t>(),
        8usize,
        concat!("Size of: ", stringify!(__wasi_ciovec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_ciovec_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__wasi_ciovec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_ciovec_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_ciovec_t),
            "::",
            stringify!(buf_len)
        )
    );
}
pub type __wasi_filedelta_t = i64;
pub type __wasi_whence_t = u8;
pub type __wasi_dircookie_t = u64;
pub type __wasi_dirnamlen_t = u32;
pub type __wasi_inode_t = u64;
pub type __wasi_filetype_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_dirent_t {
    pub d_next: __wasi_dircookie_t,
    pub d_ino: __wasi_inode_t,
    pub d_namlen: __wasi_dirnamlen_t,
    pub d_type: __wasi_filetype_t,
}
#[test]
fn bindgen_test_layout___wasi_dirent_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_dirent_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_dirent_t>(),
        24usize,
        concat!("Size of: ", stringify!(__wasi_dirent_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_dirent_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_dirent_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_dirent_t),
            "::",
            stringify!(d_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_dirent_t),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_namlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_dirent_t),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_dirent_t),
            "::",
            stringify!(d_type)
        )
    );
}
pub type __wasi_advice_t = u8;
pub type __wasi_fdflags_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_fdstat_t {
    pub fs_filetype: __wasi_filetype_t,
    pub fs_flags: __wasi_fdflags_t,
    pub fs_rights_base: __wasi_rights_t,
    pub fs_rights_inheriting: __wasi_rights_t,
}
#[test]
fn bindgen_test_layout___wasi_fdstat_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_fdstat_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_fdstat_t>(),
        24usize,
        concat!("Size of: ", stringify!(__wasi_fdstat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_fdstat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_fdstat_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_filetype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_fdstat_t),
            "::",
            stringify!(fs_filetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_fdstat_t),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_rights_base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_fdstat_t),
            "::",
            stringify!(fs_rights_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs_rights_inheriting) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_fdstat_t),
            "::",
            stringify!(fs_rights_inheriting)
        )
    );
}
pub type __wasi_device_t = u64;
pub type __wasi_fstflags_t = u16;
pub type __wasi_lookupflags_t = u32;
pub type __wasi_oflags_t = u16;
pub type __wasi_linkcount_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_filestat_t {
    pub dev: __wasi_device_t,
    pub ino: __wasi_inode_t,
    pub filetype: __wasi_filetype_t,
    pub nlink: __wasi_linkcount_t,
    pub size: __wasi_filesize_t,
    pub atim: __wasi_timestamp_t,
    pub mtim: __wasi_timestamp_t,
    pub ctim: __wasi_timestamp_t,
}
#[test]
fn bindgen_test_layout___wasi_filestat_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_filestat_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_filestat_t>(),
        64usize,
        concat!("Size of: ", stringify!(__wasi_filestat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_filestat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_filestat_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(filetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlink) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atim) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtim) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctim) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_filestat_t),
            "::",
            stringify!(ctim)
        )
    );
}
pub type __wasi_userdata_t = u64;
pub type __wasi_eventtype_t = u8;
pub type __wasi_eventrwflags_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_event_fd_readwrite_t {
    pub nbytes: __wasi_filesize_t,
    pub flags: __wasi_eventrwflags_t,
}
#[test]
fn bindgen_test_layout___wasi_event_fd_readwrite_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_event_fd_readwrite_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_event_fd_readwrite_t>(),
        16usize,
        concat!("Size of: ", stringify!(__wasi_event_fd_readwrite_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_event_fd_readwrite_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_event_fd_readwrite_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_fd_readwrite_t),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_fd_readwrite_t),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_event_t {
    pub userdata: __wasi_userdata_t,
    pub error: __wasi_errno_t,
    pub type_: __wasi_eventtype_t,
    pub fd_readwrite: __wasi_event_fd_readwrite_t,
}
#[test]
fn bindgen_test_layout___wasi_event_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_event_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(__wasi_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_event_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_t),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_t),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd_readwrite) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_event_t),
            "::",
            stringify!(fd_readwrite)
        )
    );
}
pub type __wasi_subclockflags_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_subscription_clock_t {
    pub id: __wasi_clockid_t,
    pub timeout: __wasi_timestamp_t,
    pub precision: __wasi_timestamp_t,
    pub flags: __wasi_subclockflags_t,
}
#[test]
fn bindgen_test_layout___wasi_subscription_clock_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_subscription_clock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_subscription_clock_t>(),
        32usize,
        concat!("Size of: ", stringify!(__wasi_subscription_clock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_subscription_clock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_subscription_clock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_clock_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_clock_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_clock_t),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_clock_t),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_subscription_fd_readwrite_t {
    pub file_descriptor: __wasi_fd_t,
}
#[test]
fn bindgen_test_layout___wasi_subscription_fd_readwrite_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_subscription_fd_readwrite_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_subscription_fd_readwrite_t>(),
        4usize,
        concat!("Size of: ", stringify!(__wasi_subscription_fd_readwrite_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_subscription_fd_readwrite_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__wasi_subscription_fd_readwrite_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_descriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_fd_readwrite_t),
            "::",
            stringify!(file_descriptor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_subscription_u_u_t {
    pub clock: __wasi_subscription_clock_t,
    pub fd_read: __wasi_subscription_fd_readwrite_t,
    pub fd_write: __wasi_subscription_fd_readwrite_t,
}
#[test]
fn bindgen_test_layout___wasi_subscription_u_u_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_subscription_u_u_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_subscription_u_u_t>(),
        32usize,
        concat!("Size of: ", stringify!(__wasi_subscription_u_u_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_subscription_u_u_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_subscription_u_u_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_u_u_t),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_u_u_t),
            "::",
            stringify!(fd_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd_write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_u_u_t),
            "::",
            stringify!(fd_write)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_u_t {
    pub tag: __wasi_eventtype_t,
    pub u: __wasi_subscription_u_u_t,
}
#[test]
fn bindgen_test_layout___wasi_subscription_u_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_subscription_u_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_subscription_u_t>(),
        40usize,
        concat!("Size of: ", stringify!(__wasi_subscription_u_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_subscription_u_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_subscription_u_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_u_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_u_t),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_t {
    pub userdata: __wasi_userdata_t,
    pub u: __wasi_subscription_u_t,
}
#[test]
fn bindgen_test_layout___wasi_subscription_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_subscription_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_subscription_t>(),
        48usize,
        concat!("Size of: ", stringify!(__wasi_subscription_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_subscription_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__wasi_subscription_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_t),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_subscription_t),
            "::",
            stringify!(u)
        )
    );
}
pub type __wasi_exitcode_t = u32;
pub type __wasi_signal_t = u8;
pub type __wasi_riflags_t = u16;
pub type __wasi_roflags_t = u16;
pub type __wasi_siflags_t = u16;
pub type __wasi_sdflags_t = u8;
pub type __wasi_preopentype_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_prestat_dir_t {
    pub pr_name_len: __wasi_size_t,
}
#[test]
fn bindgen_test_layout___wasi_prestat_dir_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_prestat_dir_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_prestat_dir_t>(),
        4usize,
        concat!("Size of: ", stringify!(__wasi_prestat_dir_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_prestat_dir_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__wasi_prestat_dir_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pr_name_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_prestat_dir_t),
            "::",
            stringify!(pr_name_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_prestat_u_t {
    pub dir: __wasi_prestat_dir_t,
}
#[test]
fn bindgen_test_layout___wasi_prestat_u_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_prestat_u_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_prestat_u_t>(),
        4usize,
        concat!("Size of: ", stringify!(__wasi_prestat_u_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_prestat_u_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__wasi_prestat_u_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_prestat_u_t),
            "::",
            stringify!(dir)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_prestat_t {
    pub tag: __wasi_preopentype_t,
    pub u: __wasi_prestat_u_t,
}
#[test]
fn bindgen_test_layout___wasi_prestat_t() {
    const UNINIT: ::std::mem::MaybeUninit<__wasi_prestat_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__wasi_prestat_t>(),
        8usize,
        concat!("Size of: ", stringify!(__wasi_prestat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__wasi_prestat_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__wasi_prestat_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_prestat_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__wasi_prestat_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn __wasi_args_get(argv: *mut *mut u8, argv_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_args_sizes_get(
        argc: *mut __wasi_size_t,
        argv_buf_size: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_environ_get(environ: *mut *mut u8, environ_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_environ_sizes_get(
        environc: *mut __wasi_size_t,
        environ_buf_size: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_clock_res_get(
        id: __wasi_clockid_t,
        resolution: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_clock_time_get(
        id: __wasi_clockid_t,
        precision: __wasi_timestamp_t,
        time: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_advise(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
        advice: __wasi_advice_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_allocate(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_close(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_datasync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_fdstat_get(fd: __wasi_fd_t, stat: *mut __wasi_fdstat_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_fdstat_set_flags(fd: __wasi_fd_t, flags: __wasi_fdflags_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_fdstat_set_rights(
        fd: __wasi_fd_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_filestat_get(fd: __wasi_fd_t, buf: *mut __wasi_filestat_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_filestat_set_size(fd: __wasi_fd_t, size: __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_filestat_set_times(
        fd: __wasi_fd_t,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_pread(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        nread: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_prestat_get(fd: __wasi_fd_t, buf: *mut __wasi_prestat_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_prestat_dir_name(
        fd: __wasi_fd_t,
        path: *mut u8,
        path_len: __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_pwrite(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        nwritten: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_read(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        nread: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_readdir(
        fd: __wasi_fd_t,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        cookie: __wasi_dircookie_t,
        bufused: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_renumber(fd: __wasi_fd_t, to: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_seek(
        fd: __wasi_fd_t,
        offset: __wasi_filedelta_t,
        whence: __wasi_whence_t,
        newoffset: *mut __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_sync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_tell(fd: __wasi_fd_t, offset: *mut __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_fd_write(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        nwritten: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_create_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_filestat_get(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        buf: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_filestat_set_times(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_link(
        old_fd: __wasi_fd_t,
        old_flags: __wasi_lookupflags_t,
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_open(
        fd: __wasi_fd_t,
        dirflags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        oflags: __wasi_oflags_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inherting: __wasi_rights_t,
        fdflags: __wasi_fdflags_t,
        opened_fd: *mut __wasi_fd_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_readlink(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        bufused: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_remove_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_rename(
        fd: __wasi_fd_t,
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_symlink(
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_path_unlink_file(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_poll_oneoff(
        in_: *const __wasi_subscription_t,
        out: *mut __wasi_event_t,
        nsubscriptions: __wasi_size_t,
        nevents: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_proc_exit(rval: __wasi_exitcode_t);
}
extern "C" {
    pub fn __wasi_proc_raise(sig: __wasi_signal_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_sched_yield() -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_random_get(buf: *mut u8, buf_len: __wasi_size_t) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_sock_recv(
        fd: __wasi_fd_t,
        ri_data: *const __wasi_iovec_t,
        ri_data_len: usize,
        ri_flags: __wasi_riflags_t,
        ro_datalen: *mut __wasi_size_t,
        ro_flags: *mut __wasi_roflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_sock_send(
        fd: __wasi_fd_t,
        si_data: *const __wasi_ciovec_t,
        si_data_len: usize,
        si_flags: __wasi_siflags_t,
        so_datalen: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_sock_shutdown(fd: __wasi_fd_t, how: __wasi_sdflags_t) -> __wasi_errno_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::std::os::raw::c_char; 16usize],
    pub __lldata: ::std::os::raw::c_longlong,
    pub __align: f64,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lldata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__lldata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type fpos_t = _G_fpos64_t;
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE);
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets_unlocked(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs_unlocked(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
extern "C" {
    pub fn fopencookie(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: cookie_io_functions_t,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __clockid {
    _unused: [u8; 0],
}
pub type clockid_t = *const __clockid;
pub type clock_t = ::std::os::raw::c_longlong;
pub type register_t = ::std::os::raw::c_longlong;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type mode_t = ::std::os::raw::c_uint;
pub type nlink_t = ::std::os::raw::c_ulonglong;
pub type ino_t = ::std::os::raw::c_ulonglong;
pub type dev_t = ::std::os::raw::c_ulonglong;
pub type blksize_t = ::std::os::raw::c_long;
pub type blkcnt_t = ::std::os::raw::c_longlong;
pub type fsblkcnt_t = ::std::os::raw::c_ulonglong;
pub type fsfilcnt_t = ::std::os::raw::c_ulonglong;
pub type timer_t = *mut ::std::os::raw::c_void;
pub type pid_t = ::std::os::raw::c_int;
pub type id_t = ::std::os::raw::c_uint;
pub type uid_t = ::std::os::raw::c_uint;
pub type gid_t = ::std::os::raw::c_uint;
pub type key_t = ::std::os::raw::c_int;
pub type useconds_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread {
    _unused: [u8; 0],
}
pub type pthread_t = *mut __pthread;
pub type pthread_once_t = ::std::os::raw::c_int;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr_t {
    pub __attr: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__attr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_t {
    pub __u: pthread_attr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 9usize],
    pub __vi: [::std::os::raw::c_int; 9usize],
    pub __s: [::std::os::raw::c_ulong; 9usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(pthread_attr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t__bindgen_ty_1),
            "::",
            stringify!(__s)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        36usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t {
    pub __u: pthread_mutex_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 6usize],
    pub __vi: [::std::os::raw::c_int; 6usize],
    pub __p: [*mut ::std::os::raw::c_void; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_cond_t {
    pub __u: pthread_cond_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 12usize],
    pub __vi: [::std::os::raw::c_int; 12usize],
    pub __p: [*mut ::std::os::raw::c_void; 12usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __u: pthread_rwlock_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 8usize],
    pub __vi: [::std::os::raw::c_int; 8usize],
    pub __p: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub __u: pthread_barrier_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 5usize],
    pub __vi: [::std::os::raw::c_int; 5usize],
    pub __p: [*mut ::std::os::raw::c_void; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(pthread_barrier_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__vi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t__bindgen_ty_1),
            "::",
            stringify!(__p)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        20usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__u)
        )
    );
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type ushort = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type quad_t = ::std::os::raw::c_longlong;
pub type u_quad_t = ::std::os::raw::c_ulonglong;
pub type sigset_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __nfds: usize,
    pub __fds: [::std::os::raw::c_int; 1024usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        4100usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nfds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__nfds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds)
        )
    );
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_nlink: nlink_t,
    pub st_mode: mode_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub __pad0: ::std::os::raw::c_uint,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub st_blksize: blksize_t,
    pub st_blocks: blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __reserved: [::std::os::raw::c_longlong; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__reserved)
        )
    );
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(arg1: ::std::os::raw::c_int, arg2: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const timespec,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn strtof_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> f32;
}
extern "C" {
    pub fn strtod_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> f64;
}
extern "C" {
    pub fn strtold_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut __locale_struct,
    ) -> u128;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4random_uniform(arg1: u32) -> u32;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __dst: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
pub type locale_t = *mut __locale_struct;
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn strverscmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_void,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(increment: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_close(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn __wasilibc_tell(arg1: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn usleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn getentropy(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocates a  storage instance.  It is  largely the same as  system malloc(),\n except:\n\n   - It raises Ruby exceptions instead of returning NULL, and\n   - In case of `ENOMEM` it tries to GC to make some room.\n\n @param[in]  size            Requested amount of memory.\n @exception  rb_eNoMemError  No space left for `size` bytes allocation.\n @return     A valid pointer  to an allocated storage instance;  which has at\n             least `size` bytes width, with appropriate alignment detected by\n             the underlying malloc() routine.\n @note       It doesn't return NULL.\n @note       Unlike some malloc() implementations, it allocates something and\n             returns a meaningful value even when `size` is equal to zero.\n @warning    The return  value shall  be invalidated  exactly once  by either\n             ruby_xfree(),  ruby_xrealloc(), or  ruby_xrealloc2().   It is  a\n             failure to pass it to system free(), because the system and Ruby\n             might or might not share the same malloc() implementation."]
    pub fn ruby_xmalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Identical to ruby_xmalloc(), except it allocates `nelems` * `elemsiz` bytes.\n This is needed  because the multiplication could integer  overflow.  On such\n situations  Ruby does  not try  to  allocate at  all but  raises Ruby  level\n exceptions  instead.  If  there  is  no integer  overflow  the behaviour  is\n exactly the same as `ruby_xmalloc(nelems*elemsiz)`.\n\n @param[in]  nelems          Number of elements.\n @param[in]  elemsiz         Size of an element.\n @exception  rb_eNoMemError  No space left for allocation.\n @exception  rb_eArgError    `nelems` * `elemsiz` would overflow.\n @return     A valid pointer  to an allocated storage instance;  which has at\n             least  `nelems`  *  `elemsiz`   bytes  width,  with  appropriate\n             alignment detected by the underlying malloc() routine.\n @note       It doesn't return NULL.\n @note       Unlike some malloc() implementations, it allocates something and\n             returns a  meaningful value even  when `nelems` or  `elemsiz` or\n             both are zero.\n @warning    The return  value shall  be invalidated  exactly once  by either\n             ruby_xfree(),  ruby_xrealloc(), or  ruby_xrealloc2().   It is  a\n             failure to pass it to system free(), because the system and Ruby\n             might or might not share the same malloc() implementation."]
    pub fn ruby_xmalloc2(nelems: usize, elemsiz: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Identical  to  ruby_xmalloc2(),  except  it returns  a  zero-filled  storage\n instance.  It  can also be  seen as  a routine identical  to ruby_xmalloc(),\n except it calls calloc() instead of malloc().\n\n @param[in]  nelems          Number of elements.\n @param[in]  elemsiz         Size of an element.\n @exception  rb_eNoMemError  No space left for allocation.\n @exception  rb_eArgError    `nelems` * `elemsiz` would overflow.\n @return     A valid pointer  to an allocated storage instance;  which has at\n             least  `nelems`  *  `elemsiz`   bytes  width,  with  appropriate\n             alignment detected by the underlying calloc() routine.\n @post       The returned storage instance is filled with zeros.\n @note       It doesn't return NULL.\n @note       Unlike some calloc() implementations, it allocates something and\n             returns a  meaningful value even  when `nelems` or  `elemsiz` or\n             both are zero.\n @warning    The return  value shall  be invalidated  exactly once  by either\n             ruby_xfree(),  ruby_xrealloc(), or  ruby_xrealloc2().   It is  a\n             failure to pass it to system free(), because the system and Ruby\n             might or might not share the same malloc() implementation."]
    pub fn ruby_xcalloc(nelems: usize, elemsiz: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Resize the storage instance.\n\n @param[in]  ptr             A valid  pointer to a storage  instance that was\n                             previously returned from either:\n                               - ruby_xmalloc(),\n                               - ruby_xmalloc2(),\n                               - ruby_xcalloc(),\n                               - ruby_xrealloc(), or\n                               - ruby_xrealloc2().\n @param[in]  newsiz          Requested new amount of memory.\n @exception  rb_eNoMemError  No space left for `newsiz` bytes allocation.\n @return     A  valid  pointer  to   a  (possibly  newly  allocated)  storage\n             instance;  which  has  at   least  `newsiz`  bytes  width,  with\n             appropriate  alignment  detected  by  the  underlying  realloc()\n             routine.\n @pre        The passed pointer must point  to a valid live storage instance.\n             It is a failure to pass an already freed pointer.\n @post       In  case the  function  returns the  passed  pointer as-is,  the\n             storage  instance that  the  pointer holds  is  either grown  or\n             shrunken  to have  at least  `newsiz` bytes.  Otherwise a  valid\n             pointer to a  newly allocated storage instance  is returned.  In\n             this  case  `ptr`  is  invalidated   as  if  it  was  passed  to\n             ruby_xfree().\n @note       It doesn't return NULL.\n @warning    Unlike some realloc() implementations,  passing zero to `newsiz`\n             is not the  same as calling ruby_xfree(),  because this function\n             never returns NULL.  Something meaningful still returns then.\n @warning    It is  a failure not to  check the return value.   Do not assume\n             anything on  it.  It could  be either identical to,  or distinct\n             form the passed argument.\n @warning    Do not  assume anything  on the alignment  of the  return value.\n             There is  no guarantee  that it  inherits the  passed argument's\n             one.\n @warning    The return  value shall  be invalidated  exactly once  by either\n             ruby_xfree(),  ruby_xrealloc(), or  ruby_xrealloc2().   It is  a\n             failure to pass it to system free(), because the system and Ruby\n             might or might not share the same malloc() implementation."]
    pub fn ruby_xrealloc(
        ptr: *mut ::std::os::raw::c_void,
        newsiz: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Identical to ruby_xrealloc(),  except it resizes the  given storage instance\n to `newelems` *  `newsiz` bytes.  This is needed  because the multiplication\n could integer overflow.   On such situations Ruby does not  try to touch the\n contents  of  argument pointer  at  all  but  raises Ruby  level  exceptions\n instead.  If there is no integer  overflow the behaviour is exactly the same\n as `ruby_xrealloc(ptr,nelems*elemsiz)`.\n\n This  is   roughly  the  same   as  reallocarray()  function   that  OpenBSD\n etc. provides, but also interacts with our GC.\n\n @param[in]  ptr             A valid  pointer to a storage  instance that was\n                             previously returned from either:\n                               - ruby_xmalloc(),\n                               - ruby_xmalloc2(),\n                               - ruby_xcalloc(),\n                               - ruby_xrealloc(), or\n                               - ruby_xrealloc2().\n @param[in]  newelems        Requested new number of elements.\n @param[in]  newsiz          Requested new size of each element.\n @exception  rb_eNoMemError  No space left for  allocation.\n @exception  rb_eArgError    `newelems` * `newsiz` would overflow.\n @return     A  valid  pointer  to   a  (possibly  newly  allocated)  storage\n             instance; which has at least  `newelems` * `newsiz` bytes width,\n             with appropriate alignment detected  by the underlying realloc()\n             routine.\n @pre        The passed pointer must point  to a valid live storage instance.\n             It is a failure to pass an already freed pointer.\n @post       In  case the  function  returns the  passed  pointer as-is,  the\n             storage  instance that  the  pointer holds  is  either grown  or\n             shrunken  to   have  at  least  `newelems`   *  `newsiz`  bytes.\n             Otherwise a valid pointer to  a newly allocated storage instance\n             is returned.   In this case  `ptr` is  invalidated as if  it was\n             passed to ruby_xfree().\n @note       It doesn't return NULL.\n @warning    Unlike some  realloc() implementations,  passing zero  to either\n             `newelems`   or  `elemsiz`   are   not  the   same  as   calling\n             ruby_xfree(),   because  this   function  never   returns  NULL.\n             Something meaningful still returns then.\n @warning    It is  a failure not to  check the return value.   Do not assume\n             anything on  it.  It could  be either identical to,  or distinct\n             form the passed argument.\n @warning    Do not  assume anything  on the alignment  of the  return value.\n             There is  no guarantee  that it  inherits the  passed argument's\n             one.\n @warning    The return  value shall  be invalidated  exactly once  by either\n             ruby_xfree(),  ruby_xrealloc(), or  ruby_xrealloc2().   It is  a\n             failure to pass it to system free(), because the system and Ruby\n             might or might not share the same malloc() implementation."]
    pub fn ruby_xrealloc2(
        ptr: *mut ::std::os::raw::c_void,
        newelems: usize,
        newsiz: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Deallocates a storage instance.\n\n @param[out]  ptr  Either\n                     - NULL, or\n                     - a valid pointer previously returned from one of:\n                       - ruby_xmalloc(),\n                       - ruby_xmalloc2(),\n                       - ruby_xcalloc(),\n                       - ruby_xrealloc(), or\n                       - ruby_xrealloc2().\n @pre         The passed pointer must point to a valid live storage instance.\n              It is a failure to pass an already freed pointer.\n @post        The  storage  instance  pointed  by  the  passed  pointer  gets\n              invalidated; it is no longer addressable.\n @warning     Every single storage instance  that was previously allocated by\n              either    ruby_xmalloc(),   ruby_xmalloc2(),    ruby_xcalloc(),\n              ruby_xrealloc(),  or  ruby_xrealloc2()   shall  be  invalidated\n              exactly once by  either passing it to  ruby_xfree(), or passing\n              it to  either ruby_xrealloc(), ruby_xrealloc2() then  check the\n              return value for invalidation.\n @warning     Do not pass anything other  than pointers described above.  For\n              instance pointers returned from malloc() or mmap() shall not be\n              passed  to   this  function,  because  the   underlying  memory\n              management mechanism could differ.\n @warning     Do  not pass  any invalid  pointers  to this  function e.g.  by\n              calling it twice with a same argument."]
    pub fn ruby_xfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rb_assert_failure(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalbf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
extern "C" {
    pub fn significandf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sincos(arg1: f64, arg2: *mut f64, arg3: *mut f64);
}
extern "C" {
    pub fn sincosf(arg1: f32, arg2: *mut f32, arg3: *mut f32);
}
extern "C" {
    pub fn sincosl(arg1: u128, arg2: *mut u128, arg3: *mut u128);
}
extern "C" {
    pub fn exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn pow10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn pow10l(arg1: u128) -> u128;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_int,
    pub tm_zone: *const ::std::os::raw::c_char,
    pub __tm_nsec: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        48usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__tm_nsec) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_nsec)
        )
    );
}
extern "C" {
    pub static _CLOCK_MONOTONIC: __clockid;
}
extern "C" {
    pub static _CLOCK_PROCESS_CPUTIME_ID: __clockid;
}
extern "C" {
    pub static _CLOCK_REALTIME: __clockid;
}
extern "C" {
    pub static _CLOCK_THREAD_CPUTIME_ID: __clockid;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn timespec_get(arg1: *mut timespec, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strftime_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
        arg5: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn nanosleep(arg1: *const timespec, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(arg1: clockid_t, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(arg1: clockid_t, arg2: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        arg1: clockid_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const timespec,
        arg4: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn eaccess(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setproctitle(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn posix_madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn ruby_abi_version() -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __assert_fail(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type VALUE = ::std::os::raw::c_ulong;
pub type ID = ::std::os::raw::c_ulong;
extern "C" {
    #[doc = " Creates a new, anonymous class.\n\n @param[in]  super          What would become a parent class.\n @exception  rb_eTypeError  `super` is not something inheritable.\n @return     An anonymous class that inherits `super`."]
    pub fn rb_class_new(super_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " The comment  that comes with  this function  says `:nodoc:`.  Not  sure what\n that means though.\n\n @param[out]  clone          Destination object.\n @param[in]   orig           Source object.\n @exception   rb_eTypeError  Cannot copy `orig`.\n @return      The passed `clone`."]
    pub fn rb_mod_init_copy(clone: VALUE, orig: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Asserts that  the given class  can derive a child  class.  A class  might or\n might not be able to do so; for instance a singleton class cannot.\n\n @param[in]  super          Possible super class.\n @exception  rb_eTypeError  No it cannot.\n @post       Upon successful return `super` can derive."]
    pub fn rb_check_inheritable(super_: VALUE);
}
extern "C" {
    #[doc = " This is a very badly designed API that creates an anonymous class.\n\n @param[in]  id             Discarded for no reason (why...).\n @param[in]  super          What  would  become  a  parent  class.   0  means\n                            ::rb_cObject.\n @exception  rb_eTypeError  `super` is not something inheritable.\n @return     An anonymous class that inherits `super`.\n @warning    You must explicitly name the return value."]
    pub fn rb_define_class_id(id: ID, super_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_define_class_under(),  except  it takes  the  name in  ::ID\n instead of C's string.\n\n @param[out]  outer          A class which contains the new class.\n @param[in]   id             Name of the new class\n @param[in]   super          A class from which the new class will derive.\n                             0 means ::rb_cObject.\n @exception   rb_eTypeError  The constant name `id`  is already taken but the\n                             constant is not a class.\n @exception   rb_eTypeError  The class  is already defined but  the class can\n                             not be  reopened because  its superclass  is not\n                             `super`.\n @exception   rb_eArgError   `super` is NULL.\n @return      The created class.\n @post        `outer::id` refers the returned class.\n @note        If a class named `id` is  already defined and its superclass is\n              `super`, the function just returns the defined class.\n @note        The  compaction  GC does  not  move  classes returned  by  this\n              function."]
    pub fn rb_define_class_id_under(outer: VALUE, id: ID, super_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a new, anonymous module.\n\n @return An anonymous module."]
    pub fn rb_module_new() -> VALUE;
}
extern "C" {
    #[doc = " Creates a new, anonymous refinement.\n\n @return An anonymous refinement."]
    pub fn rb_refinement_new() -> VALUE;
}
extern "C" {
    #[doc = " This is a very badly designed API that creates an anonymous module.\n\n @param[in]  id  Discarded for no reason (why...).\n @return     An anonymous module.\n @warning    You must explicitly name the return value."]
    pub fn rb_define_module_id(id: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_define_module_under(),  except it  takes the  name in  ::ID\n instead of C's string.\n\n @param[out]  outer          A class which contains the new module.\n @param[in]   id             Name of the new module\n @exception   rb_eTypeError  The constant name `id`  is already taken but the\n                             constant is not a module.\n @return      The created module.\n @post        `outer::id` refers the returned module.\n @note        The  compaction  GC does  not  move  classes returned  by  this\n              function."]
    pub fn rb_define_module_id_under(outer: VALUE, id: ID) -> VALUE;
}
extern "C" {
    #[doc = " Queries the list of  included modules.  It can also be seen  as a routine to\n first  call rb_mod_ancestors(),  then  rejects non-modules  from the  return\n value.\n\n @param[in]  mod  Class or Module.\n @return     An array of modules that are either included or prepended in any\n             of `mod`'s ancestry tree (including itself)."]
    pub fn rb_mod_included_modules(mod_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the passed module is included by the module.  It can also be seen\n as a routine to first call rb_mod_included_modules(), then see if the return\n value contains the passed module.\n\n @param[in]  child          A Module.\n @param[in]  parent         Another Module.\n @exception  rb_eTypeError  `child` is not an instance of ::rb_cModule.\n @retval     RUBY_Qtrue     `parent` is  either included or prepended  in any\n                            of `child`'s ancestry tree (including itself).\n @return     RUBY_Qfalse    Otherwise."]
    pub fn rb_mod_include_p(child: VALUE, parent: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the  module's ancestors.  This routine gathers classes  and modules\n that  the  passed  module  either  inherits,  includes,  or  prepends,  then\n recursively applies  that routine again  and again to the  collected entries\n until the list doesn't grow up.\n\n @param[in]  mod  A module or a class.\n @return     An array of  classes or modules that  `mod` possibly recursively\n             inherits, includes, or prepends.\n\n @internal\n\n Above description  is written  in a  recursive language  but in  practice it\n computes the return value iteratively."]
    pub fn rb_mod_ancestors(mod_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the class's descendants. This  routine gathers classes that are\n subclasses of the given class (or subclasses of those subclasses, etc.),\n returning an array of classes that have the given class as an ancestor.\n The returned array does not include the given class or singleton classes.\n\n @param[in]  klass A class.\n @return     An array of classes where `klass` is an ancestor.\n\n @internal"]
    pub fn rb_class_descendants(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the class's direct descendants. This  routine gathers classes that are\n direct subclasses of the given class,\n returning an array of classes that have the given class as a superclass.\n The returned array does not include singleton classes.\n\n @param[in]  klass A class.\n @return     An array of classes where `klass` is the `superclass`.\n\n @internal"]
    pub fn rb_class_subclasses(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = "  Returns the attached object for a singleton class.\n  If the given class is not a singleton class, raises a TypeError.\n\n @param[in]  klass A class.\n @return     The object which has the singleton class `klass`.\n\n @internal"]
    pub fn rb_class_attached_object(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Generates an array of symbols, which are the list of method names defined in\n the passed class.\n\n @param[in]  argc          Number of objects of `argv`.\n @param[in]  argv          Array of  at most  one object, which  controls (if\n                           any) whether  the return array includes  the names\n                           of methods defined in ancestors or not.\n @param[in]  mod           A module or a class.\n @exception  rb_eArgError  `argc` out of range.\n @return     An array  of symbols collecting  names of instance  methods that\n             are not private, defined at `mod`."]
    pub fn rb_class_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_class_instance_methods(), except it returns names of methods\n that are public only.\n\n @param[in]  argc          Number of objects of `argv`.\n @param[in]  argv          Array of  at most  one object, which  controls (if\n                           any) whether  the return array includes  the names\n                           of methods defined in ancestors or not.\n @param[in]  mod           A module or a class.\n @exception  rb_eArgError  `argc` out of range.\n @return     An array  of symbols collecting  names of instance  methods that\n             are public, defined at `mod`."]
    pub fn rb_class_public_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_class_instance_methods(), except it returns names of methods\n that are protected only.\n\n @param[in]  argc          Number of objects of `argv`.\n @param[in]  argv          Array of  at most  one object, which  controls (if\n                           any) whether  the return array includes  the names\n                           of methods defined in ancestors or not.\n @param[in]  mod           A module or a class.\n @exception  rb_eArgError  `argc` out of range.\n @return     An array  of symbols collecting  names of instance  methods that\n             are protected, defined at `mod`."]
    pub fn rb_class_protected_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_class_instance_methods(), except it returns names of methods\n that are private only.\n\n @param[in]  argc          Number of objects of `argv`.\n @param[in]  argv          Array of  at most  one object, which  controls (if\n                           any) whether  the return array includes  the names\n                           of methods defined in ancestors or not.\n @param[in]  mod           A module or a class.\n @exception  rb_eArgError  `argc` out of range.\n @return     An array  of symbols collecting  names of instance  methods that\n             are protected, defined at `mod`."]
    pub fn rb_class_private_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_class_instance_methods(),  except   it  returns  names  of\n singleton methods instead of instance methods.\n\n @param[in]  argc          Number of objects of `argv`.\n @param[in]  argv          Array of  at most  one object, which  controls (if\n                           any) whether  the return array includes  the names\n                           of methods defined in ancestors or not.\n @param[in]  obj           Arbitrary ruby object.\n @exception  rb_eArgError  `argc` out of range.\n @return     An array  of symbols collecting  names of instance  methods that\n             are not private, defined at the singleton class of `obj`."]
    pub fn rb_obj_singleton_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        obj: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_define_method(),  except it takes the name of  the method in\n ::ID instead of C's string.\n\n @param[out]  klass  A module or a class.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_method_id"]
    pub fn rb_define_method_id(
        klass: VALUE,
        mid: ID,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Inserts a  method entry that hides  previous method definition of  the given\n name.  This is not a deletion of  a method.  Method of the same name defined\n in a parent class is kept invisible in this way.\n\n @param[out]  mod              The module to insert an undef.\n @param[in]   mid              Name of the undef.\n @exception   rb_eTypeError    `klass` is a non-module.\n @exception   rb_eFrozenError  `klass` is frozen.\n @exception   rb_eNameError    No such method named `klass#name`.\n @post        `klass#name` is undefined.\n @see         rb_undef_method\n\n @internal\n\n @shyouhei doesn't  understand why this  is not  the ::ID -taking  variant of\n rb_undef_method(), given rb_remove_method() has its ::ID -taking counterpart\n named rb_remove_method_id()."]
    pub fn rb_undef(mod_: VALUE, mid: ID);
}
extern "C" {
    #[doc = " Identical to rb_define_method(), except it defines a protected method.\n\n @param[out]  klass  A module or a class.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_protected_method"]
    pub fn rb_define_protected_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Identical to rb_define_method(), except it defines a private method.\n\n @param[out]  klass  A module or a class.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_protected_method"]
    pub fn rb_define_private_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Identical to rb_define_method(), except it defines a singleton method.\n\n @param[out]  obj    Arbitrary ruby object.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_singleton_method"]
    pub fn rb_define_singleton_method(
        obj: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Finds or creates the singleton class of the passed object.\n\n @param[out]  obj            Arbitrary ruby object.\n @exception   rb_eTypeError  `obj` cannot have its singleton class.\n @return      A (possibly newly allocated) instance of ::rb_cClass.\n @post        `obj` has its singleton class, which is the return value.\n @post        In case `obj` is a class, the returned singleton class also has\n              its own  singleton class  in order to  keep consistency  of the\n              inheritance structure of metaclasses.\n @note        A new  singleton class will  be created  if `obj` did  not have\n              one.\n @note        The  singleton  classes   for  ::RUBY_Qnil,  ::RUBY_Qtrue,  and\n              ::RUBY_Qfalse   are    ::rb_cNilClass,   ::rb_cTrueClass,   and\n              ::rb_cFalseClass respectively.\n\n @internal\n\n You can _create_ a singleton class of a frozen object.  Intentional or ...?\n\n Nowadays there are wider range of  objects who cannot have singleton classes\n than before.  For instance some string instances cannot for some reason."]
    pub fn rb_singleton_class(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `__LINE__`.\n\n @retval  0          Current execution context not in a ruby method.\n @retval  otherwise  The current  line number  of the  current thread  of the\n                     current ractor of the current execution context."]
    pub fn rb_sourceline() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resembles `__FILE__`.\n\n @retval  0          Current execution context not in a ruby method.\n @retval  otherwise  The current  source path  of the  current thread  of the\n                     current ractor of the current execution context.\n @note    This may or may not be an absolute path."]
    pub fn rb_sourcefile() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Resembles `__method__`.\n\n @param[out]  idp     Return buffer for method id.\n @param[out]  klassp  Return buffer for class.\n @retval      0       Current execution context not in a method.\n @retval      1       Successful return.\n @post        Upon successful return `*idp` and `*klassp` are updated to have\n              the current method name and its defined class respectively.\n @note        Both parameters can be `NULL`."]
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical  to  rb_funcallv(), except  it  returns  ::RUBY_Qundef instead  of\n raising ::rb_eNoMethodError.\n\n @param[in,out]  recv         Receiver of the method.\n @param[in]      mid          Name of the method to call.\n @param[in]      argc         Number of arguments.\n @param[in]      argv         Arbitrary number of method arguments.\n @retval         RUBY_Qundef  `recv` doesn't respond to `mid`.\n @retval         otherwise    What the method evaluates to."]
    pub fn rb_check_funcall(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_check_funcall(), except you  can specify how to  handle the\n last element of the given array.  It can also be seen as a routine identical\n to  rb_funcallv_kw(), except  it  returns ::RUBY_Qundef  instead of  raising\n ::rb_eNoMethodError.\n\n @param[in,out]  recv         Receiver of the method.\n @param[in]      mid          Name of the method to call.\n @param[in]      argc         Number of arguments.\n @param[in]      argv         Arbitrary number of method arguments.\n @param[in]      kw_splat     Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @retval         RUBY_Qundef  `recv` doesn't respond to `mid`.\n @retval         otherwise    What the method evaluates to."]
    pub fn rb_check_funcall_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " This API  is practically a  variant of rb_proc_call_kw()  now.  Historically\n when there  still was a  concept called `$SAFE`, this  was an API  for that.\n But we  no longer have  that.  This function  basically ended its  role.  It\n just remains here because of no harm.\n\n @param[in]  cmd       A string, or something callable.\n @param[in]  arg       Argument passed to the call.\n @param[in]  kw_splat  Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `arg`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `arg`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @return     What the command evaluates to."]
    pub fn rb_eval_cmd_kw(cmd: VALUE, arg: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_funcallv(), except it takes Ruby's array instead of C's.\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      args               An instance of ::RArray.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to.\n @pre            `args` must  be an ::RArray.  Call  `to_ary` beforehand when\n                 necessary."]
    pub fn rb_apply(recv: VALUE, mid: ID, args: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Evaluates a string  containing Ruby source code, or the  given block, within\n the  context of  the receiver.  In order  to set  the context,  the variable\n `self` is set to `recv` while the  code is executing, giving the code access\n to `recv`'s instance variables and private methods.\n\n When given a block, `recv` is also passed in as the block's only argument.\n\n When  given a  string, the  optional second  and third  parameters supply  a\n filename and starting  line number that are used  when reporting compilation\n errors.\n\n @param[in]  argc  Number of objects in `argv`\n @param[in]  argv  C array of 0 up to 3 elements.\n @param[in]  recv  The object in question.\n @return     What was evaluated."]
    pub fn rb_obj_instance_eval(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Executes the  given block within the  context of the receiver.   In order to\n set the  context, the  variable `self` is  set to `recv`  while the  code is\n executing, giving the code access to `recv`'s instance variables.  Arguments\n are passed as block parameters.\n\n @param[in]  argc  Number of objects in `argv`\n @param[in]  argv  Arbitrary parameters to be passed to the block.\n @param[in]  recv  The object in question.\n @return     What was evaluated.\n @note       Don't  confuse   this  with  rb_obj_instance_eval().    The  key\n             difference is whether  you can pass arbitrary  parameters to the\n             block, like this:\n\n ```ruby\n class Foo\n   def initialize\n     @foo = 5\n   end\n end\n Foo.new.instance_exec(7) {|i| @foo + i } # => 12\n ```"]
    pub fn rb_obj_instance_exec(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_obj_instance_eval(), except  it evaluates within the context\n of module.\n\n @param[in]  argc  Number of objects in `argv`\n @param[in]  argv  C array of 0 up to 3 elements.\n @param[in]  mod   The module in question.\n @pre        `mod` must be a Module.\n @return     What was evaluated."]
    pub fn rb_mod_module_eval(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_obj_instance_exec(), except  it evaluates within the context\n of module.\n\n @param[in]  argc  Number of objects in `argv`\n @param[in]  argv  Arbitrary parameters to be passed to the block.\n @param[in]  mod   The module in question.\n @pre        `mod` must be a Module.\n @return     What was evaluated."]
    pub fn rb_mod_module_exec(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
#[doc = " This is  the type of  functions that ruby calls  when trying to  allocate an\n object.  It is  sometimes necessary to allocate extra memory  regions for an\n object.  When you define a class that uses ::RTypedData, it is typically the\n case.  On  such situations  define a function  of this type  and pass  it to\n rb_define_alloc_func().\n\n @param[in]  klass  The class that this function is registered.\n @return     A newly allocated instance of `klass`."]
pub type rb_alloc_func_t = ::std::option::Option<unsafe extern "C" fn(klass: VALUE) -> VALUE>;
extern "C" {
    #[doc = " Sets the allocator function of a class.\n\n @param[out]  klass  The class to modify.\n @param[in]   func   An allocator function for the class.\n @pre         `klass` must be an instance of Class."]
    pub fn rb_define_alloc_func(klass: VALUE, func: rb_alloc_func_t);
}
extern "C" {
    #[doc = " Deletes the  allocator function of  a class.   It is sometimes  desirable to\n restrict creation  of an instance of  a class.  For example  it rarely makes\n sense for  a DB adaptor class  to allow programmers creating  DB row objects\n without querying  the DB  itself.  You  can kill  sporadic creation  of such\n objects then,  by nullifying  the allocator function  using this  API.  Your\n object shall be allocated using #RB_NEWOBJ_OF() directly.\n\n @param[out]  klass  The class to modify.\n @pre         `klass` must be an instance of Class."]
    pub fn rb_undef_alloc_func(klass: VALUE);
}
extern "C" {
    #[doc = " Queries the allocator function of a class.\n\n @param[in]  klass      The class in question.\n @pre        `klass` must be an instance of Class.\n @retval     0          No allocator function is registered.\n @retval     otherwise  The allocator function.\n\n @internal\n\n Who cares?  @shyouhei finds no practical usage of the return value.  Maybe we\n need KonMari."]
    pub fn rb_get_alloc_func(klass: VALUE) -> rb_alloc_func_t;
}
extern "C" {
    #[doc = " Clears the inline constant caches associated with a particular ID. Extension\n libraries should not bother with such things. Just forget about this API (or\n even, the presence of constant caches)."]
    pub fn rb_clear_constant_cache_for_id(id: ID);
}
extern "C" {
    #[doc = " Resembles `alias`.\n\n @param[out]  klass            Where to define an alias.\n @param[in]   dst              New name.\n @param[in]   src              Existing name.\n @exception   rb_eTypeError    `klass` is not a class.\n @exception   rb_eFrozenError  `klass` is frozen.\n @exception   rb_eNameError    No such method named `src`.\n @post        `klass` has a method named `dst`, which is the identical to its\n              method named `src`."]
    pub fn rb_alias(klass: VALUE, dst: ID, src: ID);
}
extern "C" {
    #[doc = " This function resembles now-deprecated `Module#attr`.\n\n @param[out]  klass              Where to define an attribute.\n @param[in]   name               Name of an instance variable.\n @param[in]   need_reader        Whether attr_reader is needed.\n @param[in]   need_writer        Whether attr_writer is needed.\n @param[in]   honour_visibility  Whether to use the current visibility.\n @exception   rb_eTypeError      `klass` is not a class.\n @exception   rb_eFrozenError    `klass` is frozen.\n @post        If `need_reader` is set `klass` has a method named `name`.\n @post        If `need_writer` is set `klass` has a method named `name=`.\n\n @internal\n\n The three `int` arguments should have been bool, but there was no such thing\n like a bool when K&R was used in this project."]
    pub fn rb_attr(
        klass: VALUE,
        name: ID,
        need_reader: ::std::os::raw::c_int,
        need_writer: ::std::os::raw::c_int,
        honour_visibility: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Removes a  method.  Don't confuse  this to rb_undef_method(),  which doesn't\n remove a method.  This one resembles `Module#remove_method`.\n\n @param[out]  klass            The class to remove a method.\n @param[in]   name             Name of a method to be removed.\n @exception   rb_eTypeError    `klass` is a non-module.\n @exception   rb_eFrozenError  `klass` is frozen.\n @exception   rb_eNameError    No such method.\n @see         rb_undef_method"]
    pub fn rb_remove_method(klass: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical to rb_remove_method(), except it accepts the method name as ::ID.\n\n @param[out]  klass            The class to remove a method.\n @param[in]   mid              Name of a method to be removed.\n @exception   rb_eTypeError    `klass` is a non-module.\n @exception   rb_eFrozenError  `klass` is frozen.\n @exception   rb_eNameError    No such method.\n @see         rb_undef"]
    pub fn rb_remove_method_id(klass: VALUE, mid: ID);
}
extern "C" {
    #[doc = " Queries if the  klass has this method.   This function has only  one line of\n document in the implementation that states \"// deprecated\".  Don't know what\n that means though.\n\n @param[in]  klass  The class in question.\n @param[in]  id     The method name to query.\n @param[in]  ex     Undocumented magic value.\n @retval     false  Method not found.\n @retval     true   There is a method.\n @pre        `klass` must be a module.\n\n @internal\n\n @shyouhei has no  motivation to describe what should be  passed to `ex`.  It\n seems this function should just be trashed."]
    pub fn rb_method_boundp(
        klass: VALUE,
        id: ID,
        ex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Well...  Let us hesitate from describing what a \"basic definition\" is.  This\n nuanced concept  should have been  kept private.  Just please.   Don't touch\n it.  This function is a badly distributed random number generator.  Right?\n\n @param[in]  klass  The class in question.\n @param[in]  mid    The method name in question.\n @retval     1      It is.\n @retval     0      It isn't."]
    pub fn rb_method_basic_definition_p(klass: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to  rb_respond_to(), except  it additionally takes  the visibility\n parameter.   This   does  not   make  difference   unless  the   object  has\n `respond_to?` undefined,  but has `respond_to_missing?` defined.   That case\n the passed argument becomes the second argument of `respond_to_missing?`.\n\n @param[in]  obj        The object in question.\n @param[in]  mid        The method name in question.\n @param[in]  private_p  This    is   the    second   argument    of   `obj`'s\n                        `respond_to_missing?`.\n @retval     1          Yes it does.\n @retval     0          No it doesn't."]
    pub fn rb_obj_respond_to(
        obj: VALUE,
        mid: ID,
        private_p: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries if  the object responds  to the  method.  This involves  calling the\n object's `respond_to?` method.\n\n @param[in]  obj        The object in question.\n @param[in]  mid        The method name in question.\n @retval     1          Yes it does.\n @retval     0          No it doesn't."]
    pub fn rb_respond_to(obj: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Raises  ::rb_eNotImpError.   This  function  is   used  as  an  argument  to\n rb_define_method() etc.\n\n ```CXX\n rb_define_method(rb_cFoo, \"foo\", rb_f_notimplement, -1);\n ```\n\n @param     argc             Unused parameter.\n @param     argv             Unused parameter.\n @param     obj              Unused parameter.\n @param     marker           Unused parameter.\n @exception rb_eNotImpError  Always.\n @return    Never returns.\n\n @internal\n\n See also the Q&A section of include/ruby/internal/anyargs.h."]
    pub fn rb_f_notimplement(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        obj: VALUE,
        marker: VALUE,
    ) -> !;
}
extern "C" {
    #[doc = " Prints the backtrace  out to the standard error.  This  just confuses people\n for no reason.  Evil souls must only use it.\n\n @internal\n\n Actually it is very useful when called from an interactive GDB session."]
    pub fn rb_backtrace();
}
extern "C" {
    #[doc = " Creates the good old fashioned array-of-strings style backtrace info.\n\n @return  An   array  which   contains   strings,  which   are  the   textual\n          representations of the backtrace locations of the current thread of\n          the current ractor of the current execution context.\n @note    Ruby      scripts      can      access      more      sophisticated\n          `Thread::Backtrace::Location`.  But it seems there  is no way for C\n          extensions to use that API."]
    pub fn rb_make_backtrace() -> VALUE;
}
extern "C" {
    #[doc = " Defines a method.\n\n @param[out]  klass  A module or a class.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_method"]
    pub fn rb_define_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Defines a module function for a module.\n\n @param[out]  klass  A module or a class.\n @param[in]   mid    Name of the function.\n @param[in]   func   The method body.\n @param[in]   arity  The number of parameters.  See @ref defmethod.\n @note        There are in fact 18 different prototypes for func.\n @see         ::ruby::backward::cxxanyargs::define_method::rb_define_module_function"]
    pub fn rb_define_module_function(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Defines a global function.\n\n @param[in]  mid    Name of the function.\n @param[in]  func   The method body.\n @param[in]  arity  The number of parameters.  See @ref defmethod.\n @note       There are in fact 18 different prototypes for func.\n @see        ::ruby::backward::cxxanyargs::define_method::rb_define_global_function"]
    pub fn rb_define_global_function(
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Defines an undef of a method.  -- What?\n\n In ruby, there are two separate concepts called \"undef\" and \"remove_method\".\n The thing you imagine when you  \"un-define\" a method is remove_method.  This\n one on the  other hand is masking of a  previous method definition.  Suppose\n for instance:\n\n ```ruby\n class Foo\n   def foo\n   end\n end\n\n class Bar < Foo\n   def bar\n     foo\n   end\n end\n\n class Baz < Foo\n   undef foo            # <--- (*1)\n end\n ```\n\n This `undef foo` at `(*1)` must not eliminate `Foo#foo`, because that method\n is also used from `Bar#bar`.  So  instead of physically executing the target\n method, `undef` inserts  a special filtering entry to the  class (`Baz` this\n case).  That entry,  when called, acts as  if there were no  methods at all.\n But the original can still be accessible, via ways like `Bar#bar` above.\n\n @param[out]  klass            The class to insert an undef.\n @param[in]   name             Name of the undef.\n @exception   rb_eTypeError    `klass` is a non-module.\n @exception   rb_eFrozenError  `klass` is frozen.\n @see         rb_remove_method"]
    pub fn rb_undef_method(klass: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Defines an alias of a method.\n\n @param[in,out]  klass            The class which the original method belongs\n                                  to; this is also  where the new method will\n                                  belong to.\n @param[in]      dst              A new name for the method.\n @param[in]      src              The original name of the method.\n @exception      rb_eTypeError    `klass` is a non-module.\n @exception      rb_eFrozenError  `klass` is frozen.\n @exception      rb_eNameError    There is  no such method named  as `src` in\n                                  `klass`.\n\n @internal\n\n Above  description  is   in  fact  a  bit  inaccurate   because  it  ignores\n Refinements."]
    pub fn rb_define_alias(
        klass: VALUE,
        dst: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Defines public accessor method(s) for an attribute.\n\n @param[out]  klass            The class which the attribute will belong to.\n @param[in]   name             Name of the attribute.\n @param[in]   read             Whether to define a getter method.\n @param[in]   write            Whether to define a setter method.\n @exception   rb_eTypeError    `klass` is a non-module.\n @exception   rb_eFrozenError  `klass` is frozen.\n @exception   rb_eNameError    `name` invalid as an attr e.g. an operator."]
    pub fn rb_define_attr(
        klass: VALUE,
        name: *const ::std::os::raw::c_char,
        read: ::std::os::raw::c_int,
        write: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_3 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_3),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_4 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_4),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_5 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_5),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_5),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_6 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_6),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_6),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_7 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_7> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(_bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_7),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    #[doc = " Converts a C's `intptr_t` into an instance of ::rb_cInteger.\n\n @param[in]  i  Arbitrary `intptr_t` value.\n @return     An instance of ::rb_cInteger.\n @note       This function always allocates Bignums, even if the given number\n             is small enough to fit into a Fixnum."]
    pub fn rb_int2big(i: isize) -> VALUE;
}
extern "C" {
    #[doc = " Converts a C's `intptr_t` into an instance of ::rb_cInteger.\n\n @param[in]  i  Arbitrary `intptr_t` value.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_int2inum(i: isize) -> VALUE;
}
extern "C" {
    #[doc = " Converts a C's `intptr_t` into an instance of ::rb_cInteger.\n\n @param[in]  i  Arbitrary `intptr_t` value.\n @return     An instance of ::rb_cInteger.\n @note       This function always allocates Bignums, even if the given number\n             is small enough to fit into a Fixnum."]
    pub fn rb_uint2big(i: usize) -> VALUE;
}
extern "C" {
    #[doc = " Converts a C's `uintptr_t` into an instance of ::rb_cInteger.\n\n @param[in]  i  Arbitrary `uintptr_t` value.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_uint2inum(i: usize) -> VALUE;
}
pub const ruby_special_consts_RUBY_Qfalse: ruby_special_consts = 0;
pub const ruby_special_consts_RUBY_Qnil: ruby_special_consts = 2;
pub const ruby_special_consts_RUBY_Qtrue: ruby_special_consts = 6;
pub const ruby_special_consts_RUBY_Qundef: ruby_special_consts = 10;
pub const ruby_special_consts_RUBY_IMMEDIATE_MASK: ruby_special_consts = 3;
pub const ruby_special_consts_RUBY_FIXNUM_FLAG: ruby_special_consts = 1;
pub const ruby_special_consts_RUBY_FLONUM_MASK: ruby_special_consts = 0;
pub const ruby_special_consts_RUBY_FLONUM_FLAG: ruby_special_consts = 2;
pub const ruby_special_consts_RUBY_SYMBOL_FLAG: ruby_special_consts = 14;
#[doc = "< Least significant 8 bits are reserved."]
pub const ruby_special_consts_RUBY_SPECIAL_SHIFT: ruby_special_consts = 8;
#[doc = " special constants - i.e. non-zero and non-fixnum constants"]
pub type ruby_special_consts = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This is an utility function to raise an ::rb_eRangeError.\n\n @param[in]  num             A signed value about to overflow.\n @exception  rb_eRangeError  `num` is out of range of `int`."]
    pub fn rb_out_of_int(num: ::std::os::raw::c_long) -> !;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `long`.\n @return     The passed value converted into C's `long`."]
    pub fn rb_num2long(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `unsigned long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned long`.\n @return     The passed value converted into C's `unsigned long`."]
    pub fn rb_num2ulong(num: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `int`.\n @return     The passed value converted into C's `long`.\n\n @internal\n\n Yes, the  API is  really strange.   It returns `long`,  but raises  when the\n value is out of `int`.  This seems to  be due to the fact that Matz favoured\n K&R before, and his machine at that moment was an ILP32 architecture."]
    pub fn rb_num2int(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Identical to rb_num2int().\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `int`.\n @return     The passed value converted into C's `long`.\n\n @internal\n\n This function seems to be a complete  waste of disk space.  @shyouhei has no\n idea why this is a different thing from rb_num2short()."]
    pub fn rb_fix2int(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `unsigned long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned int`.\n @return     The passed value converted into C's `unsigned long`.\n\n @internal\n\n Yes, the API is really strange.  It returns `unsigned long`, but raises when\n the value is out  of `unsigned int`.  This seems to be due  to the fact that\n Matz  favoured K&R  before, and  his  machine at  that moment  was an  ILP32\n architecture."]
    pub fn rb_num2uint(num: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Identical to rb_num2uint().\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned int`.\n @return     The passed value converted into C's `unsigned long`.\n\n @internal\n\n This function seems to be a complete  waste of disk space.  @shyouhei has no\n idea why this is a different thing from rb_num2short()."]
    pub fn rb_fix2uint(num: VALUE) -> ::std::os::raw::c_ulong;
}
pub const ruby_rvalue_flags_RVALUE_EMBED_LEN_MAX: ruby_rvalue_flags = 3;
#[doc = " This is an enum because GDB wants it (rather than a macro).  People need not\n bother."]
pub type ruby_rvalue_flags = ::std::os::raw::c_uint;
#[doc = " Ruby's object's,  base components.  Every  single ruby objects have  them in\n common."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    #[doc = " Per-object  flags.  Each  ruby  objects have  their own  characteristics\n apart from their  classes.  For instance whether an object  is frozen or\n not is not  controlled by its class.  This is  where such properties are\n stored.\n\n @see enum ::ruby_fl_type\n\n @note  This is ::VALUE rather than  an enum for alignment purpose.  Back\n        in the 1990s there were no such thing like `_Alignas` in C."]
    pub flags: VALUE,
    #[doc = " Class of an object.  Every object has its class.  Also, everything is an\n object  in Ruby.   This means  classes are  also objects.   Classes have\n their own classes,  classes of classes have their classes,  too ...  and\n it recursively continues forever.\n\n Also note the `const` qualifier.  In  ruby an object cannot \"change\" its\n class."]
    pub klass: VALUE,
}
#[test]
fn bindgen_test_layout_RBasic() {
    const UNINIT: ::std::mem::MaybeUninit<RBasic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RBasic>(),
        8usize,
        concat!("Size of: ", stringify!(RBasic))
    );
    assert_eq!(
        ::std::mem::align_of::<RBasic>(),
        4usize,
        concat!("Alignment of ", stringify!(RBasic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RBasic),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).klass) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RBasic),
            "::",
            stringify!(klass)
        )
    );
}
extern "C" {
    #[doc = " Make the object invisible from Ruby code.\n\n It is  useful to let  Ruby's GC manage your  internal data structure  -- The\n object keeps being managed by GC, but `ObjectSpace.each_object` never yields\n the object.\n\n Note that the object also lose a way to call a method on it.\n\n @param[out]  obj  A Ruby object.\n @return      The passed object.\n @post        The object is destructively modified to be invisible.\n @see         rb_obj_reveal"]
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Make a hidden object visible again.\n\n It is  the caller's  responsibility to  pass the  right `klass`  which `obj`\n originally used to belong to.\n\n @param[out]  obj    A Ruby object.\n @param[in]   klass  Class of `obj`.\n @return      Passed `obj`.\n @pre         `obj` was previously hidden.\n @post        `obj`'s class is `klass`.\n @see         rb_obj_hide"]
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
}
#[doc = " Category unspecified."]
pub const rb_warning_category_t_RB_WARN_CATEGORY_NONE: rb_warning_category_t = 0;
#[doc = " Warning is for deprecated features."]
pub const rb_warning_category_t_RB_WARN_CATEGORY_DEPRECATED: rb_warning_category_t = 1;
#[doc = " Warning is for experimental features."]
pub const rb_warning_category_t_RB_WARN_CATEGORY_EXPERIMENTAL: rb_warning_category_t = 2;
#[doc = " Warning is for experimental features."]
pub const rb_warning_category_t_RB_WARN_CATEGORY_ALL_BITS: rb_warning_category_t = 6;
#[doc = " Warning  categories.  A  warning issued  using this  API can  be selectively\n requested   /   suppressed   by   the  end-users.   For   instance   passing\n `-W:no-deprecated`  to the  ruby process  would suppress  those warnings  in\n deprecated category.\n\n @warning    There is no way to declare a new category (for now)."]
pub type rb_warning_category_t = ::std::os::raw::c_uint;
pub const rb_io_wait_readwrite_RB_IO_WAIT_READABLE: rb_io_wait_readwrite = 0;
pub const rb_io_wait_readwrite_RB_IO_WAIT_WRITABLE: rb_io_wait_readwrite = 1;
#[doc = " for rb_readwrite_sys_fail first argument"]
pub type rb_io_wait_readwrite = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This is the same as `$!` in Ruby.\n\n @retval   RUBY_Qnil  Not handling exceptions at the moment.\n @retval   otherwise  The current exception in the current thread.\n @ingroup  exception"]
    pub fn rb_errinfo() -> VALUE;
}
extern "C" {
    #[doc = " Sets the current exception (`$!`) to the given value.\n\n @param[in]  err            An instance of ::rb_eException, or ::RUBY_Qnil.\n @exception  rb_eTypeError  What  is given  was  neither ::rb_eException  nor\n                            ::RUBY_Qnil.\n @note       Use  rb_raise()  instead to  raise  `err`.   This function  just\n             assigns the given object to the global variable.\n @ingroup    exception"]
    pub fn rb_set_errinfo(err: VALUE);
}
extern "C" {
    #[doc = " Exception  entry point.   By calling  this  function the  execution of  your\n program gets interrupted to \"raise\" an  exception up to the callee entities.\n Programs could \"rescue\" that exception, or could \"ensure\" some part of them.\n If nobody cares  about such things, the raised exception  reaches at the top\n of execution.  This yields abnormal end of the process.\n\n @param[in]  exc  A subclass of ::rb_eException.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf().\n @exception  exc  The specified exception.\n @note       It never returns."]
    pub fn rb_raise(exc: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Raises the unsung \"fatal\" exception.  This is considered severe.  Nobody can\n rescue  the  exception.  Once  raised,  process  termination is  inevitable.\n However ensure clauses still run, so that resources are properly cleaned up.\n\n @param[in]  fmt        Format specifier string compatible with rb_sprintf().\n @exception  rb_eFatal  An exception that you cannot rescue.\n @note       It never returns."]
    pub fn rb_fatal(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Interpreter  panic  switch.   Immediate   process  termination  without  any\n synchronisations shall  occur.  LOTS of  internal states, stack  traces, and\n even  machine registers  are displayed  if possible  for debugging  purposes\n then.\n\n @warning    Do not use this API.\n @warning    You are not expected to use this API.\n @warning    Why not just fix your code instead of calling this API?\n @warning    It was a  bad idea to expose this API  to extension libraries at\n             the first  place.  We just  cannot delete  it at this  point for\n             backwards  compatibility.    That  doesn't  mean   everyone  are\n             welcomed to call this function at will.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf().\n @note       It never returns."]
    pub fn rb_bug(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " This is  a wrapper  of rb_bug()  which automatically  constructs appropriate\n message from the passed errno.\n\n @param[in]  msg  Additional message to display.\n @exception  err  C level errno.\n @note       It never returns."]
    pub fn rb_bug_errno(msg: *const ::std::os::raw::c_char, err: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Converts a C errno into a Ruby exception, then raises it.  For instance:\n\n ```CXX\n static VALUE\n foo(VALUE argv)\n {\n    const auto cmd = StringValueCStr(argv);\n    const auto waitr = system(cmd);\n    if (waitr == -1) {\n        rb_sys_fail(\"system(3posix)\"); // <-------------- this\n    }\n    else {\n        return INT2FIX(fd);\n    }\n }\n ```\n\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing errno.\n @note       It never returns."]
    pub fn rb_sys_fail(msg: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[doc = " Identical to  rb_sys_fail(), except  it takes the  message in  Ruby's String\n instead of C's.\n\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing errno.\n @note       It never returns."]
    pub fn rb_sys_fail_str(msg: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical to rb_sys_fail(), except it  takes additional module to extend the\n exception object before raising.\n\n @param[in]  mod                  A ::rb_cModule instance.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing errno.\n @note       It never returns.\n\n @internal\n\n Does anybody use it?"]
    pub fn rb_mod_sys_fail(mod_: VALUE, msg: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[doc = " Identical to rb_mod_sys_fail(), except it takes the message in Ruby's String\n instead of C's.\n\n @param[in]  mod                  A ::rb_cModule instance.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing errno.\n @note       It never returns."]
    pub fn rb_mod_sys_fail_str(mod_: VALUE, msg: VALUE) -> !;
}
extern "C" {
    #[doc = " Raises appropriate exception using the parameters.\n\n In Ruby level there are  rb_eEAGAINWaitReadable etc.  This function maps the\n given parameter to an appropriate exception class, then raises it.\n\n @param[in]  waiting  Reason for the IO to wait.\n @param[in]  msg      Additional message to raise.\n @exception  rb_eEAGAINWaitWritable\n @exception  rb_eEWOULDBLOCKWaitWritable\n @exception  rb_eEINPROGRESSWaitWritable\n @exception  rb_eEAGAINWaitReadable\n @exception  rb_eEWOULDBLOCKWaitReadable\n @exception  rb_eEINPROGRESSWaitReadable\n @exception  rb_eSystemCallError\n @note       It never returns."]
    pub fn rb_readwrite_sys_fail(
        waiting: rb_io_wait_readwrite,
        msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Breaks from a block.  Because you are  using a CAPI this is not as intuitive\n as  it  sounds.   In order  for  this  function  to  properly work,  make  a\n ::rb_block_call_func_t  function that  calls  it internally,  and pass  that\n function to rb_block_call().\n\n @exception  rb_eLocalJumpError  Called from outside of a block.\n @note       It never returns."]
    pub fn rb_iter_break() -> !;
}
extern "C" {
    #[doc = " Identical to  rb_iter_break(), except it  additionally takes the  \"value\" of\n this breakage.  It  will be the evaluation result of  the iterator.  This is\n kind  of  complicated; you  cannot  see  this as  a  \"return  from a  block\"\n behaviour.  Take a look at this example:\n\n ```ruby\n def foo(q)\n   puts(w = yield(q))\n   puts(e = yield(w))\n   puts(r = yield(e))\n   puts(t = yield(r))\n   puts(y = yield(t))\n   return \"howdy!\"\n end\n\n x = foo(0) {|i|\n   if i > 2\n     break \"hello!\"\n   else\n     next i + 1\n   end\n }\n\n puts x\n ```\n\n This script outputs 1, 2, 3, and hello.  Note that the value passed to break\n becomes the  return value of  foo method, not the  value of yield.   This is\n confusing, but  can be  handy on occasions  e.g.  when you  want to  bring a\n local variable out of a block.\n\n @param[in]  val                 The value of the iterator.\n @exception  rb_eLocalJumpError  Called from outside of a block.\n @note       It never returns."]
    pub fn rb_iter_break_value(val: VALUE) -> !;
}
extern "C" {
    #[doc = " Terminates the current execution context.  This  API is the entry point of a\n \"well-mannered\"  termination  sequence.   When   called  from  an  extension\n library, it  raises ::rb_eSystemExit exception.  Programs  could rescue that\n exception.  Can cancel process exit then.  Otherwise, that exception results\n in a process termination with the status passed to this function.\n\n @param[in]  status          Exit status, see also exit(3).\n @exception  rb_eSystemExit  Exception representing the exit status.\n @note       It never returns.\n\n @internal\n\n \"When called from  an extension library\"?  You might wonder.   In fact there\n are chances for this function to be  called from outside of it, for instance\n when dlopen(3)  failed.  In  case it  is not possible  for this  function to\n raise an exception,  it does not (silently enters to  process cleanup).  But\n that  is a  kind of  implementation detail  which extension  library authors\n should not bother."]
    pub fn rb_exit(status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " @exception  rb_eNotImpError\n @note       It never returns."]
    pub fn rb_notimplement() -> !;
}
extern "C" {
    #[doc = " Creates an exception object that represents the given C errno.\n\n @param[in]  err                  C level errno.\n @param[in]  msg                  Additional message.\n @retval     rb_eSystemCallError  An exception for the errno."]
    pub fn rb_syserr_new(err: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_syserr_new(),  except it takes the message  in Ruby's String\n instead of C's.\n\n @param[in]  n                    C level errno.\n @param[in]  arg                  Additional message.\n @retval     rb_eSystemCallError  An exception for the errno."]
    pub fn rb_syserr_new_str(n: ::std::os::raw::c_int, arg: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Raises appropriate exception that represents a C errno.\n\n @param[in]  err                  C level errno.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing `err`.\n @note       It never returns."]
    pub fn rb_syserr_fail(err: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[doc = " Identical to rb_syserr_fail(), except it  takes the message in Ruby's String\n instead of C's.\n\n @param[in]  err                  C level errno.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing `err`.\n @note       It never returns."]
    pub fn rb_syserr_fail_str(err: ::std::os::raw::c_int, msg: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical  to rb_mod_sys_fail(),  except  it  does not  depend  on C  global\n variable errno.  Pass it explicitly.\n\n @param[in]  mod                  A ::rb_cModule instance.\n @param[in]  err                  C level errno.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing `err`.\n @note       It never returns."]
    pub fn rb_mod_syserr_fail(
        mod_: VALUE,
        err: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Identical to  rb_mod_syserr_fail(), except  it takes  the message  in Ruby's\n String instead of C's.\n\n @param[in]  mod                  A ::rb_cModule instance.\n @param[in]  err                  C level errno.\n @param[in]  msg                  Additional message to raise.\n @exception  rb_eSystemCallError  An exception representing `err`.\n @note       It never returns."]
    pub fn rb_mod_syserr_fail_str(mod_: VALUE, err: ::std::os::raw::c_int, msg: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical to rb_readwrite_sys_fail(), except it  does not depend on C global\n variable errno.  Pass it explicitly.\n\n @param[in]  waiting  Reason for the IO to wait.\n @param[in]  err      C level errno.\n @param[in]  msg      Additional message to raise.\n @exception  rb_eEAGAINWaitWritable\n @exception  rb_eEWOULDBLOCKWaitWritable\n @exception  rb_eEINPROGRESSWaitWritable\n @exception  rb_eEAGAINWaitReadable\n @exception  rb_eEWOULDBLOCKWaitReadable\n @exception  rb_eEINPROGRESSWaitReadable\n @exception  rb_eSystemCallError\n @note       It never returns."]
    pub fn rb_readwrite_syserr_fail(
        waiting: rb_io_wait_readwrite,
        err: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Fails with the given object's type incompatibility to the type.\n\n It  seems this  function is  visible from  extension libraries  only because\n RTYPEDDATA_TYPE() uses  it on RUBY_DEBUG.   So you can basically  ignore it;\n use some other fine-grained method instead.\n\n @param[in]  self           The object in question.\n @param[in]  t              Expected type of the object.\n @exception  rb_eTypeError  `self` not in type `t`.\n @note       It never returns.\n @note       The second  argument must  have been an  enum ::ruby_value_type,\n             but for  historical reasons it  remains to  be an int  (in other\n             words we see no benefits fixing this bug)."]
    pub fn rb_unexpected_type(self_: VALUE, t: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " @private\n\n This  is an  implementation detail  of #ruby_verbose.   Please don't  use it\n directly.\n\n @retval  Qnil       Interpreter is quiet.\n @retval  Qfalse     Interpreter is kind of chatty.\n @retval  otherwise  Interpreter is very verbose."]
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
}
extern "C" {
    #[doc = " @private\n\n This  is an  implementation  detail  of #ruby_debug.   Please  don't use  it\n directly.\n\n @retval  Qnil       Interpreter not in debug mode.\n @retval  Qfalse     Interpreter not in debug mode.\n @retval  otherwise  Interpreter is in debug mode."]
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
}
extern "C" {
    #[doc = " Issues a warning.\n\n In  ruby, warnings  these  days  are tightly  coupled  with the  rb_mWarning\n constant and its `warn` singleton method.   This CAPI is just a thin wrapper\n of it;  everything passed  are formatted like  what rb_sprintf()  does, then\n passed  through   to  the  method.    Programs  can  have  their   own  `def\n Warning.warn` at will  to do whatever they want, from  ignoring the warnings\n at all to sinking them to some  BigQuery data set via a Fluentd cluster.  By\n default,  the method  just emits  its passed  contents to  ::rb_stderr using\n rb_io_write().\n\n @note       This function is affected by the `-W` flag.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf().\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Identical to rb_warning(), except it takes additional \"category\" parameter.\n\n @param[in]  cat  Name of a known category.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf()."]
    pub fn rb_category_warning(cat: rb_warning_category_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Issues a compile-time warning  that happens at `__file__:__line__`.  Purpose\n of this function being exposed to CAPI is unclear.\n\n @note       This function is affected by the `-W` flag.\n @param[in]  file  The path corresponding to Ruby level `__FILE__`.\n @param[in]  line  The number corresponding to Ruby level `__LINE__`.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf()."]
    pub fn rb_compile_warning(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Identical to rb_sys_fail(), except it does  not raise an exception to render\n a warning instead.\n\n @note       This function is affected by the `-W` flag.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf()."]
    pub fn rb_sys_warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Identical to  rb_warning(), except it  reports always regardless  of runtime\n `-W` flag.\n\n @param[in]  fmt  Format specifier string compatible with rb_sprintf()."]
    pub fn rb_warn(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Identical to  rb_category_warning(), except it reports  always regardless of\n runtime `-W` flag.\n\n @param[in]  cat  Category e.g. deprecated.\n @param[in]  fmt  Format specifier string compatible with rb_sprintf()."]
    pub fn rb_category_warn(cat: rb_warning_category_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Identical to  rb_compile_warning(), except  it reports always  regardless of\n runtime `-W` flag.\n\n @param[in]  file  The path corresponding to Ruby level `__FILE__`.\n @param[in]  line  The number corresponding to Ruby level `__LINE__`.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf()."]
    pub fn rb_compile_warn(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Identical to  rb_compile_warn(), except  it also accepts category.\n\n @param[in]  cat   Category e.g. deprecated.\n @param[in]  file  The path corresponding to Ruby level `__FILE__`.\n @param[in]  line  The number corresponding to Ruby level `__LINE__`.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf()."]
    pub fn rb_category_compile_warn(
        cat: rb_warning_category_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[doc = "< Non-object (swept etc.)"]
pub const ruby_value_type_RUBY_T_NONE: ruby_value_type = 0;
#[doc = "< @see struct ::RObject"]
pub const ruby_value_type_RUBY_T_OBJECT: ruby_value_type = 1;
#[doc = "< @see struct ::RClass and ::rb_cClass"]
pub const ruby_value_type_RUBY_T_CLASS: ruby_value_type = 2;
#[doc = "< @see struct ::RClass and ::rb_cModule"]
pub const ruby_value_type_RUBY_T_MODULE: ruby_value_type = 3;
#[doc = "< @see struct ::RFloat"]
pub const ruby_value_type_RUBY_T_FLOAT: ruby_value_type = 4;
#[doc = "< @see struct ::RString"]
pub const ruby_value_type_RUBY_T_STRING: ruby_value_type = 5;
#[doc = "< @see struct ::RRegexp"]
pub const ruby_value_type_RUBY_T_REGEXP: ruby_value_type = 6;
#[doc = "< @see struct ::RArray"]
pub const ruby_value_type_RUBY_T_ARRAY: ruby_value_type = 7;
#[doc = "< @see struct ::RHash"]
pub const ruby_value_type_RUBY_T_HASH: ruby_value_type = 8;
#[doc = "< @see struct ::RStruct"]
pub const ruby_value_type_RUBY_T_STRUCT: ruby_value_type = 9;
#[doc = "< @see struct ::RBignum"]
pub const ruby_value_type_RUBY_T_BIGNUM: ruby_value_type = 10;
#[doc = "< @see struct ::RFile"]
pub const ruby_value_type_RUBY_T_FILE: ruby_value_type = 11;
#[doc = "< @see struct ::RTypedData"]
pub const ruby_value_type_RUBY_T_DATA: ruby_value_type = 12;
#[doc = "< @see struct ::RMatch"]
pub const ruby_value_type_RUBY_T_MATCH: ruby_value_type = 13;
#[doc = "< @see struct ::RComplex"]
pub const ruby_value_type_RUBY_T_COMPLEX: ruby_value_type = 14;
#[doc = "< @see struct ::RRational"]
pub const ruby_value_type_RUBY_T_RATIONAL: ruby_value_type = 15;
#[doc = "< @see ::RUBY_Qnil"]
pub const ruby_value_type_RUBY_T_NIL: ruby_value_type = 17;
#[doc = "< @see ::RUBY_Qfalse"]
pub const ruby_value_type_RUBY_T_TRUE: ruby_value_type = 18;
#[doc = "< @see ::RUBY_Qtrue"]
pub const ruby_value_type_RUBY_T_FALSE: ruby_value_type = 19;
#[doc = "< @see struct ::RSymbol"]
pub const ruby_value_type_RUBY_T_SYMBOL: ruby_value_type = 20;
#[doc = "< Integers formerly known as Fixnums."]
pub const ruby_value_type_RUBY_T_FIXNUM: ruby_value_type = 21;
#[doc = "< @see ::RUBY_Qundef"]
pub const ruby_value_type_RUBY_T_UNDEF: ruby_value_type = 22;
#[doc = "< @see struct ::RIMemo"]
pub const ruby_value_type_RUBY_T_IMEMO: ruby_value_type = 26;
#[doc = "< @see struct ::RNode"]
pub const ruby_value_type_RUBY_T_NODE: ruby_value_type = 27;
#[doc = "< Hidden classes known as IClasses."]
pub const ruby_value_type_RUBY_T_ICLASS: ruby_value_type = 28;
#[doc = "< @see struct ::RZombie"]
pub const ruby_value_type_RUBY_T_ZOMBIE: ruby_value_type = 29;
#[doc = "< @see struct ::RMoved"]
pub const ruby_value_type_RUBY_T_MOVED: ruby_value_type = 30;
#[doc = "< Bitmask of ::ruby_value_type."]
pub const ruby_value_type_RUBY_T_MASK: ruby_value_type = 31;
#[doc = " C-level type of an object."]
pub type ruby_value_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @private\n\n This was  the old implementation  of Check_Type(), but they  diverged.  This\n one remains  for theoretical backwards compatibility.   People normally need\n not use it.\n\n @param[in]  obj            An object.\n @param[in]  t              A type.\n @exception  rb_eTypeError  `obj` is not of type `t`.\n @exception  rb_eFatal      `obj` is corrupt.\n @post       Upon successful return `obj` is guaranteed to have type `t`.\n\n @internal\n\n The second argument shall have been enum ::ruby_value_type.  But at the time\n matz designed this  function he still used  K&R C.  There was  no such thing\n like a function prototype.  We can no longer change this API."]
    pub fn rb_check_type(obj: VALUE, t: ::std::os::raw::c_int);
}
#[doc = " Number of bits in ::ruby_fl_type that  are _not_ open to users.  This is\n an implementation detail.  Please ignore."]
pub const ruby_fl_ushift_RUBY_FL_USHIFT: ruby_fl_ushift = 12;
#[doc = " This is an enum because GDB wants it (rather than a macro).  People need not\n bother."]
pub type ruby_fl_ushift = ::std::os::raw::c_uint;
#[doc = " @deprecated  This flag once was a thing  back in the old days, but makes\n              no  sense  any longer  today.   Exists  here for  backwards\n              compatibility only.  You can safely forget about it.\n\n @internal\n\n The reality is our GC no  longer remembers write barriers inside of each\n objects, to use  dedicated bitmap instead.  But this flag  is still used\n internally.   The  current  usages  of this  flag  should  be  something\n different, which is unclear to @shyouhei."]
pub const ruby_fl_type_RUBY_FL_WB_PROTECTED: ruby_fl_type = 32;
#[doc = " This flag  has something to do  with our garbage collector.   These days\n ruby  objects are  \"generational\".  There  are those  who are  young and\n those who are old.  Young objects are prone to die; monitored relatively\n extensively by  the garbage  collector.  OTOH old  objects tend  to live\n longer.  They are relatively rarely considered.  This flag is set when a\n object experienced promotion i.e. survived a garbage collection.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_PROMOTED0: ruby_fl_type = 32;
#[doc = " This flag  has something to do  with our garbage collector.   These days\n ruby  objects are  \"generational\".  There  are those  who are  young and\n those who are old.  Young objects are prone to die; monitored relatively\n extensively by  the garbage  collector.  OTOH old  objects tend  to live\n longer.  They are relatively rarely considered.  This flag is set when a\n object  experienced two  promotions  i.e.  survived garbage  collections\n twice.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_PROMOTED1: ruby_fl_type = 64;
#[doc = " This flag  has something to do  with our garbage collector.   These days\n ruby  objects are  \"generational\".  There  are those  who are  young and\n those who are old.  Young objects are prone to die; monitored relatively\n extensively by  the garbage  collector.  OTOH old  objects tend  to live\n longer.  They are relatively rarely considered.  This flag is set when a\n object  experienced  promotions i.e.   survived  more  than one  garbage\n collections.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_PROMOTED: ruby_fl_type = 96;
#[doc = " This flag has  something to do with finalisers.  A  ruby object can have\n its finaliser,  which is another  object that evaluates when  the target\n object is about  to die.  This flag  is used to denote that  there is an\n attached finaliser.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_FINALIZE: ruby_fl_type = 128;
#[doc = " @deprecated  This flag once was a thing  back in the old days, but makes\n              no  sense  any longer  today.   Exists  here for  backwards\n              compatibility only.  You can safely forget about it."]
pub const ruby_fl_type_RUBY_FL_TAINT: ruby_fl_type = 256;
#[doc = " This flag has something to do with Ractor.  Multiple Ractors run without\n protecting each  other.  Sharing an  object among Ractors  are basically\n dangerous,  disabled by  default.   This  flag is  used  to bypass  that\n restriction.  Of  course, you have  to manually prevent  race conditions\n then.\n\n This flag  needs deep  understanding of multithreaded  programming.  You\n would better not use it."]
pub const ruby_fl_type_RUBY_FL_SHAREABLE: ruby_fl_type = 256;
#[doc = " @deprecated  This flag once was a thing  back in the old days, but makes\n              no  sense  any longer  today.   Exists  here for  backwards\n              compatibility only.  You can safely forget about it."]
pub const ruby_fl_type_RUBY_FL_UNTRUSTED: ruby_fl_type = 256;
#[doc = " This flag has something to do with  object IDs.  Unlike in the old days,\n an object's object  ID (that a user can  query using `Object#object_id`)\n is no longer its physical address represented using Ruby level integers.\n It is  now a  monotonic-increasing integer  unrelated to  the underlying\n memory arrangement.  Object IDs are assigned when necessary; objects are\n born without one,  and will eventually have such  property when queried.\n The interpreter has to manage which one is which.  This is the flag that\n helps the  management.  Objects  with this  flag set  are the  ones with\n object IDs assigned.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_SEEN_OBJ_ID: ruby_fl_type = 512;
#[doc = " This flag has something to do with instance variables.  3rd parties need\n not  know, but  there are  several ways  to store  an object's  instance\n variables.   Objects  with this  flag  use  so-called \"generic\"  backend\n storage.  This  distinction is purely an  implementation detail.  People\n need not be aware of this working behind-the-scene.\n\n @internal\n\n As of writing everything except ::RObject and RModule use this scheme."]
pub const ruby_fl_type_RUBY_FL_EXIVAR: ruby_fl_type = 1024;
#[doc = " This flag has something to do with data immutability.  When this flag is\n set an object  is considered \"frozen\".  No modification  are expected to\n happen beyond  that point  for the  particular object.   Immutability is\n basically considered to be a  good property these days.  Library authors\n are expected to obey.  Test this bit before you touch a data structure.\n\n @see rb_check_frozen()"]
pub const ruby_fl_type_RUBY_FL_FREEZE: ruby_fl_type = 2048;
pub const ruby_fl_type_RUBY_FL_USER0: ruby_fl_type = 4096;
pub const ruby_fl_type_RUBY_FL_USER1: ruby_fl_type = 8192;
pub const ruby_fl_type_RUBY_FL_USER2: ruby_fl_type = 16384;
pub const ruby_fl_type_RUBY_FL_USER3: ruby_fl_type = 32768;
pub const ruby_fl_type_RUBY_FL_USER4: ruby_fl_type = 65536;
pub const ruby_fl_type_RUBY_FL_USER5: ruby_fl_type = 131072;
pub const ruby_fl_type_RUBY_FL_USER6: ruby_fl_type = 262144;
pub const ruby_fl_type_RUBY_FL_USER7: ruby_fl_type = 524288;
pub const ruby_fl_type_RUBY_FL_USER8: ruby_fl_type = 1048576;
pub const ruby_fl_type_RUBY_FL_USER9: ruby_fl_type = 2097152;
pub const ruby_fl_type_RUBY_FL_USER10: ruby_fl_type = 4194304;
pub const ruby_fl_type_RUBY_FL_USER11: ruby_fl_type = 8388608;
pub const ruby_fl_type_RUBY_FL_USER12: ruby_fl_type = 16777216;
pub const ruby_fl_type_RUBY_FL_USER13: ruby_fl_type = 33554432;
pub const ruby_fl_type_RUBY_FL_USER14: ruby_fl_type = 67108864;
pub const ruby_fl_type_RUBY_FL_USER15: ruby_fl_type = 134217728;
pub const ruby_fl_type_RUBY_FL_USER16: ruby_fl_type = 268435456;
pub const ruby_fl_type_RUBY_FL_USER17: ruby_fl_type = 536870912;
pub const ruby_fl_type_RUBY_FL_USER18: ruby_fl_type = 1073741824;
pub const ruby_fl_type_RUBY_FL_USER19: ruby_fl_type = -2147483648;
pub const ruby_fl_type_RUBY_ELTS_SHARED: ruby_fl_type = 16384;
#[doc = " This flag has something to do with an object's class.  There are kind of\n classes  called  \"singleton  class\",  each of  which  have  exactly  one\n instance.  What is interesting about  singleton classes is that they are\n created _after_ their instance were instantiated, like this:\n\n ```ruby\n foo = Object.new          # foo is an instance of Object...\n bar = foo.singleton_class # foo is now an instance of bar.\n ```\n\n Here as you see  `bar` is a singleton class of  `foo`, which is injected\n into  `foo`'s inheritance  tree in  a different  statement (==  distinct\n sequence point).   In order to  achieve this property  singleton classes\n are  special-cased in  the  interpreter.   There is  one  bit flag  that\n distinguishes if a class is a singleton class or not, and this is it.\n\n @internal\n\n But honestly, @shyouhei  doesn't think this flag should  be visible from\n 3rd parties.  It must be an implementation detail that they should never\n know.  Might better be hidden."]
pub const ruby_fl_type_RUBY_FL_SINGLETON: ruby_fl_type = 4096;
#[doc = " The  flags.  Each  ruby objects  have their  own characteristics  apart from\n their  classes.  For  instance whether  an object  is frozen  or not  is not\n controlled by its class.  This is the type that represents such properties.\n\n @note  About the `FL_USER` terminology: the \"user\" here does not necessarily\n        mean only  you.  For  instance struct  ::RString instances  use these\n        bits to cache their encodings  etc.  Devs discussed about this topic,\n        reached their  consensus that  ::RUBY_T_DATA is  the only  valid data\n        structure that  can use these  bits; other data  structures including\n        ::RUBY_T_OBJECT  use these  bits  for their  own  purpose.  See  also\n        https://bugs.ruby-lang.org/issues/18059"]
pub type ruby_fl_type = ::std::os::raw::c_int;
#[doc = " @deprecated  This flag once was a thing  back in the old days, but makes\n              no  sense  any longer  today.   Exists  here for  backwards\n              compatibility only.  You can safely forget about it."]
pub const RUBY_FL_DUPPED: _bindgen_ty_8 = 1055;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " This is an  implementation detail of #RB_OBJ_FREEZE().  People  don't use it\n directly.\n\n @param[out]  klass  A singleton class.\n @post        `klass` gets frozen."]
    pub fn rb_freeze_singleton_class(klass: VALUE);
}
extern "C" {
    pub fn rb_obj_freeze_inline(obj: VALUE);
}
pub const ruby_rstring_flags_RSTRING_NOEMBED: ruby_rstring_flags = 8192;
pub const ruby_rstring_flags_RSTRING_FSTR: ruby_rstring_flags = 536870912;
#[doc = " @private\n\n Bits that you can set to ::RBasic::flags.\n\n @warning  These enums are not the only bits we use for strings.\n\n @internal\n\n Actually all bits  through FL_USER1 to FL_USER19 are used  for strings.  Why\n only this  tiny part of  them are made public  here?  @shyouhei can  find no\n reason."]
pub type ruby_rstring_flags = ::std::os::raw::c_uint;
#[doc = " Ruby's String.  A string in ruby conceptually has these information:\n\n - Encoding of the string.\n - Length of the string.\n - Contents of the string.\n\n It is worth  noting that a string  is _not_ an array of  characters in ruby.\n It has never been.   In 1.x a string was an array of  integers.  Since 2.x a\n string is no longer an array of anything.  A string is a string -- just like\n a Time is not an integer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    pub as_: RString__bindgen_ty_1,
}
#[doc = " String's specific fields."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1 {
    pub heap: RString__bindgen_ty_1__bindgen_ty_1,
    pub embed: RString__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " Strings  that use  separated  memory region  for  contents use  this\n pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Length of the string, not including terminating NUL character.\n\n @note  This is in bytes."]
    pub len: ::std::os::raw::c_long,
    #[doc = " Pointer to  the contents of  the string.   In the old  days each\n string had  dedicated memory  regions.  That  is no  longer true\n today,  but there  still are  strings of  such properties.  This\n field could be used to point such things."]
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Auxiliary info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Capacity of `*ptr`.  A continuous  memory region of at least\n `capa` bytes  is expected to  exist at `*ptr`.  This  can be\n bigger than `len`."]
    pub capa: ::std::os::raw::c_long,
    #[doc = " Parent  of the  string.   Nowadays strings  can share  their\n contents each other, constructing  gigantic nest of objects.\n This situation is called \"shared\",  and this is the field to\n control such properties."]
    pub shared: VALUE,
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(shared)
        )
    );
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RString__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(RString__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(aux)
        )
    );
}
#[doc = " Embedded contents."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_2 {
    pub len: ::std::os::raw::c_long,
    pub ary: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<RString__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(RString__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ary) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ary)
        )
    );
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RString__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(RString__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RString__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString__bindgen_ty_1),
            "::",
            stringify!(embed)
        )
    );
}
#[test]
fn bindgen_test_layout_RString() {
    const UNINIT: ::std::mem::MaybeUninit<RString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RString>(),
        20usize,
        concat!("Size of: ", stringify!(RString))
    );
    assert_eq!(
        ::std::mem::align_of::<RString>(),
        4usize,
        concat!("Alignment of ", stringify!(RString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RString),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RString),
            "::",
            stringify!(as_)
        )
    );
}
extern "C" {
    #[doc = " Identical to rb_check_string_type(), except it  raises exceptions in case of\n conversion failures.\n\n @param[in]  obj            Target object.\n @exception  rb_eTypeError  No implicit conversion to String.\n @return     Return value of `obj.to_str`.\n @see        rb_io_get_io\n @see        rb_ary_to_ary"]
    pub fn rb_str_to_str(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_to_str(), except it  fills the passed pointer  with the\n converted object.\n\n @param[in,out]  ptr            Pointer to a variable of target object.\n @exception      rb_eTypeError  No implicit conversion to String.\n @return         Return value of `obj.to_str`.\n @post           `*ptr` is the return value."]
    pub fn rb_string_value(ptr: *mut VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_str_to_str(), except  it  returns  the converted  string's\n backend memory region.\n\n @param[in,out]  ptr            Pointer to a variable of target object.\n @exception      rb_eTypeError  No implicit conversion to String.\n @post           `*ptr` is the return value of `obj.to_str`.\n @return         Pointer to the contents of the return value."]
    pub fn rb_string_value_ptr(ptr: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Identical to  rb_string_value_ptr(), except  it additionally checks  for the\n contents  for viability  as a  C  string.  Ruby  can accept  wider range  of\n contents as strings, compared to C.  This function is to check that.\n\n @param[in,out]  ptr            Pointer to a variable of target object.\n @exception      rb_eTypeError  No implicit conversion to String.\n @exception      rb_eArgError   String is not C-compatible.\n @post           `*ptr` is the return value of `obj.to_str`.\n @return         Pointer to the contents of the return value."]
    pub fn rb_string_value_cstr(ptr: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Identical  to rb_str_to_str(),  except it  additionally converts  the string\n into default  external encoding.   Ruby has a  concept called  encodings.  A\n string can  have different encoding  than the environment  expects.  Someone\n has to make  sure its contents be converted to  something suitable.  This is\n that routine.  Call it when necessary.\n\n @param[in]  obj            Target object.\n @exception  rb_eTypeError  No implicit conversion to String.\n @return     Converted ruby string of default external encoding."]
    pub fn rb_str_export(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_export(), except it  converts into the  locale encoding\n instead.\n\n @param[in]  obj            Target object.\n @exception  rb_eTypeError  No implicit conversion to String.\n @return     Converted ruby string of locale encoding."]
    pub fn rb_str_export_locale(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @private\n\n @deprecated  This function  once was a thing  in the old days,  but makes no\n              sense   any   longer   today.   Exists   here   for   backwards\n              compatibility only.  You can safely forget about it."]
    pub fn rb_check_safe_str(arg1: VALUE);
}
extern "C" {
    #[doc = " @private\n\n Prints diagnostic message to stderr when RSTRING_PTR or RSTRING_END\n is NULL.\n\n @param[in]  func           The function name where encountered NULL pointer."]
    pub fn rb_debug_rstring_null_ptr(func: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `double`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @return     The passed value converted into C's `double`."]
    pub fn rb_num2dbl(num: VALUE) -> f64;
}
extern "C" {
    #[doc = " Extracts its double value from an instance of ::rb_cFloat.\n\n @param[in]  num  An instance of ::rb_cFloat.\n @pre        Must not pass anything other than a Fixnum.\n @return     The passed value converted into C's `double`."]
    pub fn rb_float_value(num: VALUE) -> f64;
}
extern "C" {
    #[doc = " Converts a C's `double` into an instance of ::rb_cFloat.\n\n @param[in]  d  Arbitrary `double` value.\n @return     An instance of ::rb_cFloat."]
    pub fn rb_float_new(d: f64) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_float_new(), except it does not generate Flonums.\n\n @param[in]  d  Arbitrary `double` value.\n @return     An instance of ::rb_cFloat.\n\n @internal\n\n @shyouhei has no idea why it is here."]
    pub fn rb_float_new_in_heap(d: f64) -> VALUE;
}
extern "C" {
    #[doc = " Converts a C's `long long` into an instance of ::rb_cInteger.\n\n @param[in]  num  Arbitrary `long long` value.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_ll2inum(num: ::std::os::raw::c_longlong) -> VALUE;
}
extern "C" {
    #[doc = " Converts a C's `unsigned long long` into an instance of ::rb_cInteger.\n\n @param[in]  num  Arbitrary `unsigned long long` value.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_ull2inum(num: ::std::os::raw::c_ulonglong) -> VALUE;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `long long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `long long`.\n @return     The passed value converted into C's `long long`."]
    pub fn rb_num2ll(num: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `unsigned long long`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned long long`.\n @return     The passed value converted into C's `unsigned long long`."]
    pub fn rb_num2ull(num: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `short`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `short`.\n @return     The passed value converted into C's `short`."]
    pub fn rb_num2short(num: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cNumeric into C's `unsigned short`.\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned short`.\n @return     The passed value converted into C's `unsigned short`."]
    pub fn rb_num2ushort(num: VALUE) -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " Identical to rb_num2short().\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `short`.\n @return     The passed value converted into C's `short`.\n\n @internal\n\n This function seems to be a complete  waste of disk space.  @shyouhei has no\n idea why this is a different thing from rb_num2short()."]
    pub fn rb_fix2short(num: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = " Identical to rb_num2ushort().\n\n @param[in]  num             Something numeric.\n @exception  rb_eTypeError   `num` is not a numeric.\n @exception  rb_eRangeError  `num` is out of range of `unsigned short`.\n @return     The passed value converted into C's `unsigned short`.\n\n @internal\n\n This function seems to be a complete  waste of disk space.  @shyouhei has no\n idea why this is a different thing from rb_num2ushort()."]
    pub fn rb_fix2ushort(num: VALUE) -> ::std::os::raw::c_ushort;
}
pub type st_data_t = ::std::os::raw::c_ulong;
pub type st_index_t = st_data_t;
pub type st_compare_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int,
>;
pub type st_hash_func = ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_index_t>;
pub type st_check_for_sizeof_st_index_t = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_hash_type {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int,
    >,
    pub hash: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_index_t>,
}
#[test]
fn bindgen_test_layout_st_hash_type() {
    const UNINIT: ::std::mem::MaybeUninit<st_hash_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<st_hash_type>(),
        8usize,
        concat!("Size of: ", stringify!(st_hash_type))
    );
    assert_eq!(
        ::std::mem::align_of::<st_hash_type>(),
        4usize,
        concat!("Alignment of ", stringify!(st_hash_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(st_hash_type),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(st_hash_type),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table {
    pub entry_power: ::std::os::raw::c_uchar,
    pub bin_power: ::std::os::raw::c_uchar,
    pub size_ind: ::std::os::raw::c_uchar,
    pub rebuilds_num: ::std::os::raw::c_uint,
    pub type_: *const st_hash_type,
    pub num_entries: st_index_t,
    pub bins: *mut st_index_t,
    pub entries_start: st_index_t,
    pub entries_bound: st_index_t,
    pub entries: *mut st_table_entry,
}
#[test]
fn bindgen_test_layout_st_table() {
    const UNINIT: ::std::mem::MaybeUninit<st_table> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<st_table>(),
        32usize,
        concat!("Size of: ", stringify!(st_table))
    );
    assert_eq!(
        ::std::mem::align_of::<st_table>(),
        4usize,
        concat!("Alignment of ", stringify!(st_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(entry_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bin_power) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(bin_power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_ind) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(size_ind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rebuilds_num) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(rebuilds_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bins) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(bins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries_start) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(entries_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries_bound) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(entries_bound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(st_table),
            "::",
            stringify!(entries)
        )
    );
}
pub const st_retval_ST_CONTINUE: st_retval = 0;
pub const st_retval_ST_STOP: st_retval = 1;
pub const st_retval_ST_DELETE: st_retval = 2;
pub const st_retval_ST_CHECK: st_retval = 3;
pub const st_retval_ST_REPLACE: st_retval = 4;
pub type st_retval = ::std::os::raw::c_uint;
extern "C" {
    pub fn rb_st_init_table(arg1: *const st_hash_type) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_table_with_size(arg1: *const st_hash_type, arg2: st_index_t)
        -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_delete(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_delete_safe(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_shift(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert2(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_data_t>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_lookup(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_get_key(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_update_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut st_data_t,
        value: *mut st_data_t,
        arg: st_data_t,
        existing: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_update(
        table: *mut st_table,
        key: st_data_t,
        func: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_foreach_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type st_foreach_check_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_foreach_with_replace(
        tab: *mut st_table,
        func: st_foreach_check_callback_func,
        replace: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach(
        arg1: *mut st_table,
        arg2: st_foreach_callback_func,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach_check(
        arg1: *mut st_table,
        arg2: st_foreach_check_callback_func,
        arg3: st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_keys(table: *mut st_table, keys: *mut st_data_t, size: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_keys_check(
        table: *mut st_table,
        keys: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values_check(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_add_direct(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t);
}
extern "C" {
    pub fn rb_st_free_table(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
}
extern "C" {
    pub fn rb_st_clear(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_copy(arg1: *mut st_table) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_numcmp(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_numhash(arg1: st_data_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_memsize(arg1: *const st_table) -> usize;
}
extern "C" {
    pub fn rb_st_hash(ptr: *const ::std::os::raw::c_void, len: usize, h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint32(h: st_index_t, i: u32) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_end(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_start(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_bulk_insert_into_st_table(
        arg1: ::std::os::raw::c_long,
        arg2: *const VALUE,
        arg3: VALUE,
    );
}
extern "C" {
    #[doc = " This  is  the  implementation  of  #RB_OBJ_WRITE().   People  don't  use  it\n directly.\n\n @param[in]   old    An object that points to `young`.\n @param[out]  young  An object that is referenced from `old`."]
    pub fn rb_gc_writebarrier(old: VALUE, young: VALUE);
}
extern "C" {
    #[doc = " This is the  implementation of #RB_OBJ_WB_UNPROTECT().  People  don't use it\n directly.\n\n @param[out] obj  An object that does not participate in WB."]
    pub fn rb_gc_writebarrier_unprotect(obj: VALUE);
}
pub const ruby_rarray_flags_RARRAY_EMBED_FLAG: ruby_rarray_flags = 8192;
pub const ruby_rarray_flags_RARRAY_EMBED_LEN_MASK: ruby_rarray_flags = 4161536;
pub const ruby_rarray_flags_RARRAY_TRANSIENT_FLAG: ruby_rarray_flags = 33554432;
#[doc = " @private\n\n Bits that you can set to ::RBasic::flags.\n\n @warning  These enums are not the only bits we use for arrays.\n\n @internal\n\n Unlike  strings, flag  usages for  arrays  are scattered  across the  entire\n source codes.  @shyouhei doesn't know the complete list.  But what is listed\n here is at least incomplete."]
pub type ruby_rarray_flags = ::std::os::raw::c_uint;
pub const ruby_rarray_consts_RARRAY_EMBED_LEN_SHIFT: ruby_rarray_consts = 15;
#[doc = " This is an enum because GDB wants it (rather than a macro).  People need not\n bother."]
pub type ruby_rarray_consts = ::std::os::raw::c_uint;
#[doc = " Ruby's array."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    pub as_: RArray__bindgen_ty_1,
}
#[doc = " Array's specific fields."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1 {
    pub heap: RArray__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 1usize],
}
#[doc = " Arrays  that  use separated  memory  region  for elements  use  this\n pattern."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Number of elements of the array."]
    pub len: ::std::os::raw::c_long,
    pub aux: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Pointer to the C array that holds the elements of the array.  In\n the old days  each array had dedicated memory  regions.  That is\n no  longer  true today,  but  there  still  are arrays  of  such\n properties.  This field could be used to point such things."]
    pub ptr: *const VALUE,
}
#[doc = " Auxiliary info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Capacity of `*ptr`.  A continuous  memory region of at least\n `capa` elements is expected to exist at `*ptr`.  This can be\n bigger than `len`."]
    pub capa: ::std::os::raw::c_long,
    pub shared_root: VALUE,
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shared_root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(shared_root)
        )
    );
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RArray__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(RArray__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(aux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RArray__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(RArray__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RArray__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray__bindgen_ty_1),
            "::",
            stringify!(ary)
        )
    );
}
#[test]
fn bindgen_test_layout_RArray() {
    const UNINIT: ::std::mem::MaybeUninit<RArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RArray>(),
        20usize,
        concat!("Size of: ", stringify!(RArray))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray>(),
        4usize,
        concat!("Alignment of ", stringify!(RArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RArray),
            "::",
            stringify!(as_)
        )
    );
}
extern "C" {
    #[doc = " @private\n\n Declares  a  section of  code  where  raw pointers  are  used.   This is  an\n implementation detail of #RARRAY_PTR_USE.  People don't use it directly.\n\n @param[in]  ary  An object of ::RArray.\n @return     `ary`'s backend C array."]
    pub fn rb_ary_ptr_use_start(ary: VALUE) -> *mut VALUE;
}
extern "C" {
    #[doc = " @private\n\n Declares an  end of  a section  formerly started  by rb_ary_ptr_use_start().\n This is  an implementation detail  of #RARRAY_PTR_USE.  People don't  use it\n directly.\n\n @param[in]  a  An object of ::RArray."]
    pub fn rb_ary_ptr_use_end(a: VALUE);
}
extern "C" {
    #[doc = " Destructively converts an array of transient backend into ordinal one.\n\n @param[out]  a  An object of ::RArray.\n @pre         `a` must be a transient array.\n @post        `a` gets out of transient heap, destructively."]
    pub fn rb_ary_detransient(a: VALUE);
}
extern "C" {
    #[doc = " The \"sign\" of a bignum.\n\n @param[in]  num  An object of RBignum.\n @retval     1    It is greater than or equal to zero.\n @retval     0    It is less than zero.\n\n @internal\n\n Implementation wise, unlike fixnums (which  are 2's complement), bignums are\n signed  magnitude  system.   Theoretically  it could  be  possible  to  have\n negative zero  instances.  But  in reality  there is no  way to  create such\n thing.  Nobody ever needed that kind of insanity."]
    pub fn rb_big_sign(num: VALUE) -> ::std::os::raw::c_int;
}
pub const ruby_rmodule_flags_RMODULE_IS_REFINEMENT: ruby_rmodule_flags = 32768;
#[doc = " @private\n\n Bits that you can set to ::RBasic::flags.\n\n @internal\n\n Why is it here, given RClass itself is not?"]
pub type ruby_rmodule_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns the superclass of a class.\n @param[in]  klass        An object of RClass.\n @retval     RUBY_Qfalse  `klass` has no super class.\n @retval     otherwise    Raw superclass of `klass`\n @see        rb_class_superclass\n\n ### Q&A ###\n\n - Q: How can a class have no super class?\n\n - A: `klass` could be a module.  Or it could be ::rb_cBasicObject.\n\n - Q: What do you mean by \"raw\" superclass?\n\n - A: This  is a  really good  question.  The  answer is  that this  function\n      returns something  different from what  you would normally  expect.  On\n      occasions  ruby  inserts  hidden  classes   in  a  hierarchy  of  class\n      inheritance behind-the-scene.   Such classes are called  \"iclass\"es and\n      distinguished  using  ::RUBY_T_ICLASS  in  C  level.   They  are  truly\n      transparent from Ruby  level but can be accessed from  C, by using this\n      API."]
    pub fn rb_class_get_superclass(klass: VALUE) -> VALUE;
}
#[doc = " This is  the type of callbacks  registered to ::RData.  The  argument is the\n `data` field."]
pub type RUBY_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " @deprecated\n\n Old  \"untyped\"  user  data.   It  has  roughly  the  same  usage  as  struct\n ::RTypedData, but lacked several features such as support for compaction GC.\n Use of this struct is not recommended  any longer.  If it is dead necessary,\n please inform the core devs about your usage.\n\n @internal\n\n @shyouhei tried to add RBIMPL_ATTR_DEPRECATED for this type but that yielded\n too many warnings  in the core.  Maybe  we want to retry  later...  Just add\n deprecated document for now."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RData {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    #[doc = " This function is called when the object is experiencing GC marks.  If it\n contains references to  other Ruby objects, you need to  mark them also.\n Otherwise GC will smash your data.\n\n @see      rb_gc_mark()\n @warning  This  is  called  during  GC  runs.   Object  allocations  are\n           impossible at that moment (that is why GC runs)."]
    pub dmark: RUBY_DATA_FUNC,
    #[doc = " This function is called when the object  is no longer used.  You need to\n do whatever necessary to avoid memory leaks.\n\n @warning  This  is  called  during  GC  runs.   Object  allocations  are\n           impossible at that moment (that is why GC runs)."]
    pub dfree: RUBY_DATA_FUNC,
    #[doc = " Pointer to the actual C level struct that you want to wrap."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RData() {
    const UNINIT: ::std::mem::MaybeUninit<RData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RData>(),
        20usize,
        concat!("Size of: ", stringify!(RData))
    );
    assert_eq!(
        ::std::mem::align_of::<RData>(),
        4usize,
        concat!("Alignment of ", stringify!(RData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RData),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmark) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RData),
            "::",
            stringify!(dmark)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfree) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RData),
            "::",
            stringify!(dfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RData),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " This is the primitive way to wrap an existing C struct into ::RData.\n\n @param[in]  klass          Ruby level class of the returning object.\n @param[in]  datap          Pointer to the target C struct.\n @param[in]  dmark          Mark function.\n @param[in]  dfree          Free function.\n @exception  rb_eTypeError  `klass` is not a class.\n @exception  rb_eNoMemError  Out of memory.\n @return     An allocated object that wraps `datap`."]
    pub fn rb_data_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_data_object_wrap(), except it  allocates a new  data region\n internally instead of taking an existing  one.  The allocation is done using\n ruby_calloc().   Hence  it  makes  no  sense to  pass  anything  other  than\n ::RUBY_DEFAULT_FREE to the last argument.\n\n @param[in]  klass          Ruby level class of the returning object.\n @param[in]  size           Requested size of memory to allocate.\n @param[in]  dmark          Mark function.\n @param[in]  dfree          Free function.\n @exception  rb_eTypeError  `klass` is not a class.\n @exception  rb_eNoMemError  Out of memory.\n @return     An allocated object that wraps a new `size` byte region."]
    pub fn rb_data_object_zalloc(
        klass: VALUE,
        size: usize,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    #[doc = " @private\n Documented in include/ruby/internal/globals.h"]
    pub static mut rb_cObject: VALUE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_io_t {
    _unused: [u8; 0],
}
#[doc = " Ruby's File  and IO.  Ruby's  IO are not  just file descriptors.   They have\n buffers.   They also  have  encodings.  Various  information are  controlled\n using this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFile {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    #[doc = " IO's specific fields."]
    pub fptr: *mut rb_io_t,
}
#[test]
fn bindgen_test_layout_RFile() {
    const UNINIT: ::std::mem::MaybeUninit<RFile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RFile>(),
        12usize,
        concat!("Size of: ", stringify!(RFile))
    );
    assert_eq!(
        ::std::mem::align_of::<RFile>(),
        4usize,
        concat!("Alignment of ", stringify!(RFile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RFile),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RFile),
            "::",
            stringify!(fptr)
        )
    );
}
extern "C" {
    #[doc = " Initializes the process for libruby.\n\n This function assumes this process is `ruby(1)` and it has just started.\n Usually programs that embed CRuby interpreter may not call this function,\n and may do their own initialization.\n\n @param[in]  argc  Pointer to process main's `argc`.\n @param[in]  argv  Pointer to process main's `argv`.\n @warning    `argc` and `argv` cannot be `NULL`.\n\n @internal\n\n AFAIK Ruby does write to argv, especially `argv[0][0]`, via setproctitle(3).\n It is intentional that the argument is not const-qualified."]
    pub fn ruby_sysinit(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Calls ruby_setup() and check error.\n\n Prints errors and calls exit(3) if an error occurred."]
    pub fn ruby_init();
}
extern "C" {
    #[doc = " Processes command line arguments and compiles the Ruby source to execute.\n\n This function does:\n   - Processes the given command line flags and arguments for `ruby(1)`\n   - Compiles the source code from the given argument, `-e` or `stdin`, and\n   - Returns the compiled source as an opaque pointer to an internal data\n     structure\n\n @param[in]  argc  Process main's `argc`.\n @param[in]  argv  Process main's `argv`.\n @return     An opaque pointer to the compiled source or an internal special\n             value.  Pass it to ruby_executable_node() to detect which.\n @see        ruby_executable_node"]
    pub fn ruby_options(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Checks the return value of ruby_options().\n\n ruby_options() sometimes returns a special value to indicate this process\n should immediately exit. This function checks if the case. Also stores the\n exit status that the caller have to pass to exit(3) into `*status`.\n\n @param[in]   n          A return value of ruby_options().\n @param[out]  status     Pointer to the exit status of this process.\n @retval      0          The given value is such a special value.\n @retval      otherwise  The given opaque pointer is actually a compiled\n                         source."]
    pub fn ruby_executable_node(
        n: *mut ::std::os::raw::c_void,
        status: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Runs the given compiled source and exits this process.\n\n @param[in]  n             Opaque \"node\" pointer.\n @retval     EXIT_SUCCESS  Successfully run the source.\n @retval     EXIT_FAILURE  An error occurred."]
    pub fn ruby_run_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prints the version information of the CRuby interpreter to stdout."]
    pub fn ruby_show_version();
}
extern "C" {
    #[doc = " Prints the copyright notice of the CRuby interpreter to stdout."]
    pub fn ruby_show_copyright();
}
extern "C" {
    #[doc = " Set stack bottom of Ruby implementation.\n\n You  must   call  this   function  before  any   heap  allocation   by  Ruby\n implementation.  Or GC will break living objects.\n\n @param[in]  addr  A pointer somewhere on the stack, near its bottom."]
    pub fn ruby_init_stack(addr: *mut VALUE);
}
extern "C" {
    #[doc = " Initializes the VM and builtin libraries.\n\n @retval  0          Initialization succeeded.\n @retval  otherwise  An error occurred.\n\n @internal\n\n Though not  a part of our  public API, the return  value is in fact  an enum\n ruby_tag_type.  You can  see the potential \"otherwise\" values  by looking at\n vm_core.h."]
    pub fn ruby_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destructs the VM.\n\n Runs the VM finalization processes as well as ruby_finalize(), and frees\n resources used by the VM.\n\n @param[in]  ex  Default value to the return value.\n @retval     EXIT_FAILURE  An error occurred.\n @retval     ex            Successful cleanup.\n @note       This function does not raise any exception."]
    pub fn ruby_cleanup(ex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Runs the VM finalization processes.\n\n `END{}` and procs registered by `Kernel.#at_exit` are executed here. See the\n Ruby language spec for more details.\n\n @note This function is allowed to raise an exception if an error occurred."]
    pub fn ruby_finalize();
}
extern "C" {
    #[doc = " Calls ruby_cleanup() and exits the process."]
    pub fn ruby_stop(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Checks for stack overflow.\n\n @retval  true   NG machine stack is about to overflow.\n @retval  false  OK there still is a room in the stack.\n\n @internal\n\n Does anybody use it?  So far @shyouhei have never seen any actual use-case."]
    pub fn ruby_stack_check() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries what Ruby thinks is the machine stack.  Ruby manages a region of\n memory.  It calls that area the \"machine stack\".  By calling this function,\n in spite of its name, you can obtain both one end of the stack and its\n length at once.  Which means you can know the entire region.\n\n @param[out]  topnotch  On return the pointer points to the upmost address of\n                        the macihne stack that Ruby knows.\n @return      Length of the machine stack that Ruby knows.\n\n @internal\n\n Does anybody use it?  @shyouhei is quite skeptical if this is useful outside\n of the VM.  Maybe it was a wrong idea to expose this API to 3rd parties."]
    pub fn ruby_stack_length(topnotch: *mut *mut VALUE) -> usize;
}
extern "C" {
    #[doc = " Identical to ruby_run_node(), except it returns an opaque execution status.\n You can pass it to rb_cleanup().\n\n @param[in]  n          Opaque \"node\" pointer.\n @retval     0          Successful end-of-execution.\n @retval     otherwise  An error occurred.\n\n @internal\n\n Though not  a part of our  public API, the return  value is in fact  an enum\n ruby_tag_type.  You can  see the potential \"otherwise\" values  by looking at\n vm_core.h."]
    pub fn ruby_exec_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the current script name to this value.\n\n This is similar to `$0 = name` in Ruby level but also affects\n `Method#location` and others.\n\n @param[in]  name  File name to set."]
    pub fn ruby_script(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical to ruby_script(), except it takes the name as a Ruby String\n instance.\n\n @param[in]  name  File name to set."]
    pub fn ruby_set_script_name(name: VALUE);
}
extern "C" {
    #[doc = " Defines built-in variables"]
    pub fn ruby_prog_init();
}
extern "C" {
    #[doc = " Sets argv that ruby understands.  Your program might have its own command\n line parameters etc.  Handle them as you wish, and pass remaining parts of\n argv here.\n\n @param[in]  argc  Number of elements of `argv`.\n @param[in]  argv  Command line arguments."]
    pub fn ruby_set_argv(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical to ruby_options(), except it raises ruby-level exceptions on\n failure.\n\n @param[in]  argc  Process main's `argc`.\n @param[in]  argv  Process main's `argv`.\n @return     An opaque \"node\" pointer."]
    pub fn ruby_process_options(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sets up `$LOAD_PATH`.\n\n @internal\n\n @shyouhei guesses this has to be called  at very later stage, at least after\n the birth of object system.  But is not exactly sure when."]
    pub fn ruby_init_loadpath();
}
extern "C" {
    #[doc = " Appends the given path to the end of the load path.\n\n @pre        ruby_init_loadpath() must be done beforehand.\n @param[in]  path  The path you want to push to the load path."]
    pub fn ruby_incpush(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Clear signal handlers.\n\n Ruby installs its own signal handler (apart from those which user scripts\n set).  This is to clear that.  Must be called when the ruby part terminates,\n before switching to your program's own logic."]
    pub fn ruby_sig_finalize();
}
extern "C" {
    pub fn rb_clear_constant_cache();
}
extern "C" {
    #[doc = " This is  the implementation detail  of #RHASH_SIZE.  People don't  call this\n directly.\n\n @param[in]  hash  An instance of RHash.\n @pre        `hash` must be of ::RUBY_T_HASH.\n @return     The size of the hash."]
    pub fn rb_hash_size_num(hash: VALUE) -> usize;
}
extern "C" {
    #[doc = " This is  the implementation  detail of #RHASH_TBL.   People don't  call this\n directly.\n\n @param[in]  hash  An instance of RHash.\n @param[in]  file  The `__FILE__`.\n @param[in]  line  The `__LINE__`.\n @pre        `hash` must be of ::RUBY_T_HASH.\n @return     Table that has the contents of the hash."]
    pub fn rb_hash_tbl(
        hash: VALUE,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut st_table;
}
extern "C" {
    #[doc = " This is the  implementation detail of #RHASH_SET_IFNONE.   People don't call\n this directly.\n\n @param[out]  hash    An instance of RHash.\n @param[in]   ifnone  Arbitrary default value.\n @pre        `hash` must be of ::RUBY_T_HASH."]
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
}
pub const ruby_robject_flags_ROBJECT_EMBED: ruby_robject_flags = 8192;
#[doc = " @private\n\n Bits that you can set to ::RBasic::flags."]
pub type ruby_robject_flags = ::std::os::raw::c_uint;
#[doc = " Ruby's ordinal objects.  Unless otherwise  special cased, all predefined and\n user-defined classes share this struct to hold their instances."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RObject {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    pub as_: RObject__bindgen_ty_1,
}
#[doc = " Object's specific fields."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union RObject__bindgen_ty_1 {
    pub heap: RObject__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 1usize],
}
#[doc = " Object that use  separated memory region for  instance variables use\n this pattern."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RObject__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Pointer to a C array that holds instance variables."]
    pub ivptr: *mut VALUE,
    #[doc = " This  is a  table that  holds  instance variable  name to  index\n mapping.  Used when accessing instance variables using names.\n\n @internal\n\n This is a shortcut for `RCLASS_IV_INDEX_TBL(rb_obj_class(obj))`."]
    pub iv_index_tbl: *mut rb_id_table,
}
#[test]
fn bindgen_test_layout_RObject__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RObject__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RObject__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RObject__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RObject__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RObject__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ivptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ivptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iv_index_tbl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(iv_index_tbl)
        )
    );
}
#[test]
fn bindgen_test_layout_RObject__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<RObject__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RObject__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RObject__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RObject__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RObject__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject__bindgen_ty_1),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject__bindgen_ty_1),
            "::",
            stringify!(ary)
        )
    );
}
#[test]
fn bindgen_test_layout_RObject() {
    const UNINIT: ::std::mem::MaybeUninit<RObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RObject>(),
        16usize,
        concat!("Size of: ", stringify!(RObject))
    );
    assert_eq!(
        ::std::mem::align_of::<RObject>(),
        4usize,
        concat!("Alignment of ", stringify!(RObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).as_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RObject),
            "::",
            stringify!(as_)
        )
    );
}
pub const ROBJECT_OFFSET_AS_HEAP_IVPTR: i32 = 8;
pub const ROBJECT_OFFSET_AS_HEAP_IV_INDEX_TBL: i32 = 12;
pub const ROBJECT_OFFSET_AS_ARY: i32 = 8;
#[doc = " @endcond"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_patter_buffer {
    _unused: [u8; 0],
}
#[doc = " Ruby's regular expression.   A regexp is compiled into  its own intermediate\n representation.  This  one holds that  info.  Regexp \"match\"  operation then\n executes that IR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RRegexp {
    #[doc = " Basic part, including flags and class."]
    pub basic: RBasic,
    #[doc = " The pattern buffer.   This is a quasi-opaque struct  that holds compiled\n intermediate representation of the regular expression.\n\n @note  Compilation of a regexp could be delayed until actual match."]
    pub ptr: *mut re_pattern_buffer,
    #[doc = " Source code of this expression."]
    pub src: VALUE,
    #[doc = " Reference count.  A  regexp match can take extraordinarily  long time to\n run.  Ruby's  regular expression is  heavily extended and not  a regular\n language any  longer; runs in NP-time  in practice.  Now, Ruby  also has\n threads and GVL.  In order to prevent long GVL lockup, our regexp engine\n can release it on occasions.  This means that multiple threads can touch\n a regular expressions at once.  That  itself is okay.  But their cleanup\n phase shall wait for all  the concurrent runs, to prevent use-after-free\n situation.  This field is used to  count such threads that are executing\n this particular pattern buffer.\n\n @warning  Of course, touching this field from extension libraries causes\n           catastrophic effects.  Just leave it."]
    pub usecnt: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_RRegexp() {
    const UNINIT: ::std::mem::MaybeUninit<RRegexp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RRegexp>(),
        20usize,
        concat!("Size of: ", stringify!(RRegexp))
    );
    assert_eq!(
        ::std::mem::align_of::<RRegexp>(),
        4usize,
        concat!("Alignment of ", stringify!(RRegexp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RRegexp),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RRegexp),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RRegexp),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usecnt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RRegexp),
            "::",
            stringify!(usecnt)
        )
    );
}
extern "C" {
    #[doc = " Returns the number of struct members.\n\n @param[in]  st  An instance of RStruct.\n @return     The number of members of `st`.\n @pre        `st` must be of ::RUBY_T_STRUCT."]
    pub fn rb_struct_size(st: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Struct#[]`.\n\n @param[in]  st              An instance of RStruct.\n @param[in]  k               Index a.k.a. key of the struct.\n @exception  rb_eTypeError   `k` is neither Numeric, Symbol, nor String.\n @exception  rb_eIndexError  Numerical index out of range.\n @exception  rb_eNameError   No such key.\n @return     The member stored at `k` in `st`.\n @pre        `st` must be of ::RUBY_T_STRUCT."]
    pub fn rb_struct_aref(st: VALUE, k: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Struct#[]=`.\n\n @param[out]  st              An instance of RStruct.\n @param[in]   k               Index a.k.a. key of the struct.\n @param[in]   v               Value to store.\n @exception  rb_eTypeError    `k` is neither Numeric, Symbol, nor String.\n @exception  rb_eIndexError   Numerical index out of range.\n @exception  rb_eNameError    No such key.\n @return     Passed `v`.\n @pre        `st` must be of ::RUBY_T_STRUCT.\n @post       `v` is stored at `k` in `st`."]
    pub fn rb_struct_aset(st: VALUE, k: VALUE, v: VALUE) -> VALUE;
}
pub const rbimpl_typeddata_flags_RUBY_TYPED_FREE_IMMEDIATELY: rbimpl_typeddata_flags = 1;
pub const rbimpl_typeddata_flags_RUBY_TYPED_FROZEN_SHAREABLE: rbimpl_typeddata_flags = 256;
pub const rbimpl_typeddata_flags_RUBY_TYPED_WB_PROTECTED: rbimpl_typeddata_flags = 32;
pub const rbimpl_typeddata_flags_RUBY_TYPED_PROMOTED1: rbimpl_typeddata_flags = 64;
#[doc = " @private\n\n Bits for rb_data_type_struct::flags."]
pub type rbimpl_typeddata_flags = ::std::os::raw::c_uint;
#[doc = " @copydoc rb_data_type_t"]
pub type rb_data_type_t = rb_data_type_struct;
#[doc = " @copydoc rb_data_type_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_data_type_struct {
    #[doc = " Name of  structs of this  kind.  This  is used for  diagnostic purposes.\n This has  to be unique  in the  process, but doesn't  has to be  a valid\n C/Ruby identifier."]
    pub wrap_struct_name: *const ::std::os::raw::c_char,
    pub function: rb_data_type_struct__bindgen_ty_1,
    #[doc = " Parent  of  this  class.   Sometimes  C  structs  have  inheritance-like\n relationships.  An example is `struct sockaddr`  and its family.  If you\n design such things,  make ::rb_data_type_t for each of  them and connect\n using this field.   Ruby can then transparently cast your  data back and\n forth when you call #TypedData_Get_Struct().\n\n ```CXX\n struct parent { };\n static inline const rb_data_type_t parent_type = {\n     .wrap_struct_name = \"parent\",\n };\n\n struct child: public parent { };\n static inline const rb_data_type_t child_type = {\n     .wrap_struct_name = \"child\",\n     .parent = &parent_type,\n };\n\n // This function can take both parent_class and child_class.\n static inline struct parent *\n get_parent(VALUE v)\n {\n     struct parent *p;\n     TypedData_Get_Struct(v, parent_type, struct parent, p);\n     return p;\n }\n ```"]
    pub parent: *const rb_data_type_t,
    #[doc = " Type-specific static data.   This area can be used for  any purpose by a\n programmer who define the type.  Ruby does not manage this at all."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Type-specific behavioural  characteristics.  This is a  bitfield.  It is\n an EXTREMELY  WISE IDEA to  leave this field  blank.  It is  designed so\n that setting  zero is the safest  thing to do.   If you risk to  set any\n bits on, you have to know exactly what you are doing.\n\n @internal\n\n Why it has to be a ::VALUE?  @shyouhei doesn't understand the design."]
    pub flags: VALUE,
}
#[doc = " Function pointers.  Resembles C++ `vtbl`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_data_type_struct__bindgen_ty_1 {
    #[doc = " This function  is called when  the object is experiencing  GC marks.\n If it  contains references to other  Ruby objects, you need  to mark\n them also.  Otherwise GC will smash your data.\n\n @see      rb_gc_mark()\n @warning  This  is called  during GC  runs.  Object  allocations are\n           impossible at that moment (that is why GC runs)."]
    pub dmark: RUBY_DATA_FUNC,
    #[doc = " This function is called when the object is no longer used.  You need\n to do whatever necessary to avoid memory leaks.\n\n @warning  This  is called  during GC  runs.  Object  allocations are\n           impossible at that moment (that is why GC runs)."]
    pub dfree: RUBY_DATA_FUNC,
    #[doc = " This function is to query the size of the underlying memory regions.\n\n @internal\n\n This  function  has  only  one   usage,  which  is  form  inside  of\n `ext/objspace`."]
    pub dsize:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> usize>,
    #[doc = " This  function  is  called  when  the  object  is  relocated.   Like\n ::rb_data_type_struct::dmark, you need to  update references to Ruby\n objects inside of your structs.\n\n @see      rb_gc_location()\n @warning  This  is called  during GC  runs.  Object  allocations are\n           impossible at that moment (that is why GC runs)."]
    pub dcompact: RUBY_DATA_FUNC,
    #[doc = " This field  is reserved for future  extension.  For now, it  must be\n filled with zeros."]
    pub reserved: [*mut ::std::os::raw::c_void; 1usize],
}
#[test]
fn bindgen_test_layout_rb_data_type_struct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rb_data_type_struct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rb_data_type_struct__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(rb_data_type_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_data_type_struct__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rb_data_type_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmark) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct__bindgen_ty_1),
            "::",
            stringify!(dmark)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfree) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct__bindgen_ty_1),
            "::",
            stringify!(dfree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct__bindgen_ty_1),
            "::",
            stringify!(dsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcompact) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct__bindgen_ty_1),
            "::",
            stringify!(dcompact)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_rb_data_type_struct() {
    const UNINIT: ::std::mem::MaybeUninit<rb_data_type_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rb_data_type_struct>(),
        36usize,
        concat!("Size of: ", stringify!(rb_data_type_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_data_type_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(rb_data_type_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrap_struct_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct),
            "::",
            stringify!(wrap_struct_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_data_type_struct),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " \"Typed\" user data.   By using this, extension libraries can  wrap a C struct\n to make it visible from Ruby.  For  instance if you have a `struct timeval`,\n and you want users to use it,\n\n ```CXX\n static inline const rb_data_type_t timeval_type = {\n     // Note that unspecified fields are 0-filled by default.\n     .wrap_struct_name = \"timeval\",\n     .function = {\n         .dmark = nullptr,                 // no need to mark\n         .dfree = RUBY_TYPED_DEFAULT_FREE, // use ruby_xfree()\n         .dsize = [](auto) {\n             return sizeof(struct timeval);\n         },\n     },\n };\n\n extern \"C\" void\n Init_timeval(void)\n {\n     auto klass = rb_define_class(\"YourName\", rb_cObject);\n\n     rb_define_alloc_func(klass, [](auto klass) {\n         struct timeval *t;\n         auto ret = TypedData_Make_Struct(\n            klass, struct timeval, &timeval_type, t);\n\n         if (auto i = gettimeofday(t, nullptr); i == -1) {\n             rb_sys_fail(\"gettimeofday(3)\");\n         }\n         else {\n             return ret;\n         }\n     });\n }\n ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTypedData {
    #[doc = " The part that all ruby objects have in common."]
    pub basic: RBasic,
    #[doc = " This field  stores various  information about how  Ruby should  handle a\n data.   This roughly  resembles a  Ruby level  class (apart  from method\n definition etc.)"]
    pub type_: *const rb_data_type_t,
    #[doc = " This has to be always 1.\n\n @internal\n\n Why, then, this is not a const ::VALUE?"]
    pub typed_flag: VALUE,
    #[doc = " Pointer to the actual C level struct that you want to wrap."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RTypedData() {
    const UNINIT: ::std::mem::MaybeUninit<RTypedData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RTypedData>(),
        20usize,
        concat!("Size of: ", stringify!(RTypedData))
    );
    assert_eq!(
        ::std::mem::align_of::<RTypedData>(),
        4usize,
        concat!("Alignment of ", stringify!(RTypedData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTypedData),
            "::",
            stringify!(basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTypedData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typed_flag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTypedData),
            "::",
            stringify!(typed_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTypedData),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " This is the primitive way to wrap an existing C struct into ::RTypedData.\n\n @param[in]  klass          Ruby level class of the returning object.\n @param[in]  datap          Pointer to the target C struct.\n @param[in]  type           The characteristics of the passed data.\n @exception  rb_eTypeError  `klass` is not a class.\n @exception  rb_eNoMemError  Out of memory.\n @return     An allocated object that wraps `datap`."]
    pub fn rb_data_typed_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        type_: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_data_typed_object_wrap(),  except it  allocates a  new data\n region internally instead of taking an existing one.  The allocation is done\n using ruby_calloc().  Hence it makes  no sense for `type->function.dfree` to\n be anything other than ::RUBY_TYPED_DEFAULT_FREE.\n\n @param[in]  klass          Ruby level class of the returning object.\n @param[in]  size           Requested size of memory to allocate.\n @param[in]  type           The characteristics of the passed data.\n @exception  rb_eTypeError  `klass` is not a class.\n @exception  rb_eNoMemError  Out of memory.\n @return     An allocated object that wraps a new `size` byte region."]
    pub fn rb_data_typed_object_zalloc(
        klass: VALUE,
        size: usize,
        type_: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Checks for the domestic relationship between the two.\n\n @param[in]  child   A data type supposed to be a child of `parent`.\n @param[in]  parent  A data type supposed to be a parent of `child`.\n @retval     true    `child` is a descendent of `parent`.\n @retval     false   Otherwise.\n\n @internal\n\n You can path NULL to both arguments, don't know what that means though."]
    pub fn rb_typeddata_inherited_p(
        child: *const rb_data_type_t,
        parent: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks if the given object is of given kind.\n\n @param[in]  obj        An instance of ::RTypedData.\n @param[in]  data_type  Expected data type of `obj`.\n @retval     true       `obj` is of `data_type`.\n @retval     false      Otherwise."]
    pub fn rb_typeddata_is_kind_of(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_typeddata_is_kind_of(), except  it raises exceptions instead\n of returning false.\n\n @param[in]  obj            An instance of ::RTypedData.\n @param[in]  data_type      Expected data type of `obj`.\n @exception  rb_eTypeError  obj is not of `data_type`.\n @return     Unwrapped C struct that `obj` holds.\n @post       Upon successful return `obj`'s type is guaranteed `data_type`."]
    pub fn rb_check_typeddata(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Our own locale-insensitive version of  `strtoul(3)`.  The conversion is done\n as if the current locale is set  to the \"C\" locale, no matter actual runtime\n locale settings.\n\n @note        This is needed because  `strtoul(\"i\", 0, 36)` would return zero\n              if it is locale sensitive and the current locale is `tr_TR`.\n @param[in]   str     String of digits,  optionally preceded with whitespaces\n                      (ignored) and optionally `+` or `-` sign.\n @param[out]  endptr  NULL, or an arbitrary pointer (overwritten on return).\n @param[in]   base    `2` to  `36` inclusive for  each base, or  special case\n                      `0` to detect the base from the contents of the string.\n @return      Converted integer, casted to unsigned long.\n @post        If `endptr` is not NULL, it  is updated to point the first such\n              byte where conversion failed.\n @note        This function sets `errno` on failure.\n                - `EINVAL`: Passed `base` is out of range.\n                - `ERANGE`: Converted integer is out of range of `long`.\n @warning     As far as @shyouhei reads ISO/IEC 9899:2018 section 7.22.1.4, a\n              conforming  `strtoul`  implementation   shall  render  `ERANGE`\n              whenever  it  finds  the  input string  represents  a  negative\n              integer.  Such thing can never be representable using `unsigned\n              long`.   However  this  implementation  does  not  honour  that\n              language.   It just  casts such  negative value  to the  return\n              type, resulting a very big  return value.  This behaviour is at\n              least questionable.  But  we can no longer change  that at this\n              point.\n @note        Not only  does this  function works under  the \"C\"  locale, but\n              also assumes its execution character  set be what ruby calls an\n              ASCII-compatible  character set;  which  does  not include  for\n              instance EBCDIC or UTF-16LE."]
    pub fn ruby_strtoul(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Evaluates the given string in an isolated binding.\n\n Here  \"isolated\"  means  that  the   binding  does  not  inherit  any  other\n bindings.  This behaves same as the binding for required libraries.\n\n `__FILE__`  will  be  `\"(eval)\"`,  and  `__LINE__`  starts  from  1  in  the\n evaluation.\n\n @param[in]  str            Ruby code to evaluate.\n @exception  rb_eException  Raises an exception on error.\n @return     The evaluated result."]
    pub fn rb_eval_string(str_: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_eval_string(), except  it avoids potential  global escapes.\n Such global escapes include exceptions, `throw`, `break`, for example.\n\n It first evaluates the given string  as rb_eval_string() does.  If no global\n escape occurred during the evaluation, it returns the result and `*state` is\n zero.   Otherwise, it  returns some  undefined  value and  sets `*state`  to\n nonzero.  If state is `NULL`, it is not set in both cases.\n\n @param[in]   str    Ruby code to evaluate.\n @param[out]  state  State of execution.\n @return      The  evaluated  result  if  succeeded, an  undefined  value  if\n              otherwise.\n @post        `*state` is set to zero if succeeded.  Nonzero otherwise.\n @warning     You have to clear the error info with `rb_set_errinfo(Qnil)` if\n              you decide to ignore the caught exception.\n @see         rb_eval_string\n @see         rb_protect\n\n @internal\n\n The \"undefined value\"  described above is in fact ::RUBY_Qnil  for now.  But\n @shyouhei doesn't think that we would never change that.\n\n Though   not  a   part  of   our  public   API,  `state`   is  in   fact  an\n enum ruby_tag_type.  You can  see the potential \"nonzero\"  values by looking\n at vm_core.h."]
    pub fn rb_eval_string_protect(
        str_: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_eval_string_protect(), except  it evaluates the given string\n under  a module  binding in  an isolated  binding.  This  is the  same as  a\n binding for loaded libraries on `rb_load(something, true)`.\n\n @param[in]   str    Ruby code to evaluate.\n @param[out]  state  State of execution.\n @return      The  evaluated  result  if  succeeded, an  undefined  value  if\n              otherwise.\n @post        `*state` is set to zero if succeeded.  Nonzero otherwise.\n @warning     You have to clear the error info with `rb_set_errinfo(Qnil)` if\n              you decide to ignore the caught exception.\n @see         rb_eval_string"]
    pub fn rb_eval_string_wrap(
        str_: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Calls a method.  Can call both public and private methods.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      n                  Number of arguments that follow.\n @param[in]      ...                Arbitrary number of method arguments.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcall(recv: VALUE, mid: ID, n: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_funcall(),  except it  takes the  method arguments  as a  C\n array.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcallv(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_funcallv(), except you can  specify how to handle  the last\n element of the given array.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @param[in]      kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcallv_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_funcallv(),  except  it only  takes  public  methods  into\n account.  This is roughly Ruby's `Object#public_send`.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcallv_public(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_funcallv_public(), except you  can specify how to handle the\n last element of the given array.  It can also be seen as a routine identical\n to rb_funcallv_kw(), except it only takes public methods into account.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @param[in]      kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcallv_public_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_funcallv_public(), except you can pass the passed block.\n\n Sometimes you want  to \"pass\" a block parameter form  one method to another.\n Suppose you have this Ruby method `foo`:\n\n ```ruby\n def foo(x, y, &z)\n   x.open(y, &z)\n end\n ```\n\n And    suppose   you    want    to   translate    this    into   C.     Then\n rb_funcall_passing_block() function is usable in this situation.\n\n ```CXX\n VALUE\n foo_translated_into_C(VALUE self, VALUE x, VALUE y)\n {\n     const auto open = rb_intern(\"open\");\n\n     return rb_funcall_passing_block(x, open, 1, &y);\n }\n ```\n\n @see            rb_yield_block\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcall_passing_block(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_funcallv_passing_block(),  except  you can  specify how  to\n handle  the last  element of  the given  array.  It  can also  be seen  as a\n routine identical to rb_funcallv_public_kw(), except you can pass the passed\n block.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @param[in]      kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcall_passing_block_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_funcallv_public(), except  you can pass  a block.   A block\n here  basically is  an  instance of  ::rb_cProc.  If  you  want to  exercise\n `to_proc` conversion, do so before passing it here.  However nil and symbols\n are special-case allowed.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @param[in]      procval            An instance of Proc, Symbol, or NilClass.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to.\n\n @internal\n\n Implementation-wise, `procval`  is in  fact a  \"block handler\"  object.  You\n could also pass an IFUNC (block_handler_ifunc) here to say precise.  --- But\n AFAIK there is no  3rd party way to even know that  there are objects called\n IFUNC behind-the-scene."]
    pub fn rb_funcall_with_block(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        procval: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_funcallv_with_block(), except you  can specify how to handle\n the last  element of  the given  array.  It can  also be  seen as  a routine\n identical to rb_funcallv_public_kw(), except you can pass a block.\n\n @param[in,out]  recv               Receiver of the method.\n @param[in]      mid                Name of the method to call.\n @param[in]      argc               Number of arguments.\n @param[in]      argv               Arbitrary number of method arguments.\n @param[in]      procval            An instance of Proc, Symbol, or NilClass.\n @param[in]      kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception      rb_eNoMethodError  No such method.\n @exception      rb_eNoMethodError  The method is private or protected.\n @exception      rb_eException      Any exceptions happen inside.\n @return         What the method evaluates to."]
    pub fn rb_funcall_with_block_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        procval: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " This resembles ruby's `super`.\n\n @param[in]  argc               Number of arguments.\n @param[in]  argv               Arbitrary number of method arguments.\n @exception  rb_eNoMethodError  No super method are there.\n @exception  rb_eException      Any exceptions happen inside.\n @return     What the super method evaluates to."]
    pub fn rb_call_super(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_call_super(), except you can  specify how to handle the last\n element of the given array.\n\n @param[in]  argc               Number of arguments.\n @param[in]  argv               Arbitrary number of method arguments.\n @param[in]  kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eNoMethodError  No super method are there.\n @exception  rb_eException      Any exceptions happen inside.\n @return     What the super method evaluates to."]
    pub fn rb_call_super_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " This resembles ruby's `self`.\n\n @exception  rb_eRuntimeError  Called from outside of method context.\n @return     Current receiver."]
    pub fn rb_current_receiver() -> VALUE;
}
extern "C" {
    #[doc = " Keyword argument deconstructor.\n\n Retrieves argument values bound to  keywords, which directed by `table` into\n `values`,  deleting retrieved  entries  from `keyword_hash`  along the  way.\n First  `required` number  of  IDs  referred by  `table`  are mandatory,  and\n succeeding `optional`  (`-optional-1` if  `optional` is negative)  number of\n IDs are  optional.  If a mandatory  key is not contained  in `keyword_hash`,\n raises ::rb_eArgError.  If an optional key is not present in `keyword_hash`,\n the  corresponding  element  in  `values`   is  set  to  ::RUBY_Qundef.   If\n `optional` is negative, rest of `keyword_hash` are ignored, otherwise raises\n ::rb_eArgError.\n\n @warning     Handling keyword arguments in the  C API is less efficient than\n              handling them  in Ruby.  Consider  using a Ruby  wrapper method\n              around a non-keyword C function.\n @see         https://bugs.ruby-lang.org/issues/11339\n @param[out]  keyword_hash  Target hash to deconstruct.\n @param[in]   table         List of keywords that you are interested in.\n @param[in]   required      Number of mandatory keywords.\n @param[in]   optional      Number of optional keywords (can be negative).\n @param[out]  values        Buffer to be filled.\n @exception   rb_eArgError  Absence of a mandatory keyword.\n @exception   rb_eArgError  Found an unknown keyword.\n @return      Number of found values that are stored into `values`."]
    pub fn rb_get_kwargs(
        keyword_hash: VALUE,
        table: *const ID,
        required: ::std::os::raw::c_int,
        optional: ::std::os::raw::c_int,
        values: *mut VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Splits a hash into two.\n\n Takes  a hash  of various  keys, and  split it  into symbol-keyed  parts and\n others.   Symbol-keyed part  becomes  the return  value.   What remains  are\n returned as a new hash object stored at the argument pointer.\n\n @param[in,out]  orighash  Pointer to a target hash to split.\n @return         An extracted keyword hash.\n @post           Upon  successful return  `orighash` points  to another  hash\n                 object, whose contents are the remainder of the operation.\n @note           The argument hash object is not modified."]
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
}
#[doc = " Represents event(s).  As the name implies events are bit flags."]
pub type rb_event_flag_t = u32;
#[doc = " Type of event hooks.  When an  event happens registered functions are kicked\n with appropriate parameters.\n\n @param[in]  evflag  The kind of event that happened.\n @param[in]  data    The `data` passed to rb_add_event_hook().\n @param[in]  self    Current receiver.\n @param[in]  mid     Name of the current method.\n @param[in]  klass   Current class."]
pub type rb_event_hook_func_t = ::std::option::Option<
    unsafe extern "C" fn(evflag: rb_event_flag_t, data: VALUE, self_: VALUE, mid: ID, klass: VALUE),
>;
extern "C" {
    #[doc = " Registers an event hook function.\n\n @param[in]  func    A callback.\n @param[in]  events  A set of events that `func` should run.\n @param[in]  data    Passed as-is to `func`."]
    pub fn rb_add_event_hook(func: rb_event_hook_func_t, events: rb_event_flag_t, data: VALUE);
}
extern "C" {
    #[doc = " Removes the passed function from the list of event hooks.\n\n @param[in]  func  A callback.\n @return     Number of deleted event hooks.\n @note       As  multiple  events can  share  the  same  `func` it  is  quite\n             possible for the return value to become more than one.\n\n @internal\n\n @shyouhei doesn't know if this is an  Easter egg or an official feature, but\n you can pass 0 to the argument.  That effectively swipes everything out from\n the hook list."]
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inform the garbage collector that `valptr` points to a live Ruby object that\n should not be moved. Note that extensions should use this API on global\n constants instead of assuming constants defined in Ruby are always alive.\n Ruby code can remove global constants."]
    pub fn rb_gc_register_address(valptr: *mut VALUE);
}
extern "C" {
    #[doc = " An alias for `rb_gc_register_address()`."]
    pub fn rb_global_variable(arg1: *mut VALUE);
}
extern "C" {
    #[doc = " Inform the garbage collector that a pointer previously passed to\n `rb_gc_register_address()` no longer points to a live Ruby object."]
    pub fn rb_gc_unregister_address(valptr: *mut VALUE);
}
extern "C" {
    #[doc = " Inform the garbage collector that `object` is a live Ruby object that should\n not be moved.\n\n See also: rb_gc_register_address()"]
    pub fn rb_gc_register_mark_object(object: VALUE);
}
#[doc = " Type of a glob callback function.  Called every time glob scans a path.\n\n @param[in]  path       The path in question.\n @param[in]  arg        The argument passed to rb_glob().\n @param[in]  enc        Encoding of the path.\n @retval     -1         Not enough memory to do the operation.\n @retval     0          Operation successful.\n @retval     otherwise  Opaque exception state.\n @note       You can use rb_protect() to generate the return value.\n\n @internal\n\n This  is a  wrong design.   Type of  `enc` should  have been  `rb_encoding*`\n instead of just `void*`.  But we cannot change the API any longer.\n\n Though not a part of our public API, the \"opaque exception state\" is in fact\n an  enum ruby_tag_type.   You can  see the  potential \"otherwise\"  values by\n looking at vm_core.h."]
pub type ruby_glob_func = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        arg: VALUE,
        enc: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " The \"glob\"  operator.  Expands  the given pattern  against the  actual local\n filesystem,  then  iterates  over  the expanded  filenames  by  calling  the\n callback function.\n\n @param[in]  pattern        A glob pattern.\n @param[in]  func           Identical to ruby_glob_func,  except it can raise\n                            exceptions instead of returning opaque state.\n @param[in]  arg            Extra argument passed to func.\n @exception  rb_eException  Can propagate what `func` raises.\n @note       The  language  accepted   as  the  pattern  is   not  a  regular\n             expression.  It resembles shell's glob."]
    pub fn rb_glob(
        pattern: *const ::std::os::raw::c_char,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                path: *const ::std::os::raw::c_char,
                arg: VALUE,
                enc: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: VALUE,
    );
}
extern "C" {
    #[doc = " Identical to rb_glob(), except it returns opaque exception states instead of\n raising exceptions.\n\n @param[in]  pattern  A glob pattern.\n @param[in]  flags    No, you are not allowed to use this.  Just pass 0.\n @param[in]  func     A callback function.\n @param[in]  arg      Extra argument passed to func.\n @return     Return value of `func`.\n\n @internal\n\n This function is  completely broken by design...  Not only  is there no sane\n way to pass flags, but there also is no sane way to know what a return value\n is meant to be.\n\n Though not a part of our public API, and @shyouhei thinks it's a failure not\n to be  a public  API, the  flags can  be `FNM_EXTGLOB`,  `FNM_DOTMATCH` etc.\n Look at dir.c for the list.\n\n Though  not a  part  of our  public  API, the  return value  is  in fact  an\n enum ruby_tag_type.   You  can  see  the  potential  values  by  looking  at\n vm_core.h."]
    pub fn ruby_glob(
        pattern: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        func: ruby_glob_func,
        arg: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to  ruby_glob(), @shyouhei  currently suspects.   Historically you\n had to  call this function  instead of  ruby_glob() if the  pattern included\n \"{x,y,...}\" syntax.  However since commit 0f63d961169989a7f6dcf7c0487fe29da,\n ruby_glob() also  supports that syntax.   It seems  as of writing  these two\n functions  provide   basically  the   same  functionality  in   a  different\n implementation.  Is this analysis right?  Correct me! :FIXME:\n\n @param[in]  pattern  A glob pattern.\n @param[in]  flags    No, you are not allowed to use this.  Just pass 0.\n @param[in]  func     A callback function.\n @param[in]  arg      Extra argument passed to func.\n @return     Return value of `func`."]
    pub fn ruby_brace_glob(
        pattern: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        func: ruby_glob_func,
        arg: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "< `Kernel` module."]
    pub static mut rb_mKernel: VALUE;
}
extern "C" {
    #[doc = "< `Comparable` module."]
    pub static mut rb_mComparable: VALUE;
}
extern "C" {
    #[doc = "< `Enumerable` module."]
    pub static mut rb_mEnumerable: VALUE;
}
extern "C" {
    #[doc = "< `Errno` module."]
    pub static mut rb_mErrno: VALUE;
}
extern "C" {
    #[doc = "< `FileTest` module."]
    pub static mut rb_mFileTest: VALUE;
}
extern "C" {
    #[doc = "< `GC` module."]
    pub static mut rb_mGC: VALUE;
}
extern "C" {
    #[doc = "< `Math` module."]
    pub static mut rb_mMath: VALUE;
}
extern "C" {
    #[doc = "< `Process` module."]
    pub static mut rb_mProcess: VALUE;
}
extern "C" {
    #[doc = "< `IO::WaitReadable` module."]
    pub static mut rb_mWaitReadable: VALUE;
}
extern "C" {
    #[doc = "< `IO::WaitReadable` module."]
    pub static mut rb_mWaitWritable: VALUE;
}
extern "C" {
    #[doc = "< `BasicObject` class."]
    pub static mut rb_cBasicObject: VALUE;
}
extern "C" {
    #[doc = "< `Array` class."]
    pub static mut rb_cArray: VALUE;
}
extern "C" {
    #[doc = "< `Binding` class."]
    pub static mut rb_cBinding: VALUE;
}
extern "C" {
    #[doc = "< `Class` class."]
    pub static mut rb_cClass: VALUE;
}
extern "C" {
    #[doc = "< `Dir` class."]
    pub static mut rb_cDir: VALUE;
}
extern "C" {
    #[doc = "< `Encoding` class."]
    pub static mut rb_cEncoding: VALUE;
}
extern "C" {
    #[doc = "< `Enumerator` class."]
    pub static mut rb_cEnumerator: VALUE;
}
extern "C" {
    #[doc = "< `FalseClass` class."]
    pub static mut rb_cFalseClass: VALUE;
}
extern "C" {
    #[doc = "< `File` class."]
    pub static mut rb_cFile: VALUE;
}
extern "C" {
    #[doc = "< `Complex` class."]
    pub static mut rb_cComplex: VALUE;
}
extern "C" {
    #[doc = "< `Float` class."]
    pub static mut rb_cFloat: VALUE;
}
extern "C" {
    #[doc = "< `Hash` class."]
    pub static mut rb_cHash: VALUE;
}
extern "C" {
    #[doc = "< `IO` class."]
    pub static mut rb_cIO: VALUE;
}
extern "C" {
    #[doc = "< `Module` class."]
    pub static mut rb_cInteger: VALUE;
}
extern "C" {
    #[doc = "< `MatchData` class."]
    pub static mut rb_cMatch: VALUE;
}
extern "C" {
    #[doc = "< `Method` class."]
    pub static mut rb_cMethod: VALUE;
}
extern "C" {
    #[doc = "< `Module` class."]
    pub static mut rb_cModule: VALUE;
}
extern "C" {
    #[doc = "< `Refinement` class."]
    pub static mut rb_cRefinement: VALUE;
}
extern "C" {
    #[doc = "< `NameError::Message` class."]
    pub static mut rb_cNameErrorMesg: VALUE;
}
extern "C" {
    #[doc = "< `NilClass` class."]
    pub static mut rb_cNilClass: VALUE;
}
extern "C" {
    #[doc = "< `Numeric` class."]
    pub static mut rb_cNumeric: VALUE;
}
extern "C" {
    #[doc = "< `Proc` class."]
    pub static mut rb_cProc: VALUE;
}
extern "C" {
    #[doc = "< `Random` class."]
    pub static mut rb_cRandom: VALUE;
}
extern "C" {
    #[doc = "< `Range` class."]
    pub static mut rb_cRange: VALUE;
}
extern "C" {
    #[doc = "< `Rational` class."]
    pub static mut rb_cRational: VALUE;
}
extern "C" {
    #[doc = "< `Regexp` class."]
    pub static mut rb_cRegexp: VALUE;
}
extern "C" {
    #[doc = "< `File::Stat` class."]
    pub static mut rb_cStat: VALUE;
}
extern "C" {
    #[doc = "< `String` class."]
    pub static mut rb_cString: VALUE;
}
extern "C" {
    #[doc = "< `Struct` class."]
    pub static mut rb_cStruct: VALUE;
}
extern "C" {
    #[doc = "< `Sumbol` class."]
    pub static mut rb_cSymbol: VALUE;
}
extern "C" {
    #[doc = "< `Thread` class."]
    pub static mut rb_cThread: VALUE;
}
extern "C" {
    #[doc = "< `Time` class."]
    pub static mut rb_cTime: VALUE;
}
extern "C" {
    #[doc = "< `TrueClass` class."]
    pub static mut rb_cTrueClass: VALUE;
}
extern "C" {
    #[doc = "< `UnboundMethod` class."]
    pub static mut rb_cUnboundMethod: VALUE;
}
extern "C" {
    #[doc = "< Mother of all exceptions."]
    pub static mut rb_eException: VALUE;
}
extern "C" {
    #[doc = "< `StandardError` exception."]
    pub static mut rb_eStandardError: VALUE;
}
extern "C" {
    #[doc = "< `SystemExit` exception."]
    pub static mut rb_eSystemExit: VALUE;
}
extern "C" {
    #[doc = "< `Interrupt` exception."]
    pub static mut rb_eInterrupt: VALUE;
}
extern "C" {
    #[doc = "< `SignalException` exception."]
    pub static mut rb_eSignal: VALUE;
}
extern "C" {
    #[doc = "< `fatal` exception."]
    pub static mut rb_eFatal: VALUE;
}
extern "C" {
    #[doc = "< `ArgumentError` exception."]
    pub static mut rb_eArgError: VALUE;
}
extern "C" {
    #[doc = "< `EOFError` exception."]
    pub static mut rb_eEOFError: VALUE;
}
extern "C" {
    #[doc = "< `IndexError` exception."]
    pub static mut rb_eIndexError: VALUE;
}
extern "C" {
    #[doc = "< `StopIteration` exception."]
    pub static mut rb_eStopIteration: VALUE;
}
extern "C" {
    #[doc = "< `KeyError` exception."]
    pub static mut rb_eKeyError: VALUE;
}
extern "C" {
    #[doc = "< `RangeError` exception."]
    pub static mut rb_eRangeError: VALUE;
}
extern "C" {
    #[doc = "< `IOError` exception."]
    pub static mut rb_eIOError: VALUE;
}
extern "C" {
    #[doc = "< `RuntimeError` exception."]
    pub static mut rb_eRuntimeError: VALUE;
}
extern "C" {
    #[doc = "< `FrozenError` exception."]
    pub static mut rb_eFrozenError: VALUE;
}
extern "C" {
    #[doc = "< `SecurityError` exception."]
    pub static mut rb_eSecurityError: VALUE;
}
extern "C" {
    #[doc = "< `SystemCallError` exception."]
    pub static mut rb_eSystemCallError: VALUE;
}
extern "C" {
    #[doc = "< `ThreadError` exception."]
    pub static mut rb_eThreadError: VALUE;
}
extern "C" {
    #[doc = "< `TypeError` exception."]
    pub static mut rb_eTypeError: VALUE;
}
extern "C" {
    #[doc = "< `ZeroDivisionError` exception."]
    pub static mut rb_eZeroDivError: VALUE;
}
extern "C" {
    #[doc = "< `NotImplementedError` exception."]
    pub static mut rb_eNotImpError: VALUE;
}
extern "C" {
    #[doc = "< `NoMemoryError` exception."]
    pub static mut rb_eNoMemError: VALUE;
}
extern "C" {
    #[doc = "< `NoMethodError` exception."]
    pub static mut rb_eNoMethodError: VALUE;
}
extern "C" {
    #[doc = "< `FloatDomainError` exception."]
    pub static mut rb_eFloatDomainError: VALUE;
}
extern "C" {
    #[doc = "< `LocalJumpError` exception."]
    pub static mut rb_eLocalJumpError: VALUE;
}
extern "C" {
    #[doc = "< `SystemStackError` exception."]
    pub static mut rb_eSysStackError: VALUE;
}
extern "C" {
    #[doc = "< `RegexpError` exception."]
    pub static mut rb_eRegexpError: VALUE;
}
extern "C" {
    #[doc = "< `EncodingError` exception."]
    pub static mut rb_eEncodingError: VALUE;
}
extern "C" {
    #[doc = "< `Encoding::CompatibilityError` exception."]
    pub static mut rb_eEncCompatError: VALUE;
}
extern "C" {
    #[doc = "< `NoMatchingPatternError` exception."]
    pub static mut rb_eNoMatchingPatternError: VALUE;
}
extern "C" {
    #[doc = "< `NoMatchingPatternKeyError` exception."]
    pub static mut rb_eNoMatchingPatternKeyError: VALUE;
}
extern "C" {
    #[doc = "< `ScriptError` exception."]
    pub static mut rb_eScriptError: VALUE;
}
extern "C" {
    #[doc = "< `NameError` exception."]
    pub static mut rb_eNameError: VALUE;
}
extern "C" {
    #[doc = "< `SyntaxError` exception."]
    pub static mut rb_eSyntaxError: VALUE;
}
extern "C" {
    #[doc = "< `LoadError` exception."]
    pub static mut rb_eLoadError: VALUE;
}
extern "C" {
    #[doc = "< `Math::DomainError` exception."]
    pub static mut rb_eMathDomainError: VALUE;
}
extern "C" {
    #[doc = "< `STDIN` constant."]
    pub static mut rb_stdin: VALUE;
}
extern "C" {
    #[doc = "< `STDOUT` constant."]
    pub static mut rb_stdout: VALUE;
}
extern "C" {
    #[doc = "< `STDERR` constant."]
    pub static mut rb_stderr: VALUE;
}
#[doc = " This is the  type of a function that the  interpreter expect for C-backended\n blocks.  Blocks are  often written in Ruby.  But C  extensions might want to\n have their own blocks.  In order to  do so authors have to create a separate\n C function of this type, and pass its pointer to rb_block_call().\n\n ```CXX\n VALUE\n my_own_iterator(RB_BLOCK_CALL_FUNC_ARGLIST(y, c))\n {\n     const auto plus = rb_intern(\"+\");\n     return rb_funcall(c, plus, 1, y);\n }\n\n VALUE\n my_own_method(VALUE self)\n {\n     const auto each = rb_intern(\"each\");\n     return rb_block_call(self, each, 0, 0, my_own_iterator, self);\n }\n ```"]
pub type rb_block_call_func = ::std::option::Option<
    unsafe extern "C" fn(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE,
>;
#[doc = " Shorthand type that represents an iterator-written-in-C function pointer."]
pub type rb_block_call_func_t = rb_block_call_func;
extern "C" {
    #[doc = " This is a shorthand of calling `obj.each`.\n\n @param[in]  obj  The receiver.\n @return     What `obj.each` returns.\n\n @internal\n\n Does anyone still need it?  This API  was to use with rb_iterate(), which is\n marked deprecated (see below).  Old idiom to call an iterator was:\n\n ```CXX\n VALUE recv;\n VALUE iter_func(ANYARGS);\n VALUE iter_data;\n rb_iterate(rb_each, recv, iter_func, iter_data);\n ```"]
    pub fn rb_each(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Yields the block.  In Ruby there is  a concept called a block.  You can pass\n one to a  method.  In a method, when  called with a block, you  can yield it\n using this function.\n\n ```CXX\n VALUE\n iterate(VALUE self)\n {\n     extern int get_n(VALUE);\n     extern VALUE get_v(VALUE, VALUE);\n     const auto n = get_n(self);\n\n     for (int i=0; i<n; i++) {\n         auto v = get_v(self, i);\n\n         rb_yield(v);\n     }\n     return self;\n }\n ```\n\n @param[in]  val                 Passed to the block.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_yield(),  except it takes variadic number  of parameters and\n pass them to the block.\n\n @param[in]  n                   Number of parameters.\n @param[in]  ...                 List of arguments passed to the block.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield_values(n: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_yield_values(),  except it takes the parameters as a C array\n instead of variadic arguments.\n\n @param[in]  n                   Number of parameters.\n @param[in]  argv                List of arguments passed to the block.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield_values2(n: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_yield_values2(), except you  can specify how to  handle the\n last element of the given array.\n\n @param[in]  n                   Number of parameters.\n @param[in]  argv                List of arguments passed to the block.\n @param[in]  kw_splat            Handling of keyword parameters:\n   - RB_NO_KEYWORDS              `ary`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS            `ary`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS     makes no sense here.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield_values_kw(
        n: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_yield_values(), except it  splats an array to  generate the\n list of parameters.\n\n @param[in]  ary                 Array to splat.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield_splat(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_yield_splat(), except you can specify how to handle the last\n element of the given array.\n\n @param[in]  ary                 Array to splat.\n @param[in]  kw_splat            Handling of keyword parameters:\n   - RB_NO_KEYWORDS              `ary`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS            `ary`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS     makes no sense here.\n @exception  rb_eLocalJumpError  There is no block given.\n @return     Evaluated value of the given block."]
    pub fn rb_yield_splat_kw(ary: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Pass a passed block.\n\n Sometimes you  want to \"pass\" a  block form one method  to another.  Suppose\n you have this Ruby method `foo`:\n\n ```ruby\n def foo(x, y)\n   x.open(y) do |*z|\n     yield(*z)\n   end\n end\n ```\n\n And  suppose you  want  to  translate this  into  C.  Then  rb_yield_block()\n function is usable in this situation.\n\n ```CXX\n VALUE\n foo_translated_into_C(VALUE self, VALUE x, VALUE y)\n {\n     const auto open = rb_intern(\"open\");\n\n     return rb_block_call(x, open, 1, &y, rb_yield_block, Qfalse);\n     //                                   ^^^^^^^^^^^^^^  Here.\n }\n ```\n\n @see rb_funcall_passing_block\n\n @internal\n\n @shyouhei  honestly  doesn't understand  why  this  is needed,  given  there\n already was rb_funcall_passing_block()  at the time it  was implemented.  If\n somebody knows its raison d'etre, please improve the document :FIXME:"]
    pub fn rb_yield_block(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Determines if the current method is given a keyword argument.\n\n @retval  false  No keyword argument is given.\n @retval  true   Keyword argument(s) are given.\n @ingroup defmethod"]
    pub fn rb_keyword_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines if the current method is given a block.\n\n @retval  false  No block is given.\n @retval  true   A block is given.\n @ingroup defmethod\n\n @internal\n\n This function should have returned a bool.   But at the time it was designed\n the project was entirely written in K&R C."]
    pub fn rb_block_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Declares that the current method needs a block.\n\n @exception  rb_eLocalJumpError  No block given.\n @ingroup    defmethod"]
    pub fn rb_need_block();
}
extern "C" {
    #[doc = " Old way to iterate a block.\n\n @deprecated     This is an old API.  Use rb_block_call() instead.\n @warning        The passed  function must at  least once call a  ruby method\n                 (to handle interrupts etc.)\n @param[in]      func1  A function that could yield a value.\n @param[in,out]  data1  Passed to `func1`\n @param[in]      proc   A function acts as a block.\n @param[in,out]  data2  Passed to `proc` as the data2 parameter.\n @return         What `func1` returns."]
    pub fn rb_iterate(
        func1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_funcallv(), except it  additionally passes a function  as a\n block.  When the  method yields, `proc` is called with  the yielded value as\n its first  argument, and  `data2` as  the second.   Yielded values  would be\n packed into an array if multiple values are yielded at once.\n\n @param[in,out]  obj    Receiver.\n @param[in]      mid    Method signature.\n @param[in]      argc   Number of arguments.\n @param[in]      argv   Arguments passed to `obj.mid`.\n @param[in]      proc   A function acts as a block.\n @param[in,out]  data2  Passed to `proc` as the data2 parameter.\n @return         What `obj.mid` returns."]
    pub fn rb_block_call(
        obj: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_funcallv_kw(), except it additionally passes a function as a\n block.   It can  also be  seen as  a routine  identical to  rb_block_call(),\n except it handles keyword-ness of `argv[argc-1]`.\n\n @param[in,out]  obj       Receiver.\n @param[in]      mid       Method signature.\n @param[in]      argc      Number of arguments including the keywords.\n @param[in]      argv      Arguments passed to `obj.mid`.\n @param[in]      proc      A function acts as a block.\n @param[in,out]  data2     Passed to `proc` as the data2 parameter.\n @param[in]      kw_splat  Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @return         What `obj.mid` returns."]
    pub fn rb_block_call_kw(
        obj: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_rescue2(),  except it  does not  take a  list of  exception\n classes.  This is a shorthand of:\n\n ```CXX\n rb_rescue2(b_proc, data1, r_proc, data2, rb_eStandardError, (VALUE)0);\n ```\n\n @param[in]      b_proc  A function which potentially raises an exception.\n @param[in,out]  data1   Passed to `b_proc`.\n @param[in]      r_proc  A function which rescues an exception in `b_proc`.\n @param[in,out]  data2   The first argument of `r_proc`.\n @return         The return value of `b_proc`  if no exception occurs, or the\n                 return value of `r_proc` otherwise.\n @see            rb_rescue\n @see            rb_ensure\n @see            rb_protect\n @ingroup        exception"]
    pub fn rb_rescue(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " An equivalent of `rescue` clause.\n\n First  it calls  the function  `b_proc` with  `data1` as  the argument.   If\n nothing is thrown the function happily returns the return value of `b_proc`.\n When `b_proc` raises an exception, and the exception is a kind of one of the\n given  exception classes,  it  then  calls `r_proc`  with  `data2` and  that\n exception.  If the exception does not match any of them, it propagates.\n\n @param[in]      b_proc  A function which potentially raises an exception.\n @param[in,out]  data1   Passed to `b_proc`.\n @param[in]      r_proc  A function which rescues an exception in `b_proc`.\n @param[in,out]  data2   The first argument of `r_proc`.\n @param[in]      ...     1 or  more exception classes.  Must be terminated by\n                         `(VALUE)0`\n @return         The return value of `b_proc`  if no exception occurs, or the\n                 return value of `r_proc` otherwise.\n @see            rb_rescue\n @see            rb_ensure\n @see            rb_protect\n @ingroup        exception"]
    pub fn rb_rescue2(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
        ...
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_rescue2(), except  it takes  `va_list` instead  of variadic\n number  of  arguments.   This  is  exposed to  3rd  parties  because  inline\n functions use it.  Basically you don't have to bother.\n\n @param[in]      b_proc  A function which potentially raises an exception.\n @param[in,out]  data1   Passed to `b_proc`.\n @param[in]      r_proc  A function which rescues an exception in `b_proc`.\n @param[in,out]  data2   The first argument of `r_proc`.\n @param[in]      ap      1 or  more exception classes.  Must be terminated by\n                         `(VALUE)0`\n @return         The return value of `b_proc`  if no exception occurs, or the\n                 return value of `r_proc` otherwise.\n @see            rb_rescue\n @see            rb_ensure\n @see            rb_protect\n @ingroup        exception"]
    pub fn rb_vrescue2(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
        ap: va_list,
    ) -> VALUE;
}
extern "C" {
    #[doc = " An equivalent to `ensure` clause.   Calls the function `b_proc` with `data1`\n as the argument, then calls `e_proc` with `data2` when execution terminated.\n\n @param[in]      b_proc     A function representing begin clause.\n @param[in,out]  data1      Passed to `b_proc`.\n @param[in]      e_proc     A function representing ensure clause.\n @param[in,out]  data2      Passed to `e_proc`.\n @retval         RUBY_Qnil  exception occurred inside of `b_proc`.\n @retval         otherwise  The return value of `b_proc`.\n @see            rb_rescue\n @see            rb_rescue2\n @see            rb_protect\n @ingroup        exception"]
    pub fn rb_ensure(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        e_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Executes the passed block and catches values thrown from inside of it.\n\n In case  the block does  not contain any  throw`, this function  returns the\n value of the last expression evaluated.\n\n ```CXX\n VALUE\n iter(RB_BLOCK_CALL_FUNC_ARGLIST(yielded, callback))\n {\n     return INT2FIX(123);\n }\n\n VALUE\n method(VALUE self)\n {\n     return rb_catch(\"tag\", iter, Qnil); // returns 123\n }\n ```\n\n In case there do exist `throw`, Ruby searches up its execution context for a\n `catch` block.   When a matching catch  is found, the block  stops executing\n and returns that thrown value instead.\n\n ```CXX\n VALUE\n iter(RB_BLOCK_CALL_FUNC_ARGLIST(yielded, callback))\n {\n     rb_throw(\"tag\", 456);\n     return INT2FIX(123);\n }\n\n VALUE\n method(VALUE self)\n {\n     return rb_catch(\"tag\", iter, Qnil); // returns 456\n }\n ```\n\n @param[in]      tag   Arbitrary tag string.\n @param[in]      func  Function pointer that acts as a block.\n @param[in,out]  data  Extra parameter passed to `func`.\n @return         Either caught value for `tag`, or the return value of `func`\n                 if nothing is thrown."]
    pub fn rb_catch(
        tag: *const ::std::os::raw::c_char,
        func: rb_block_call_func_t,
        data: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_catch(), except it catches arbitrary Ruby objects.\n\n @param[in]      tag   Arbitrary tag object.\n @param[in]      func  Function pointer that acts as a block.\n @param[in,out]  data  Extra parameter passed to `func`.\n @return         Either caught value for `tag`, or the return value of `func`\n                 if nothing is thrown."]
    pub fn rb_catch_obj(tag: VALUE, func: rb_block_call_func_t, data: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Transfers control to the end of  the active `catch` block waiting for `tag`.\n Raises  rb_eUncughtThrow if  there is  no `catch`  block for  the tag.   The\n second  parameter supplies  a  return  value for  the  `catch` block,  which\n otherwise defaults to ::RUBY_Qnil.  For examples, see rb_catch().\n\n @param[in]  tag               Tag string.\n @param[in]  val               Value to throw.\n @exception  rb_eUncughtThrow  There is no corresponding `catch` clause.\n @note       It never returns."]
    pub fn rb_throw(tag: *const ::std::os::raw::c_char, val: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical to rb_throw(), except it allows  arbitrary Ruby object to become a\n tag.\n\n @param[in]  tag               Arbitrary object.\n @param[in]  val               Value to throw.\n @exception  rb_eUncughtThrow  There is no corresponding `catch` clause.\n @note       It never returns."]
    pub fn rb_throw_obj(tag: VALUE, val: VALUE) -> !;
}
#[doc = " @private\n\n This is an implementation detail of rbimpl_size_mul_overflow().\n\n @internal\n\n Expecting  this struct  to be  eliminated  by function  inlinings.  This  is\n nothing more than std::variant<std::size_t> if  we could use recent C++, but\n reality is we cannot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbimpl_size_mul_overflow_tag {
    #[doc = "< Whether overflow happened or not."]
    pub left: bool,
    #[doc = "< Multiplication result."]
    pub right: usize,
}
#[test]
fn bindgen_test_layout_rbimpl_size_mul_overflow_tag() {
    const UNINIT: ::std::mem::MaybeUninit<rbimpl_size_mul_overflow_tag> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rbimpl_size_mul_overflow_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rbimpl_size_mul_overflow_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rbimpl_size_mul_overflow_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(rbimpl_size_mul_overflow_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbimpl_size_mul_overflow_tag),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rbimpl_size_mul_overflow_tag),
            "::",
            stringify!(right)
        )
    );
}
extern "C" {
    #[doc = " @private\n\n This is  an implementation  detail of #RB_ALLOCV().   People don't  use this\n directly.\n\n @param[out]  store  Pointer to a variable.\n @param[in]   len    Requested number of bytes to allocate.\n @return      Allocated `len` bytes array.\n @post        `store` holds the corresponding tmp buffer object."]
    pub fn rb_alloc_tmp_buffer(
        store: *mut VALUE,
        len: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @private\n\n This is an  implementation detail of #RB_ALLOCV_N().  People  don't use this\n directly.\n\n @param[out]  store  Pointer to a variable.\n @param[in]   len    Requested number of bytes to allocate.\n @param[in]   count  Number of elements in an array.\n @return      Allocated `len` bytes array.\n @post        `store` holds the corresponding tmp buffer object.\n\n @internal\n\n Although  the  meaning  of  `count` variable  is  clear,  @shyouhei  doesn't\n understand its needs."]
    pub fn rb_alloc_tmp_buffer_with_count(
        store: *mut VALUE,
        len: usize,
        count: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @private\n\n This is an implementation detail of #RB_ALLOCV_END().  People don't use this\n directly.\n\n @param[out]  store  Pointer to a variable.\n @pre         `store` is a NULL, or a pointer to a tmp buffer object.\n @post        `*store` is ::RUBY_Qfalse.\n @post        The object formerly stored in `store` is destroyed."]
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
}
extern "C" {
    #[doc = " @private\n\n This is an  implementation detail of #RB_ALLOCV_N().  People  don't use this\n directly.\n\n @param[in]  x             Arbitrary value.\n @param[in]  y             Arbitrary value.\n @exception  rb_eArgError  `x` * `y` would integer overflow."]
    pub fn ruby_malloc_size_overflow(x: usize, y: usize) -> !;
}
extern "C" {
    #[doc = " Defines a top-level class.\n\n @param[in]  name           Name of the class.\n @param[in]  super          A class from which the new class will derive.\n @exception  rb_eTypeError  The constant name `name` is already taken but the\n                            constant is not a class.\n @exception  rb_eTypeError  The class  is already  defined but the  class can\n                            not  be reopened  because its  superclass is  not\n                            `super`.\n @exception  rb_eArgError   `super` is NULL.\n @return     The created class.\n @post       Top-level constant named `name` refers the returned class.\n @note       If a class named `name` is already defined and its superclass is\n             `super`, the function just returns the defined class.\n @note       The  compaction  GC  does  not move  classes  returned  by  this\n             function.\n\n @internal\n\n There are classes without names, but you  can't pass NULL here.  You have to\n use other ways to create one."]
    pub fn rb_define_class(name: *const ::std::os::raw::c_char, super_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Defines a top-level module.\n\n @param[in]  name           Name of the module.\n @exception  rb_eTypeError  The constant name `name` is already taken but the\n                            constant is not a module.\n @return     The created module.\n @post       Top-level constant named `name` refers the returned module.\n @note       The  compaction  GC  does  not move  classes  returned  by  this\n             function.\n\n @internal\n\n There are modules without names, but you  can't pass NULL here.  You have to\n use other ways to create one."]
    pub fn rb_define_module(name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Defines a class under the namespace of `outer`.\n\n @param[out]  outer          A class which contains the new class.\n @param[in]   name           Name of the new class\n @param[in]   super          A class from which the new class will derive.\n                             0 means ::rb_cObject.\n @exception   rb_eTypeError  The constant  name `name`  is already  taken but\n                             the constant is not a class.\n @exception   rb_eTypeError  The class  is already defined but  the class can\n                             not be  reopened because  its superclass  is not\n                             `super`.\n @exception   rb_eArgError   `super` is NULL.\n @return      The created class.\n @post        `outer::name` refers the returned class.\n @note        If a class  named `name` is already defined  and its superclass\n              is `super`, the function just returns the defined class.\n @note        The  compaction  GC does  not  move  classes returned  by  this\n              function."]
    pub fn rb_define_class_under(
        outer: VALUE,
        name: *const ::std::os::raw::c_char,
        super_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Defines a module under the namespace of `outer`.\n\n @param[out]  outer          A class which contains the new module.\n @param[in]   name           Name of the new module\n @exception   rb_eTypeError  The constant  name `name`  is already  taken but\n                             the constant is not a class.\n @return      The created module.\n @post        `outer::name` refers the returned module.\n @note        The  compaction  GC does  not  move  classes returned  by  this\n              function."]
    pub fn rb_define_module_under(outer: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Includes a module to a class.\n\n @param[out]  klass         Inclusion destination.\n @param[in]   module        Inclusion source.\n @exception   rb_eArgError  Cyclic inclusion.\n\n @internal\n\n :FIXME: @shyouhei suspects this function  lacks assertion that the arguments\n being modules...  Could silently SEGV if non-module was passed?"]
    pub fn rb_include_module(klass: VALUE, module: VALUE);
}
extern "C" {
    #[doc = " Extend the object with the module.\n\n @warning     This    is   the    same    as   `Module#extend_object`,    not\n              `Object#extend`!  These  two methods are very  similar, but not\n              identical.  The difference is the hook.  `Module#extend_object`\n              does not invoke `Module#extended`, while `Object#extend` does.\n @param[out]  obj  Object to extend.\n @param[in]   mod  Module of extension."]
    pub fn rb_extend_object(obj: VALUE, mod_: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_include_module(), except it  \"prepends\" the passed module to\n the klass,  instead of  includes.  This affects  how `super`  resolves.  For\n instance:\n\n ```ruby\n class  Q;                def foo;      \"<q/>\"       end end\n module W;                def foo; \"<w>#{super}</w>\" end end\n class  E < Q; include W; def foo; \"<e>#{super}</e>\" end end\n class  R < Q; prepend W; def foo; \"<r>#{super}</r>\" end end\n\n E.new.foo # => \"<e><w><q/></w></e>\"\n r.new.foo # => \"<W><r><q/></r></w>\"\n ```\n\n @param[out]  klass         Target class to modify.\n @param[in]   module        Module to prepend.\n @exception   rb_eArgError  Cyclic inclusion."]
    pub fn rb_prepend_module(klass: VALUE, module: VALUE);
}
extern "C" {
    #[doc = " This is the implementation detail of #RB_NEWOBJ.\n\n @exception  rb_eNoMemError  No space left.\n @return     An allocated object, not initialised."]
    pub fn rb_newobj() -> VALUE;
}
extern "C" {
    #[doc = " This is the implementation detail of #RB_NEWOBJ_OF.\n\n @param      klass           Object's class.\n @param      flags           Object's flags.\n @exception  rb_eNoMemError  No space left.\n @return     An allocated object, filled with the arguments."]
    pub fn rb_newobj_of(klass: VALUE, flags: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Fills common fields in the object.\n\n @note           Prefer rb_newobj_of() to this function.\n @param[in,out]  obj    A Ruby object to be set up.\n @param[in]      klass  `obj` will belong to this class.\n @param[in]      type   One of ::ruby_value_type.\n @return         The passed object.\n\n @internal\n\n Historically, authors of  Ruby has described the `type` argument  as \"one of\n ::ruby_value_type\".   In   reality  it  accepts   either  ::ruby_value_type,\n ::ruby_fl_type,   or   any   combinations   of  the   two.    For   instance\n `RUBY_T_STRING | RUBY_FL_FREEZE` is a valid  value that this function takes,\n and means this is a frozen string.\n\n 3rd  party extension  libraries rarely  need to  allocate Strings  this way.\n They normally only concern ::RUBY_T_DATA.   This argument is mainly used for\n specifying flags, @shyouhei suspects."]
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, type_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries  the  class  of  an  object.    This  is  not  always  identical  to\n `RBASIC_CLASS(obj)`.   It   searches  for  the  nearest   ancestor  skipping\n singleton classes or included modules.\n\n @param[in]  obj  Object in question.\n @return     The object's class, in a normal sense."]
    pub fn rb_obj_class(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Clones a singleton class.  An object  can have its own singleton class.  OK.\n Then what  happens when a program  clones such object?  The  singleton class\n that is  attached to  the source  object must also  be cloned.   Otherwise a\n singleton object gets shared with two objects, which breaks \"singleton\"-ness\n of such class.\n\n This  is basically  an  implementation detail  of rb_clone_setup().   People\n need not be aware of this working behind-the-scene.\n\n @param[in]  obj  The object that has its own singleton class.\n @return     Cloned singleton class."]
    pub fn rb_singleton_class_clone(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Attaches a singleton class to its corresponding object.\n\n This  is basically  an  implementation detail  of rb_clone_setup().   People\n need not be aware of this working behind-the-scene.\n\n @param[in]   klass  The singleton class.\n @param[out]  obj    The object to attach a class.\n @pre         The passed two objects must  agree with each other that `klass`\n              becomes a singleton class of `obj`.\n @post        `klass` becomes the singleton class of `obj`."]
    pub fn rb_singleton_class_attached(klass: VALUE, obj: VALUE);
}
extern "C" {
    #[doc = " Copies the list of instance variables.  3rd parties need not know, but there\n are several ways  to store an object's instance variables,  depending on its\n internal structure.   This function  makes sense when  either of  the passed\n objects are using so-called \"generic\"  backend storage.  This distinction is\n purely an  implementation detail  of rb_clone_setup().   People need  not be\n aware of this working behind-the-scenes.\n\n @param[out]  clone  The destination object.\n @param[in]   obj    The source object."]
    pub fn rb_copy_generic_ivar(clone: VALUE, obj: VALUE);
}
extern "C" {
    #[doc = " Fills the memory region with a series of ::RUBY_Qnil.\n\n @param[out]  buf  Buffer to squash.\n @param[in]   len  Number of objects of `buf`.\n @post        `buf` is filled with ::RUBY_Qnil."]
    pub fn rb_mem_clear(buf: *mut VALUE, len: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Identical  to  rb_ary_new_from_values(),  except   it  expects  exactly  two\n parameters.\n\n @param[in]  car  Arbitrary ruby object.\n @param[in]  cdr  Arbitrary ruby object.\n @return     An  allocated new  array, of  length 2,  whose contents  are the\n             passed objects."]
    pub fn rb_assoc_new(car: VALUE, cdr: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Try  converting an  object to  its array  representation using  its `to_ary`\n method, if any.  If there is no such thing, returns ::RUBY_Qnil.\n\n @param[in]  obj            Arbitrary ruby object to convert.\n @exception  rb_eTypeError  `obj.to_ary` returned something non-Array.\n @retval     RUBY_Qnil      No conversion from `obj` to array defined.\n @retval     otherwise      Converted array representation of `obj`.\n @see        rb_io_check_io\n @see        rb_check_string_type\n @see        rb_check_hash_type"]
    pub fn rb_check_array_type(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Allocates a new, empty array.\n\n @return  An allocated new array, whose length is 0."]
    pub fn rb_ary_new() -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_ary_new(),  except it additionally specifies  how many rooms\n of  objects it  should allocate.   This way  you can  create an  array whose\n capacity is  bigger than the  length of  it.  If you  can say that  an array\n grows to a  specific amount, this could be effective  than resizing an array\n over and over again and again.\n\n @param[in]  capa  Designed capacity of the generating array.\n @return     An empty array, whose capacity is `capa`."]
    pub fn rb_ary_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Constructs an array from the passed objects.\n\n @param[in]  n    Number of passed objects.\n @param[in]  ...  Arbitrary ruby objects, filled into the returning array.\n @return     An array of size `n`, whose contents are the passed objects."]
    pub fn rb_ary_new_from_args(n: ::std::os::raw::c_long, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_ary_new_from_args(), except how objects are passed.\n\n @param[in]  n     Number of objects of `elts`.\n @param[in]  elts  Arbitrary ruby objects, filled into the returning array.\n @return     An array of size `n`, whose contents are the passed objects."]
    pub fn rb_ary_new_from_values(n: ::std::os::raw::c_long, elts: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Allocates a hidden (no class) empty array.\n\n @param[in]  capa  Designed capacity of the array.\n @return     A hidden, empty array.\n @see        rb_obj_hide()"]
    pub fn rb_ary_hidden_new(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Destroys the given array for no reason.\n\n @warning  DO NOT USE IT.\n @warning  Leave this task to our GC.\n @warning  It was a wrong indea at the first place to let you know about it.\n\n @param[out]  ary  The array to be executed.\n @post        The given array no longer exists.\n @note        Maybe `Array#clear` could be what you want.\n\n @internal\n\n Should have moved this to `internal/array.h`."]
    pub fn rb_ary_free(ary: VALUE);
}
extern "C" {
    #[doc = " Declares that the array is about to  be modified.  This for instance let the\n array have a dedicated backend storage.\n\n @param[out]  ary               Array about to be modified.\n @exception   rb_eFrozenError   `ary` is frozen.\n @post        Upon  successful return  the  passed array  is  eligible to  be\n              modified."]
    pub fn rb_ary_modify(ary: VALUE);
}
extern "C" {
    #[doc = " @alias{rb_obj_freeze}"]
    pub fn rb_ary_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the passed two arrays share the same backend storage.  A use-case\n for  knowing  such  property is  to  take  a  snapshot  of an  array  (using\n e.g. rb_ary_replace()), then  check later if that snapshot  still shares the\n storage with  the original.  Taking  a snapshot is ultra-cheap.   If nothing\n happens the impact shall be minimal.   But if someone modifies the original,\n that entity shall pay the cost  of copy-on-write.  You can detect that using\n this API.\n\n @param[in]  lhs          Comparison LHS.\n @param[in]  rhs          Comparison RHS.\n @retval     RUBY_Qtrue   They share the same backend storage.\n @retval     RUBY_Qfalse  They are distinct.\n @pre        Both arguments must be of ::RUBY_T_ARRAY."]
    pub fn rb_ary_shared_with_p(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries element(s) of  an array.  This is  complicated!  Refer `Array#slice`\n document for the complete description of how it behaves.\n\n @param[in]  argc            Number of objects of `argv`.\n @param[in]  argv            Up to 2 objects.\n @param[in]  ary             Target array.\n @exception  rb_eTypeError   `argv` (or its part) includes non-Integer.\n @exception  rb_eRangeError  rb_cArithSeq is passed, and is OOB.\n @return     An  element  (if  requested),  or   an  array  of  elements  (if\n             requested), or ::RUBY_Qnil (if index OOB).\n\n @internal\n\n ```rbs\n # \"int\" is ::Integer or `#to_int`, defined in builtin.rbs\n\n class ::Array[unchecked out T]\n   def slice\n     : (int i)                 -> T?\n     | (int beg, int len)      -> ::Array[T]?\n     | (Range[int] r)          -> ::Array[T]?\n     | (ArithmeticSequence as) -> ::Array[T]? # This also raises RagneError.\n end\n ```"]
    pub fn rb_ary_aref(argc: ::std::os::raw::c_int, argv: *const VALUE, ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Obtains a part of the passed array.\n\n @param[in]  ary        Target array.\n @param[in]  beg        Subpart index.\n @param[in]  len        Requested length of returning array.\n @retval     RUBY_Qnil  Requested range out of bounds of `ary`.\n @retval     otherwise  An  allocated new  array whose  contents are  `ary`'s\n                        `beg` to `len`.\n @note       Return  array  can  be  shorter than  `len`  when  for  instance\n             `[0, 1, 2, 3]`'s 4th to 1,000,000,000th is requested."]
    pub fn rb_ary_subseq(
        ary: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Destructively stores  the passed value  to the passed array's  passed index.\n It also resizes  the array's backend storage so that  the requested index is\n not out of bounds.\n\n @param[out]  ary              Target array to modify.\n @param[in]   key              Where to store `val`.\n @param[in]   val              What to store at `key`.\n @exception   rb_eFrozenError  `ary` is frozen.\n @exception   rb_eIndexError   `key` is negative.\n @post        `ary`'s `key`th position is occupied with `val`.\n @post        Depending on `key` and previous  length of `ary` this operation\n              can  also create  a series  of \"hole\"  positions inside  of the\n              backend storage.  They are filled with ::RUBY_Qnil."]
    pub fn rb_ary_store(ary: VALUE, key: ::std::os::raw::c_long, val: VALUE);
}
extern "C" {
    #[doc = " Duplicates an array.\n\n @param[in]  ary  Target to duplicate.\n @return     An allocated new array whose contents are identical to `ary`.\n\n @internal\n\n Not sure why this has to be something different from `ary_make_shared_copy`,\n which seems much efficient."]
    pub fn rb_ary_dup(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " I guess there  is no use case  of this function in  extension libraries, but\n this is a routine identical to rb_ary_dup().  This makes the most sense when\n the passed array is formerly hidden by rb_obj_hide().\n\n @param[in]  ary  An array, possibly hidden.\n @return     A duplicated new instance of ::rb_cArray."]
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Force converts an object to an  array.  It first tries its `#to_ary` method.\n Takes the result  if any.  Otherwise creates  an array of size  1 whose sole\n element is the passed object.\n\n @param[in]  obj  Arbitrary ruby object.\n @return     An array representation of `obj`.\n @note       Unlike    rb_str_to_str()     which    is    a     variant    of\n             rb_check_string_type(),  rb_ary_to_ary()  is  not a  variant  of\n             rb_check_array_type()."]
    pub fn rb_ary_to_ary(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts an array into a  human-readable string.  Historically its behaviour\n changed over time.   Currently it is identical to  calling `inspect` method.\n This behaviour is from that of python (!!) circa 2006.\n\n @param[in]  ary  Array to inspect.\n @return     Recursively inspected representation of `ary`.\n @see        `[ruby-dev:29520]`"]
    pub fn rb_ary_to_s(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively appends multiple elements at the end of the array.\n\n @param[out]  ary              Where to push `train`.\n @param[in]   train            Arbitrary ruby objects to push to `ary`.\n @param[in]   len              Number of objects of `train`.\n @exception   rb_eIndexError   `len` too large.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      The passed `ary`.\n @post        `ary` has contents from `train` appended at its end."]
    pub fn rb_ary_cat(ary: VALUE, train: *const VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Special case of rb_ary_cat() that it adds only one element.\n\n @param[out]  ary              Where to push `elem`.\n @param[in]   elem             Arbitrary ruby object to push.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      The passed `ary`.\n @post        `ary` has `elem` appended at its end."]
    pub fn rb_ary_push(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively  deletes an  element  from the  end of  the  passed array  and\n returns what was deleted.\n\n @param[out]  ary              Target array to modify.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      What  was at  the  end of  `ary`, or  ::RUBY_Qnil  if there  is\n              nothing to remove.\n @post        `ary`'s last element, if any, is removed.\n @note        There is no  way to distinguish whether `ary`  was an 1-element\n              array whose content was ::RUBY_Qnil, or was empty."]
    pub fn rb_ary_pop(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively deletes an element from the  beginning of the passed array and\n returns what  was deleted.  It  can also be seen  as a routine  identical to\n rb_ary_pop(), except which side of the array to scrub.\n\n @param[out]  ary              Target array to modify.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      What was at the beginning of  `ary`, or ::RUBY_Qnil if there is\n              nothing to remove.\n @post        `ary`'s first element, if any, is removed.  As the name implies\n              everything else  remaining in `ary` gets  moved towards `ary`'s\n              beginning.\n @note        There is no  way to distinguish whether `ary`  was an 1-element\n              array whose content was ::RUBY_Qnil, or was empty."]
    pub fn rb_ary_shift(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively prepends the passed item at the beginning of the passed array.\n It can  also be seen as  a routine identical to  rb_ary_push(), except which\n side of the array to modify.\n\n @param[out]  ary              Target array to modify.\n @param[in]   elem             Arbitrary ruby object to unshift.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      The passed `ary`.\n @post        `ary` has `elem` prepended at this beginning."]
    pub fn rb_ary_unshift(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries an  element of an array.   When passed offset is  negative it counts\n backwards.\n\n @param[in]  ary  An array to look into.\n @param[in]  off  Offset (can be negative).\n @return     ::RUBY_Qnil when  `off` is  out of  bounds of  `ary`.  Otherwise\n             what is stored at `off`-th position of `ary`.\n @note       `ary`'s `off`-th element can happen to be ::RUBY_Qnil."]
    pub fn rb_ary_entry(ary: VALUE, off: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Iteratively yields each element of the passed array to the implicitly passed\n block if any.  In case there is  no block given, an enumerator that does the\n thing is generated instead.\n\n @param[in]  ary  Array to iterate over.\n @retval     ary  Passed block was evaluated.\n @retval     otherwise  An instance of ::rb_cEnumerator for `Array#each`."]
    pub fn rb_ary_each(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Recursively  stringises the  elements  of the  passed  array, flattens  that\n result, then joins the sequence using the passed separator.\n\n @param[in]  ary                 Target array to convert.\n @param[in]  sep                 Separator.  Either a  string, or ::RUBY_Qnil\n                                 if you want no separator.\n @exception  rb_eArgError        Infinite recursion in `ary`.\n @exception  rb_eTypeError      `sep` is not a string.\n @exception  rb_eEncCompatError  Strings do not agree with their encodings.\n @return     An  instance  of   ::rb_cString  which  concatenates  stringised\n             contents of `ary`, using `sep` as separator."]
    pub fn rb_ary_join(ary: VALUE, sep: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " _Destructively_ reverses the passed array in-place.\n\n @warning     This is `Array#reverse!`, not `Array#reverse`.\n @param[out]  ary              Target array to modify.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      Passed `ary`.\n @post        `ary` is reversed."]
    pub fn rb_ary_reverse(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " _Destructively_ rotates the  passed array in-place to towards  its end.  The\n amount can be negative.  Would rotate to the opposite direction then.\n\n @warning     This is `Array#rotate!`, not `Array#rotate`.\n @param[out]  ary              Target array to modify.\n @param[in]   rot              Amount of rotation.\n @exception   rb_eFrozenError  `ary` is frozen.\n @retval      RUBY_Qnil        Not rotated.\n @retval      ary              Rotated.\n @post        `ary` is rotated."]
    pub fn rb_ary_rotate(ary: VALUE, rot: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Creates a copy  of the passed array, whose elements  are sorted according to\n their `<=>` result.\n\n @param[in]  ary               Array to sort.\n @exception  rb_eArgError      Comparison not defined among elements.\n @exception  rb_eRuntimeError  Infinite recursion in `<=>`.\n @return     A copy of `ary`, sorted.\n @note       As of writing  this function uses `qsort`  as backend algorithm,\n             which means the result is unstable (in terms of sort stability)."]
    pub fn rb_ary_sort(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively sorts the  passed array in-place, according  to each elements'\n `<=>` result.\n\n @param[in]  ary               Target array to modify.\n @exception  rb_eArgError      Comparison not defined among elements.\n @exception  rb_eRuntimeError  Infinite recursion in `<=>`.\n @return     Passed `ary`.\n @post       `ary` is sorted.\n @note       As of writing  this function uses `qsort`  as backend algorithm,\n             which means the result is unstable (in terms of sort stability)."]
    pub fn rb_ary_sort_bang(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively removes elements from the passed array, so that there would be\n no elements  inside that satisfy  `==` relationship with the  passed object.\n Returns the last deleted  element if any.  But in case  there was nothing to\n delete it gets complicated.  It checks  for the implicitly passed block.  If\n there is  a block  the return value  would be what  the block  evaluates to.\n Otherwise it resorts to ::RUBY_Qnil.\n\n @param[out]  ary              Target array to modify.\n @param[in]   elem             Template object to match against each element.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      What  was  deleted,   or  what  was  the   block  returned,  or\n              ::RUBY_Qnil (see above).\n @post        All elements that have `==` relationship with `elem` are purged\n              from `ary`.  Elements shift their  positions so that `ary` gets\n              compact.\n\n @internal\n\n Internally there also is `rb_ary_delete_same`, which compares by identity."]
    pub fn rb_ary_delete(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively removes an element which resides  at the specific index of the\n passed array.  Unlike  rb_ary_stre() the index can be  negative, which means\n the index counts backwards from the array's tail.\n\n @param[out]  ary  Target array to modify.\n @param[in]   pos  Position (can be negative).\n @exception   rb_eFrozenError `ary` is frozen.\n @return      What was deleted, or ::RUBY_Qnil in case of OOB.\n @post        `ary`'s `pos`-th element is deleted if any.\n @note        There is no  way to distinguish whether `pos` is  out of bound,\n              or `pos` did exist but stored ::RUBY_Qnil as an ordinal value."]
    pub fn rb_ary_delete_at(ary: VALUE, pos: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Destructively removes everything form an array.\n\n @param[out]  ary              Target array to modify.\n @exception   rb_eFrozenError  `ary` is frozen.\n @return      The passed `ary`.\n @post        `ary` is an empty array."]
    pub fn rb_ary_clear(ary: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a new array, concatenating the former to the latter.\n\n @param[in]  lhs             Source array #1.\n @param[in]  rhs             Source array #2.\n @exception  rb_eIndexError  Result array too big.\n @return     A new array containing `rhs` concatenated to `lhs`.\n @note       This  operation  doesn't commute.   Don't  get  confused by  the\n             \"plus\"  terminology.   For  historical reasons  there  are  some\n             noncommutative `+`s in Ruby.  This is one of such things.  There\n             has been a long discussion around `+`s in programming languages.\n\n @internal\n\n rb_ary_concat() is not  a destructive version of  rb_ary_plus().  They raise\n different exceptions.  Don't know why though."]
    pub fn rb_ary_plus(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively appends the contents of latter into the end of former.\n\n @param[out]  lhs              Destination array.\n @param[in]   rhs              Source array.\n @exception   rb_eFrozenError  `lhs` is frozen.\n @exception   rb_eIndexError   Result array too big.\n @exception   rb_eTypeError    `rhs` doesn't respond to `#to_ary`.\n @return      The passed `lhs`.\n @post        `lhs` has contents of `rhs` appended to its end."]
    pub fn rb_ary_concat(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Looks up the passed key, assuming the  passed array is an alist.  An \"alist\"\n here  is a  list of  \"association\"s,  much like  that of  Emacs.  Emacs  has\n `assoc` function that behaves exactly the same as this one.\n\n ```ruby\n # This is an example of aliist.\n auto_mode_alist = [\n   [ /\\.[ch]\\z/, :\"c-mode\" ],\n   [ /\\.[ch]pp\\z/, :\"c++-mode\" ],\n   [ /\\.awk\\z/, :\"awk-mode\" ],\n   [ /\\.cs\\z/, :\"csharp-mode\" ],\n   [ /\\.go\\z/, :\"go-mode\" ],\n   [ /\\.java\\z/, :\"java-mode\" ],\n   [ /\\.pas\\z/, :\"pascal-mode\" ],\n   [ /\\.rs\\z/, :\"rust-mode\" ],\n   [ /\\.txt\\z/, :\"text-mode\" ],\n ]\n ```\n\n This function scans the passed array looking for an element, which itself is\n an array,  whose first  element is the  passed key.  If  no such  element is\n found, returns ::RUBY_Qnil.\n\n Although this  function expects the passed  array be an array  of arrays, it\n can happily accept non-array elements; it just ignores such things.\n\n @param[in]  alist      An array of arrays.\n @param[in]  key        Needle.\n @retval     RUBY_Qnil  Nothing was found.\n @retval     otherwise  An element in `alist` whose  first element is in `==`\n                        relationship with `key`."]
    pub fn rb_ary_assoc(alist: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_ary_assoc(),  except it  scans  the passed  array from  the\n opposite direction.\n\n @param[in]  alist      An array of arrays.\n @param[in]  key        Needle.\n @retval     RUBY_Qnil  Nothing was found.\n @retval     otherwise  An element in `alist` whose  first element is in `==`\n                        relationship with `key`."]
    pub fn rb_ary_rassoc(alist: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the passed array has the passed entry.\n\n @param[in]  ary          Target array to scan.\n @param[in]  elem         Target array to find.\n @retval     RUBY_Qfalse  No element  in `ary`  is in `==`  relationship with\n                          `elem`.\n @retval     RUBY_Qtrue   There is at least one  element in `ary` which is in\n                          `==` relationship with `elem`.\n\n @internal\n\n This is  the only function  in the  entire C API  that is named  using third\n person singular  form of  a verb  (except #ISASCII etc.,  which are  not our\n naming).  The counterpart Ruby API of this function is `Array#include?`."]
    pub fn rb_ary_includes(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Recursively compares each elements of the two arrays one-by-one using `<=>`.\n\n @param[in]  lhs        Comparison LHS.\n @param[in]  rhs        Comparison RHS.\n @retval     RUBY_Qnil  `lhs` and `rhs` are not comparable.\n @retval     -1         `lhs` is less than `rhs`.\n @retval      0         They are equal.\n @retval      1         `rhs` is less then `lhs`."]
    pub fn rb_ary_cmp(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Replaces the contents of the former object with the contents of the latter.\n\n @param[out]  copy               Destination object.\n @param[in]   orig               Source object.\n @exception   rb_eTypeError     `orig` has no implicit conversion to Array.\n @exception   rb_eFrozenError   `copy` is frozen.\n @return      The passed `copy`.\n @post        `copy`'s  former  components are  abandoned.   It  now has  the\n              identical length and contents to `orig`."]
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This _was_  a generalisation  of `Array#values_at`,  `Struct#values_at`, and\n `MatchData#values_at`.  It begun its life  as a refactoring effort.  However\n as Ruby  evolves over  time, as  of writing  none of  aforementioned methods\n share their implementations at all.   This function is not deprecated; still\n works as it has been.  But it is now kind of like a rudimentum.\n\n This  function  takes an  object,  which  is a  receiver,  and  a series  of\n \"indices\",  which are  either integers,  or ranges  of integers.   Calls the\n passed callback  for each of those  indices, along with the  receiver.  This\n callback is  expected to do something  like rb_ary_aref(), rb_struct_aref(),\n etc.   In  case of  a  range  index  rb_range_beg_len() expands  the  range.\n Finally  return values  of  the  callback are  gathered  as  an array,  then\n returned.\n\n @param[in]  obj   Arbitrary ruby object.\n @param[in]  olen  \"Length\" of `obj`.\n @param[in]  argc  Number of objects of `argv`.\n @param[in]  argv  List of \"indices\", described above.\n @param[in]  func  Callback function.\n @return     A new instance of ::rb_cArray gathering `func`outputs.\n\n @internal\n\n `Array#values_at` no  longer uses this  function.  There is no  reason apart\n from historical ones to list this function here."]
    pub fn rb_get_values_at(
        obj: VALUE,
        olen: ::std::os::raw::c_long,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: VALUE, oidx: ::std::os::raw::c_long) -> VALUE,
        >,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Expands or shrinks the passed array to the passed length.\n\n @param[out]  ary              An array to modify.\n @param[in]   len              Desired length of `ary`.\n @exception   rb_eFrozenError  `ary`  is frozen.\n @exception   rb_eIndexError   `len` too long.\n @return      The passed `ary`.\n @post        `ary`'s length is `len`.\n @post        Depending on `len` and previous  length of `ary` this operation\n              can  also create  a series  of \"hole\"  positions inside  of the\n              backend storage.  They are filled with ::RUBY_Qnil.\n\n @internal\n\n `len` is signed.  Intentional or...?"]
    pub fn rb_ary_resize(ary: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Creates an instance of the passed exception class.\n\n @param[in]  etype           A subclass of ::rb_eException.\n @param[in]  ptr             Buffer contains error message.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eTypeError  `etype` is not a class.\n @exception  rb_eArgError   `len` is negative.\n @return     An instance of `etype`.\n @pre        At  least  `len` bytes  of  continuous  memory region  shall  be\n             accessible via `ptr`.\n\n @internal\n\n This function works for non-exception classes  as well, as long as they take\n one string argument."]
    pub fn rb_exc_new(
        etype: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_exc_new(), except it assumes the passed pointer is a pointer\n to a C string.\n\n @param[in]  etype           A subclass of ::rb_eException.\n @param[in]  str             A C string (becomes an error message).\n @exception  rb_eTypeError  `etype` is not a class.\n @return     An instance of `etype`."]
    pub fn rb_exc_new_cstr(etype: VALUE, str_: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_exc_new_cstr(),  except it takes a Ruby's  string instead of\n C's.\n\n @param[in]  etype           A subclass of ::rb_eException.\n @param[in]  str             An instance of ::rb_cString.\n @exception  rb_eTypeError  `etype` is not a class.\n @return     An instance of `etype`."]
    pub fn rb_exc_new_str(etype: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Raises an instance of ::rb_eLoadError.\n\n @param[in]  fmt  Format specifier string compatible with rb_sprintf().\n @exception  rb_eLoadError  Always raises this.\n @note       It never returns.\n\n @internal\n\n Who needs this?  Except ruby itself?"]
    pub fn rb_loaderror(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Identical  to rb_loaderror(),  except it  additionally takes  which file  is\n unable to  load.  The path can  be obtained later using  `LoadError#path` of\n the raising exception.\n\n @param[in]  path  What failed.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf().\n @exception  rb_eLoadError  Always raises this.\n @note       It never returns."]
    pub fn rb_loaderror_with_path(path: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Raises an instance of ::rb_eNameError.  The name can be obtained later using\n `NameError#name` of the raising exception.\n\n @param[in]  name  What failed.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf().\n @exception  rb_eNameError  Always raises this.\n @note       It never returns."]
    pub fn rb_name_error(name: ID, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Identical to rb_name_error(), except it takes a ::VALUE instead of ::ID.\n\n @param[in]  name  What failed.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf().\n @exception  rb_eNameError  Always raises this.\n @note       It never returns."]
    pub fn rb_name_error_str(name: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Raises an instance  of ::rb_eFrozenError.  The object can  be obtained later\n using `FrozenError#receiver` of the raising exception.\n\n @param[in]  recv  What is frozen.\n @param[in]  fmt   Format specifier string compatible with rb_sprintf().\n @exception  rb_eFrozenError  Always raises this.\n @note       It never returns.\n\n @internal\n\n Note however,  that it  is often  not possible to  inspect a  frozen object,\n because the inspection itself could be forbidden by the frozen-ness."]
    pub fn rb_frozen_error_raise(recv: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[doc = " Honestly  I  don't  understand  the  name, but  it  raises  an  instance  of\n ::rb_eArgError.\n\n @param[in]  str           A message.\n @param[in]  type          Another message.\n @exception  rb_eArgError  Always raises this.\n @note       It never returns."]
    pub fn rb_invalid_str(
        str_: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " Identical  to rb_frozen_error_raise(),  except its  raising exception  has a\n message like \"can't modify frozen /what/\".\n\n @param[in]  what             What was frozen.\n @exception  rb_eFrozenError  Always raises this.\n @note       It never returns."]
    pub fn rb_error_frozen(what: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[doc = " Identical  to  rb_error_frozen(),  except  it takes  arbitrary  Ruby  object\n instead of C's string.\n\n @param[in]  what             What was frozen.\n @exception  rb_eFrozenError  Always raises this.\n @note       It never returns."]
    pub fn rb_error_frozen_object(what: VALUE) -> !;
}
extern "C" {
    #[doc = " Queries  if the  passed  object is  frozen.\n\n @param[in]  obj  Target object to test frozen-ness.\n @exception  rb_eFrozenError  It is frozen.\n @post       Upon successful return it is guaranteed _not_ frozen."]
    pub fn rb_check_frozen(obj: VALUE);
}
extern "C" {
    #[doc = " Ensures that the passed object  can be `initialize_copy` relationship.  When\n you implement your own one you would better call this at the right beginning\n of your implementation.\n\n @param[in]  obj              Destination object.\n @param[in]  orig             Source object.\n @exception  rb_eFrozenError  `obj` is frozen.\n @post       Upon successful return obj is guaranteed safe to copy orig."]
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
}
extern "C" {
    #[doc = " @private\n\n This  is an  implementation detail  of  rb_scan_args().  You  don't have  to\n bother.\n\n @pre        `argc` is out of range of `min`..`max`, both inclusive.\n @param[in]  argc          Arbitrary integer.\n @param[in]  min           Minimum allowed `argc`.\n @param[in]  max           Maximum allowed `argc`.\n @exception  rb_eArgError  Always."]
    pub fn rb_error_arity(
        argc: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[doc = " Identical to rb_st_foreach(), except it  raises exceptions when the callback\n function tampers the table during iterating over it.\n\n @param[in]  st                Table to iterate over.\n @param[in]  func              Callback function to apply.\n @param[in]  arg               Passed as-is to `func`.\n @exception  rb_eRuntimeError  `st` was tampered during iterating.\n\n @internal\n\n This is declared here because exceptions are Ruby level concept.\n\n This is in fact a very thin wrapper of rb_st_foreach_check()."]
    pub fn rb_st_foreach_safe(st: *mut st_table, func: st_foreach_callback_func, arg: st_data_t);
}
extern "C" {
    #[doc = " Try  converting an  object to  its hash  representation using  its `to_hash`\n method, if any.  If there is no such thing, returns ::RUBY_Qnil.\n\n @param[in]  obj            Arbitrary ruby object to convert.\n @exception  rb_eTypeError  `obj.to_hash` returned something non-Hash.\n @retval     RUBY_Qnil      No conversion from `obj` to hash defined.\n @retval     otherwise      Converted hash representation of `obj`.\n @see        rb_io_check_io\n @see        rb_check_array_type\n @see        rb_check_string_type\n\n @internal\n\n There   is  no   rb_hash_to_hash()   that   analogous  to   rb_str_to_str().\n Intentional or ...?"]
    pub fn rb_check_hash_type(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Iterates   over  a   hash.   This   basically   does  the   same  thing   as\n rb_st_foreach().  But because the passed hash is a Ruby object, its keys and\n values are both Ruby objects.\n\n @param[in]  hash              An instance of ::rb_cHash to iterate over.\n @param[in]  func              Callback function to yield.\n @param[in]  arg               Passed as-is to `func`.\n @exception  rb_eRuntimeError  `hash` was tampered during iterating."]
    pub fn rb_hash_foreach(
        hash: VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(key: VALUE, val: VALUE, arg: VALUE) -> ::std::os::raw::c_int,
        >,
        arg: VALUE,
    );
}
extern "C" {
    #[doc = " Calculates a message  authentication code of the passed  object.  The return\n value is  a very small  integer used as  an index of a  key of a  table.  In\n order  to calculate  the value  this function  calls `#hash`  method of  the\n passed  object.  Ruby  provides you  a default  implementation.  But  if you\n implement  your class  in C,  that  default implementation  cannot know  the\n underlying data structure.  You must implement your own `#hash` method then,\n which  must return  an integer  of  uniform distribution  in a  sufficiently\n instant manner.\n\n @param[in]  obj            Arbitrary Ruby object.\n @exception  rb_eTypeError  `obj.hash` returned something non-Integer.\n @return     A small integer.\n @note       `#hash` can return very big integers, but they get truncated."]
    pub fn rb_hash(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a new, empty hash object.\n\n @return  An allocated new instance of ::rb_cHash."]
    pub fn rb_hash_new() -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_hash_new(), except it additionally specifies how many keys\n it is expected to contain. This way you can create a hash that is large enough\n for your need. For large hashes it means it won't need to be reallocated and\n rehashed as much, improving performance.\n\n @param[in]  capa  Designed capacity of the hash.\n @return     An empty Hash, whose capacity is `capa`."]
    pub fn rb_hash_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Duplicates a hash.\n\n @param[in]  hash  An instance of ::rb_cHash.\n @return     An  allocated new  instance  of ::rb_cHash,  whose contents  are\n             a verbatim copy of from `hash`."]
    pub fn rb_hash_dup(hash: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_obj_freeze}"]
    pub fn rb_hash_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the given key  in the given hash table.  If there is  the key in the\n hash, returns the  value associated with the key.  Otherwise  it returns the\n \"default\" value (defined per hash table).\n\n @param[in]  hash  Hash table to look into.\n @param[in]  key   Hash key to look for.\n @return     Either the value associated with the  key, or the default one if\n             absent."]
    pub fn rb_hash_aref(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_hash_aref(),  except  it always  returns  ::RUBY_Qnil  for\n misshits.\n\n @param[in]  hash  Hash table to look into.\n @param[in]  key   Hash key to look for.\n @return     Either  the value  associated with  the key,  or ::RUBY_Qnil  if\n             absent.\n @note       A hash can  store ::RUBY_Qnil as an ordinary  value.  You cannot\n             distinguish whether the  key is missing, or  just its associated\n             value happens to be ::RUBY_Qnil, as far as you use this API."]
    pub fn rb_hash_lookup(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_hash_lookup(),  except you  can specify  what to  return on\n misshits.  This is much like 2-arguments version of `Hash#fetch`.\n\n ```CXX\n VALUE hash;\n VALUE key;\n VALUE tmp = rb_obj_alloc(rb_cObject);\n VALUE val = rb_hash_lookup2(hash, key, tmp);\n if (val == tmp) {\n     printf(\"misshit\");\n }\n else {\n     printf(\"hit\");\n }\n ```\n\n @param[in]  hash       Hash table to look into.\n @param[in]  key        Hash key to look for.\n @param[in]  def        Default value.\n @retval     def        `hash` does not have `key`.\n @retval     otherwise  The value associated with `key`."]
    pub fn rb_hash_lookup2(hash: VALUE, key: VALUE, def: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_hash_lookup(),  except  it yields  the (implicitly)  passed\n block instead of returning ::RUBY_Qnil.\n\n @param[in]  hash          Hash table to look into.\n @param[in]  key           Hash key to look for.\n @exception  rb_eKeyError  No block given.\n @return     Either  the value  associated with  the key,  or what  the block\n             evaluates to if absent."]
    pub fn rb_hash_fetch(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Inserts or replaces (\"upsert\"s) the objects into the given hash table.  This\n basically associates the  given value with the given key.   On duplicate key\n this function updates its associated value with the given one.  Otherwise it\n inserts the association at the end of the table.\n\n @param[out]  hash             Target hash table to modify.\n @param[in]   key              Arbitrary Ruby object.\n @param[in]   val              A value to be associated with `key`.\n @exception   rb_eFrozenError  `hash` is frozen.\n @return      The passed `val`\n @post        `val` is associated with `key` in `hash`."]
    pub fn rb_hash_aset(hash: VALUE, key: VALUE, val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Swipes everything out of the passed hash table.\n\n @param[out]  hash             Target to clear.\n @exception   rb_eFrozenError  `hash`is frozen.\n @return      The passed `hash`\n @post        `hash` has no contents."]
    pub fn rb_hash_clear(hash: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Deletes each entry for which the block  returns a truthy value.  If there is\n no block given, it returns an enumerator that does the thing.\n\n @param[out]  hash             Target hash to modify.\n @exception   rb_eFrozenError  `hash` is frozen.\n @retval      hash             The hash is modified.\n @retval      otherwise        An instance of ::rb_cEnumerator that does it."]
    pub fn rb_hash_delete_if(hash: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Deletes the passed key from the passed hash table, if any.\n\n @param[out]  hash       Target hash to modify.\n @param[in]   key        Key to delete.\n @retval      RUBY_Qnil  `hash` has no such key as `key`.\n @retval      otherwise  What was associated with `key`.\n @post        `hash` has no such key as `key`."]
    pub fn rb_hash_delete(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Inserts  a list  of  key-value pairs  into  a  hash table  at  once.  It  is\n semantically  identical to  repeatedly  calling rb_hash_aset(),  but can  be\n faster than that.\n\n @param[in]   argc  Length of `argv`, must be even.\n @param[in]   argv  A list of key, value, key, value, ...\n @param[out]  hash  Target hash table to modify.\n @post        `hash` has contents from `argv`.\n @note        `argv` is allowed to be NULL as long as `argc` is zero.\n\n @internal\n\n What happens for  duplicated keys?  Well it silently discards  older ones to\n accept the newest (rightmost) one.  This behaviour also mimics repeated call\n of rb_hash_aset()."]
    pub fn rb_hash_bulk_insert(argc: ::std::os::raw::c_long, argv: *const VALUE, hash: VALUE);
}
#[doc = " Type of callback functions to pass to rb_hash_update_by().\n\n @param[in]  newkey  A key of the table.\n @param[in]  oldkey  Value associated with `key` in hash1.\n @param[in]  value   Value associated with `key` in hash2.\n @return     Either one of the passed values to take."]
pub type rb_hash_update_func = ::std::option::Option<
    unsafe extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE,
>;
extern "C" {
    #[doc = " Destructively merges two hash tables into one.  It resolves key conflicts by\n calling the passed function and take its return value.\n\n @param[out]  hash1             Target hash to be modified.\n @param[in]   hash2             A hash to merge into `hash1`.\n @param[in]   func              Conflict reconciler.\n @exception   rb_eFrozenError   `hash1` is frozen.\n @exception   rb_eRuntimeError  `hash2` is updated instead.\n @return      The passed `hash1`.\n @post        Contents of `hash2` is merged into `hash1`.\n @note        You can  pass zero to  `func`.  This means values  from `hash2`\n              are always taken."]
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE, func: rb_hash_update_func) -> VALUE;
}
extern "C" {
    #[doc = " This function is mysterious.  What it does is not immediately obvious.  Also\n what it does seems platform dependent.\n\n @param[in]  path       A local path.\n @retval     0          The \"check\" succeeded.\n @retval     otherwise  The \"check\" failed."]
    pub fn rb_path_check(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destructively removes every environment variables of the running process.\n\n @return  The `ENV` object.\n @post    The process has no environment variables."]
    pub fn rb_env_clear() -> VALUE;
}
extern "C" {
    #[doc = " Identical to  #RHASH_SIZE(), except  it returns the  size in  Ruby's integer\n instead of C's.\n\n @param[in]  hash  A hash object.\n @return     The size of the hash."]
    pub fn rb_hash_size(hash: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Constructs a  Proc object  from implicitly passed  components.  When  a ruby\n method is  called with a block,  that block is not  explicitly passed around\n using C level function parameters.   This function gathers all the necessary\n info to turn them into a Ruby level instance of ::rb_cProc.\n\n @exception  rb_eArgError  There is no passed block.\n @return     An instance of ::rb_cProc."]
    pub fn rb_block_proc() -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_proc_new(), except it returns a lambda.\n\n @exception  rb_eArgError  There is no passed block.\n @return     An instance of ::rb_cProc."]
    pub fn rb_block_lambda() -> VALUE;
}
extern "C" {
    #[doc = " This is an rb_iterate() + rb_block_proc() combo.\n\n ```CXX\n VALUE\n my_own_iterator(RB_BLOCK_CALL_FUNC_ARGLIST(y, c))\n {\n     const auto plus = rb_intern(\"+\");\n     return rb_funcall(c, plus, 1, y);\n }\n\n VALUE\n my_own_method(VALUE self)\n {\n     return rb_proc_new(my_own_iterator, self);\n }\n ```\n\n @param[in]  func          A backend function of a proc.\n @param[in]  callback_arg  Passed to `func`'s callback_arg.\n @return     A C-backended proc object.\n"]
    pub fn rb_proc_new(func: rb_block_call_func_t, callback_arg: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given object is a proc.\n\n @note       This is about the object's data structure, not its class etc.\n @param[in]  recv         Object in question.\n @retval     RUBY_Qtrue   It is a proc.\n @retval     RUBY_Qfalse  Otherwise."]
    pub fn rb_obj_is_proc(recv: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Evaluates the passed proc with the passed arguments.\n\n @param[in]  recv           The proc to call.\n @param[in]  args           An instance of ::RArray which is the arguments.\n @exception  rb_eException  Any exceptions happen inside.\n @return     What the proc evaluates to."]
    pub fn rb_proc_call(recv: VALUE, args: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_proc_call(),  except you can specify how to  handle the last\n element of the given array.\n\n @param[in]  recv             The proc to call.\n @param[in]  args             An instance of ::RArray which is the arguments.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `args`' last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `args`' last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eException    Any exceptions happen inside.\n @return     What the proc evaluates to."]
    pub fn rb_proc_call_kw(recv: VALUE, args: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_proc_call(),  except you can additionally  pass another proc\n object, as a block.  Nowadays procs can take blocks:\n\n ```ruby\n l = -> (positional, optional=nil, *rest, kwarg:, **kwrest, &block) {\n   #                   ... how can we pass this `&block`?   ^^^^^^\n }\n ```\n\n And this function is to pass one to such procs.\n\n @param[in]  recv           The proc to call.\n @param[in]  argc           Number of arguments.\n @param[in]  argv           Arbitrary number of proc arguments.\n @param[in]  proc           Proc as a passed block.\n @exception  rb_eException  Any exceptions happen inside.\n @return     What the proc evaluates to."]
    pub fn rb_proc_call_with_block(
        recv: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_proc_call_with_block(), except you can specify how to handle\n the last  element of  the given  array.  It can  also be  seen as  a routine\n identical  to rb_proc_call_kw(),  except you  can additionally  pass another\n proc object as a block.\n\n @param[in]  recv             The proc to call.\n @param[in]  argc             Number of arguments.\n @param[in]  argv             Arbitrary number of proc arguments.\n @param[in]  proc             Proc as a passed block.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `args`' last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `args`' last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eException    Any exceptions happen inside.\n @return     What the proc evaluates to."]
    pub fn rb_proc_call_with_block_kw(
        recv: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Queries the number  of mandatory arguments of the given  Proc.  If its block\n is declared  to take no  arguments, returns `0`.  If  the block is  known to\n take  exactly  `n`  arguments,  returns  `n`.  If  the  block  has  optional\n arguments, returns `-n-1`,  where `n` is the number  of mandatory arguments,\n with the exception  for blocks that are  not lambdas and have  only a finite\n number of  optional arguments;  in this latter  case, returns  `n`.  Keyword\n arguments will be considered as  a single additional argument, that argument\n being mandatory if any keyword argument is mandatory.\n\n @param[in]  recv  Target Proc object.\n @retval     0     It takes no arguments.\n @retval     >0    It takes exactly this number of arguments.\n @retval     <0    It takes optional arguments."]
    pub fn rb_proc_arity(recv: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries if the given object is a lambda.  Instances of ::rb_cProc are either\n lambda  or  proc.   They  differ  in  several  points.   This  function  can\n distinguish them without actually evaluating their contents.\n\n @param[in]  recv         Target proc object.\n @retval     RUBY_Qtrue   It is a lambda.\n @retval     RUBY_Qfalse  Otherwise."]
    pub fn rb_proc_lambda_p(recv: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Snapshots the  current execution  context and  turn it  into an  instance of\n ::rb_cBinding.\n\n @return  An instance of ::rb_cBinding."]
    pub fn rb_binding_new() -> VALUE;
}
extern "C" {
    #[doc = " Creates a method object.  A method object is a proc-like object that you can\n \"call\".  Note  that a  method object  snapshots the method  at the  time the\n object is created:\n\n ```ruby\n class Foo\n   def foo\n     return 1\n   end\n end\n\n obj = Foo.new.method(:foo)\n\n class Foo\n   def foo\n     return 2\n   end\n end\n\n obj.call # => 1, not 2.\n ```\n\n @param[in]  recv               Receiver of the method.\n @param[in]  mid                Method name, in either String or Symbol.\n @exception  rb_eNoMethodError  No such method.\n @return     An instance of ::rb_cMethod."]
    pub fn rb_obj_method(recv: VALUE, mid: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given object is a method.\n\n @note       This is about the object's data structure, not its class etc.\n @param[in]  recv         Object in question.\n @retval     RUBY_Qtrue   It is a method.\n @retval     RUBY_Qfalse  Otherwise."]
    pub fn rb_obj_is_method(recv: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Evaluates the passed method with the passed arguments.\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arbitrary number of method arguments.\n @param[in]  recv           The method object to call.\n @exception  rb_eTypeError  `recv` is not a method.\n @exception  rb_eException  Any exceptions happen inside.\n @return     What the method returns."]
    pub fn rb_method_call(argc: ::std::os::raw::c_int, argv: *const VALUE, recv: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_method_call(), except you can specify how to handle the last\n element of the given array.\n\n @param[in]  argc             Number of objects of `argv`.\n @param[in]  argv             Arbitrary number of method arguments.\n @param[in]  recv             The method object to call.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `args`' last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `args`' last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eTypeError    `recv` is not a method.\n @exception  rb_eException    Any exceptions happen inside.\n @return     What the method returns."]
    pub fn rb_method_call_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_proc_call(), except you can  additionally pass a proc  as a\n block.\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arbitrary number of method arguments.\n @param[in]  recv           The method object to call.\n @param[in]  proc           Proc as a passed block.\n @exception  rb_eTypeError  `recv` is not a method.\n @exception  rb_eException  Any exceptions happen inside.\n @return     What the method returns."]
    pub fn rb_method_call_with_block(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        proc_: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_method_call_with_block(),  except  you can  specify how  to\n handle  the last  element of  the given  array.  It  can also  be seen  as a\n routine identical  to rb_method_call_kw(), except you  can additionally pass\n another proc object as a block.\n\n @param[in]  argc             Number of objects of `argv`.\n @param[in]  argv             Arbitrary number of method arguments.\n @param[in]  recv             The method object to call.\n @param[in]  proc             Proc as a passed block.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `args`' last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `args`' last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eTypeError    `recv` is not a method.\n @exception  rb_eException    Any exceptions happen inside.\n @return     What the method returns."]
    pub fn rb_method_call_with_block_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        proc_: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Queries the number of mandatory arguments of the method defined in the given\n module.  If it is  declared to take no arguments, returns  `0`.  If it takes\n exactly `n` arguments,  returns `n`.  If it has  optional arguments, returns\n `-n-1`, where `n`  is the number of mandatory  arguments.  Keyword arguments\n will  be considered  as a  single additional  argument, that  argument being\n mandatory if any keyword argument is mandatory.\n\n @param[in]  mod   Namespace to search a method for.\n @param[in]  mid   Method id.\n @retval     0     It takes no arguments.\n @retval     >0    It takes exactly this number of arguments.\n @retval     <0    It takes optional arguments."]
    pub fn rb_mod_method_arity(mod_: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_mod_method_arity(), except it searches for singleton methods\n rather than instance methods.\n\n @param[in]  obj   Object to search for a singleton method.\n @param[in]  mid   Method id.\n @retval     0     It takes no arguments.\n @retval     >0    It takes exactly this number of arguments.\n @retval     <0    It takes optional arguments."]
    pub fn rb_obj_method_arity(obj: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Protects a  function call from  potential global escapes from  the function.\n Such global escapes include exceptions, `throw`, `break`, for example.\n\n It first calls the function func with  `args` as the argument.  If no global\n escape occurred during  the function, it returns the result  and `*state` is\n zero.  Otherwise, it  returns ::RUBY_Qnil and sets `*state`  to nonzero.  If\n `state` is `NULL`, it is not set in both cases.\n\n @param[in]   func   A function that potentially escapes globally.\n @param[in]   args   Passed as-is to `func`.\n @param[out]  state  State of execution.\n @return      What  `func` returns,  or an  undefined value  when it  did not\n              return.\n @post        `*state` is set to zero if succeeded.  Nonzero otherwise.\n @warning     You have to clear the error info with `rb_set_errinfo(Qnil)` if\n              you decide to ignore the caught exception.\n @see         rb_eval_string_protect()\n @see         rb_load_protect()\n\n @internal\n\n The \"undefined value\"  described above is in fact ::RUBY_Qnil  for now.  But\n @shyouhei doesn't think that we would never change that.\n\n Though   not  a   part  of   our  public   API,  `state`   is  in   fact  an\n enum ruby_tag_type.  You can  see the potential \"nonzero\"  values by looking\n at vm_core.h."]
    pub fn rb_protect(
        func: ::std::option::Option<unsafe extern "C" fn(args: VALUE) -> VALUE>,
        args: VALUE,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Retrieves argument from argc and  argv to given ::VALUE references according\n to the format string.  The format can be described in ABNF as follows:\n\n ```\n scan-arg-spec  := param-arg-spec [keyword-arg-spec] [block-arg-spec]\n\n param-arg-spec        := pre-arg-spec [post-arg-spec] / post-arg-spec /\n                          pre-opt-post-arg-spec\n pre-arg-spec          := num-of-leading-mandatory-args\n                          [num-of-optional-args]\n post-arg-spec         := sym-for-variable-length-args\n                          [num-of-trailing-mandatory-args]\n pre-opt-post-arg-spec := num-of-leading-mandatory-args num-of-optional-args\n                          num-of-trailing-mandatory-args\n keyword-arg-spec      := sym-for-keyword-arg\n block-arg-spec        := sym-for-block-arg\n\n num-of-leading-mandatory-args  := DIGIT ; The number of leading mandatory\n                                         ; arguments\n num-of-optional-args           := DIGIT ; The number of optional arguments\n sym-for-variable-length-args   := \"*\"   ; Indicates that variable length\n                                         ;  arguments are captured as a ruby\n                                         ; array\n num-of-trailing-mandatory-args := DIGIT ; The number of trailing mandatory\n                                         ; arguments\n sym-for-keyword-arg            := \":\"   ; Indicates that keyword argument\n                                         ; captured as a hash.\n                                         ; If keyword arguments are not\n                                         ; provided, returns nil.\n sym-for-block-arg              := \"&\"   ; Indicates that an iterator block\n                                         ; should be captured if given\n ```\n\n For example, \"12\" means that the  method requires at least one argument, and\n at  most receives  three (1+2)  arguments.  So,  the format  string must  be\n followed by three variable references, which  are to be assigned to captured\n arguments.  For omitted arguments, variables are set to ::RUBY_Qnil.  `NULL`\n can be put  in place of a variable reference,  which means the corresponding\n captured argument(s) should be just dropped.\n\n The number of  given arguments, excluding an option hash  or iterator block,\n is returned.\n\n @param[in]   argc          Length of `argv`.\n @param[in]   argv          Pointer to the arguments to parse.\n @param[in]   fmt           Format, in the language described above.\n @param[out]  ...           Variables to fill in.\n @exception   rb_eFatal     Malformed `fmt`.\n @exception   rb_eArgError  Arity mismatch.\n @return      Actually parsed number of given arguments.\n @post        Each  values  passed to  `argv`  is  filled into  the  variadic\n              arguments, according to the format."]
    pub fn rb_scan_args(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_scan_args(), except it also accepts `kw_splat`.\n\n @param[in]   kw_splat      How to understand the keyword arguments.\n   - RB_SCAN_ARGS_PASS_CALLED_KEYWORDS: Same behaviour as rb_scan_args().\n   - RB_SCAN_ARGS_KEYWORDS:             The final argument is a kwarg.\n   - RB_SCAN_ARGS_LAST_HASH_KEYWORDS:   The final argument is a kwarg, iff it\n                                        is a hash.\n @param[in]   argc          Length of `argv`.\n @param[in]   argv          Pointer to the arguments to parse.\n @param[in]   fmt           Format, in the language described above.\n @param[out]  ...           Variables to fill in.\n @exception   rb_eFatal     Malformed `fmt`.\n @exception   rb_eArgError  Arity mismatch.\n @return      Actually parsed number of given arguments.\n @post        Each  values  passed to  `argv`  is  filled into  the  variadic\n              arguments, according to the format."]
    pub fn rb_scan_args_kw(
        kw_splat: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @private\n\n This is  an implementation  detail of rb_scan_args().   People don't  use it\n directly."]
    pub fn rb_scan_args_bad_format(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @private\n\n This is  an implementation  detail of rb_scan_args().   People don't  use it\n directly."]
    pub fn rb_scan_args_length_mismatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Converts an instance of ::rb_cSymbol into an ::ID.\n\n @param[in]  obj            An instance of ::rb_cSymbol.\n @exception  rb_eTypeError  `obj` is not an instance of ::rb_cSymbol.\n @return     An ::ID of the identical symbol."]
    pub fn rb_sym2id(obj: VALUE) -> ID;
}
extern "C" {
    #[doc = " Allocates an instance of ::rb_cSymbol that has the given id.\n\n @param[in]  id           An id.\n @retval     RUBY_Qfalse  No such id ever existed in the history.\n @retval     Otherwise    An allocated ::rb_cSymbol instance."]
    pub fn rb_id2sym(id: ID) -> VALUE;
}
extern "C" {
    #[doc = " Finds or creates a symbol of the given name.\n\n @param[in]  name              The name of the id.\n @exception  rb_eRuntimeError  Too many symbols.\n @return     A (possibly new) id whose value is the given name.\n @note       These days  Ruby internally has  two kinds of symbols  (static /\n             dynamic).  Symbols  created using  this function would  become a\n             static one; i.e. would never be  garbage collected.  It is up to\n             you to avoid memory leaks.  Think twice before using it."]
    pub fn rb_intern(name: *const ::std::os::raw::c_char) -> ID;
}
extern "C" {
    #[doc = " Identical to  rb_intern(), except  it additionally takes  the length  of the\n string.  This way you can have a symbol that contains NUL characters.\n\n @param[in]  name              The name of the id.\n @param[in]  len               Length of `name`.\n @exception  rb_eRuntimeError  Too many symbols.\n @return     A (possibly new) id whose value is the given name.\n @note       These   days  Ruby   internally   has  two   kinds  of   symbols\n             (static/dynamic).   Symbols created  using  this function  would\n             become static ones;  i.e. would never be  garbage collected.  It\n             is up  to you to avoid  memory leaks.  Think twice  before using\n             it."]
    pub fn rb_intern2(name: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long) -> ID;
}
extern "C" {
    #[doc = " Identical to  rb_intern(), except  it takes an instance of ::rb_cString.\n\n @param[in]  str               The name of the id.\n @pre        `str` must either be an instance of ::rb_cSymbol, or an instance\n             of ::rb_cString, or responds to `#to_str` method.\n @exception  rb_eTypeError     Can't convert `str` into ::rb_cString.\n @exception  rb_eRuntimeError  Too many symbols.\n @return     A (possibly new) id whose value is the given str.\n @note       These   days  Ruby   internally   has  two   kinds  of   symbols\n             (static/dynamic).   Symbols created  using  this function  would\n             become static ones;  i.e. would never be  garbage collected.  It\n             is up  to you to avoid  memory leaks.  Think twice  before using\n             it."]
    pub fn rb_intern_str(str_: VALUE) -> ID;
}
extern "C" {
    #[doc = " Retrieves the name mapped to the given id.\n\n @param[in]  id         An id to query.\n @retval     NULL       No such id ever existed in the history.\n @retval     otherwise  A name that the id represents.\n @note       The return value  is managed by the interpreter.   Don't pass it\n             to free()."]
    pub fn rb_id2name(id: ID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Detects if  the given name  is already interned or  not.  It first  tries to\n convert the  argument to  an instance  of ::rb_cString if  it is  neither an\n instance of ::rb_cString nor ::rb_cSymbol.  The conversion result is written\n back  to the  variable.   Then queries  if that  name  was already  interned\n before.  If found it returns such id, otherwise zero.\n\n We  eventually introduced  this API  to avoid  inadvertent symbol  pin-down.\n Before,  there was  no way  to know  if an  ID was  already interned  or not\n without actually  creating one (== leaking  memory).  By using this  API you\n can avoid such situations:\n\n ```CXX\n bool does_interning_this_leak_memory(VALUE obj)\n {\n     auto tmp = obj;\n     if (auto id = rb_check_id(&tmp); id) {\n         return false;\n     }\n     else {\n         return true; // Let GC sweep tmp if necessary.\n     }\n }\n ```\n\n @param[in,out]  namep              A pointer to a name to query.\n @pre            The object referred  by `*namep` must either  be an instance\n                 of ::rb_cSymbol, or an instance of ::rb_cString, or responds\n                 to `#to_str` method.\n @exception      rb_eTypeError      Can't convert `*namep` into ::rb_cString.\n @exception      rb_eEncodingError  Given string is non-ASCII.\n @retval         0                  No such id ever existed in the history.\n @retval         otherwise          The id that represents the given name.\n @post           The object  that `*namep`  points to  is a  converted result\n                 object, which  is always an instance  of either ::rb_cSymbol\n                 or ::rb_cString.\n @see            https://bugs.ruby-lang.org/issues/5072\n\n @internal\n\n @shyouhei doesn't know why this has to raise rb_eEncodingError."]
    pub fn rb_check_id(namep: *mut VALUE) -> ID;
}
extern "C" {
    #[doc = " @copydoc rb_intern_str()\n\n @internal\n\n :FIXME:  Can anyone  tell us  what is  the difference  between this  one and\n rb_intern_str()?  As far as @shyouhei reads the implementation it seems what\n rb_to_id() does is  is just waste some CPU time,  then call rb_intern_str().\n He hopes he is wrong."]
    pub fn rb_to_id(str_: VALUE) -> ID;
}
extern "C" {
    #[doc = " Identical to rb_id2name(), except it returns a Ruby's String instead of C's.\n\n @param[in]  id           An id to query.\n @retval     RUBY_Qfalse  No such id ever existed in the history.\n @retval     otherwise    An instance of ::rb_cString with the name of id.\n\n @internal\n\n In reality \"rb_id2str() is identical  to rb_id2name() except it returns Ruby\n string\" is just describing things upside down; truth is `rb_id2name(foo)` is\n a shorthand of `RSTRING_PTR(rb_id2str(foo))`."]
    pub fn rb_id2str(id: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_id2str(), except it takes an instance of ::rb_cSymbol rather\n than an ::ID.\n\n @param[in]  id           An id to query.\n @retval     RUBY_Qfalse  No such id ever existed in the history.\n @retval     otherwise    An instance of ::rb_cString with the name of id."]
    pub fn rb_sym2str(id: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_intern_str(), except  it  generates  a dynamic  symbol  if\n necessary.\n\n @param[in]  name              The name of the id.\n @pre        `name`  must  either  be  an instance  of  ::rb_cSymbol,  or  an\n             instance of ::rb_cString, or responds to `#to_str` method.\n @exception  rb_eTypeError     Can't convert `name` into ::rb_cString.\n @exception  rb_eRuntimeError  Too many symbols.\n @return     A (possibly new) id whose value is the given name.\n @note       These   days  Ruby   internally   has  two   kinds  of   symbols\n             (static/dynamic).   Symbols created  using  this function  would\n             become dynamic ones; i.e. would  be garbage collected.  It could\n             be safer for you to use it than alternatives, when applicable."]
    pub fn rb_to_symbol(name: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_check_id(), except it  returns an instance  of ::rb_cSymbol\n instead.\n\n @param[in,out]  namep              A pointer to a name to query.\n @pre            The object referred  by `*namep` must either  be an instance\n                 of ::rb_cSymbol, or an instance of ::rb_cString, or responds\n                 to `#to_str` method.\n @exception      rb_eTypeError      Can't convert `*namep` into ::rb_cString.\n @exception      rb_eEncodingError  Given string is non-ASCII.\n @retval         RUBY_Qnil          No such id ever existed in the history.\n @retval         otherwise          The id that represents the given name.\n @post           The object  that `*namep`  points to  is a  converted result\n                 object, which  is always an instance  of either ::rb_cSymbol\n                 or ::rb_cString.\n @see            https://bugs.ruby-lang.org/issues/5072\n\n @internal\n\n @shyouhei doesn't know why this has to raise rb_eEncodingError."]
    pub fn rb_check_symbol(namep: *mut VALUE) -> VALUE;
}
#[doc = " Type that represents a global variable getter function.\n\n @param[in]      id    The variable name.\n @param[in,out]  data  Where the value is stored.\n @return         The value that shall be visible from Ruby."]
pub type rb_gvar_getter_t =
    ::std::option::Option<unsafe extern "C" fn(id: ID, data: *mut VALUE) -> VALUE>;
#[doc = " Type that represents a global variable setter function.\n\n @param[in]      val   The value to set.\n @param[in]      id    The variable name.\n @param[in,out]  data  Where the value is to be stored."]
pub type rb_gvar_setter_t =
    ::std::option::Option<unsafe extern "C" fn(val: VALUE, id: ID, data: *mut VALUE)>;
#[doc = " Type that represents a global variable marker function.\n\n @param[in]  var  Where the value is to be stored."]
pub type rb_gvar_marker_t = ::std::option::Option<unsafe extern "C" fn(var: *mut VALUE)>;
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_undef_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
}
extern "C" {
    #[doc = " This is the getter function that  backs global variables defined from a ruby\n script.  Extension  libraries can use this  if its global variable  needs no\n custom logic."]
    pub fn rb_gvar_val_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is the setter function that  backs global variables defined from a ruby\n script.  Extension  libraries can use this  if its global variable  needs no\n custom logic."]
    pub fn rb_gvar_val_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    #[doc = " This is the setter function that  backs global variables defined from a ruby\n script.  Extension  libraries can use this  if its global variable  needs no\n custom logic."]
    pub fn rb_gvar_val_marker(var: *mut VALUE);
}
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_var_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_var_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    #[doc = " @deprecated\n\n This function has no actual usage (than in ruby itself).  Please ignore.  It\n was a bad idea to expose this function  to 3rd parties, but we can no longer\n delete it."]
    pub fn rb_gvar_var_marker(var: *mut VALUE);
}
extern "C" {
    #[doc = " This function just raises ::rb_eNameError.   Handy when you want to prohibit\n a global variable from being squashed by someone."]
    pub fn rb_gvar_readonly_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE) -> !;
}
extern "C" {
    #[doc = " \"Shares\" a global variable between Ruby and C.  Normally a Ruby-level global\n variable  is stored  somewhere deep  inside of  the interpreter's  execution\n context, but this way you can explicitly specify its storage.\n\n ```CXX\n static VALUE foo;\n\n extern \"C\" void\n init_Foo(void)\n {\n     foo = rb_eval_string(\"...\");\n     rb_define_variable(\"$foo\", &foo);\n }\n ```\n\n In the above  example a Ruby global  variable named `$foo` is stored  in a C\n global variable named `foo`.\n\n @param[in]  name  Variable (Ruby side).\n @param[in]  var   Variable (C side).\n @post       Ruby level  global variable named  `name` is defined  if absent,\n             and its storage is set to `var`."]
    pub fn rb_define_variable(name: *const ::std::os::raw::c_char, var: *mut VALUE);
}
extern "C" {
    #[doc = " Defines a global variable that  is purely function-backended.  By using this\n API a programmer can define a  global variable that dynamically changes from\n time to time.\n\n @param[in]  name   Variable name, in C's string.\n @param[in]  getter A getter function.\n @param[in]  setter A setter function.\n @post       Ruby level global variable named `name` is defined if absent.\n\n @internal\n\n @shyouhei doesn't know if this is an  Easter egg or an official feature, but\n you can pass  0 to the third argument (setter).   That effectively nullifies\n any efforts to write to the defining global variable."]
    pub fn rb_define_virtual_variable(
        name: *const ::std::os::raw::c_char,
        getter: rb_gvar_getter_t,
        setter: rb_gvar_setter_t,
    );
}
extern "C" {
    #[doc = " Identical to  rb_define_virtual_variable(), but can also  specify a storage.\n A programmer can use the storage for e.g.  memoisation, storing intermediate\n computation result, etc.\n\n Also you can pass 0 to this function, unlike other variants:\n\n   - When getter is 0 ::rb_gvar_var_getter is used instead.\n   - When setter is 0 ::rb_gvar_var_setter is used instead.\n   - When data is 0, you must  specify a non-zero setter function.  Otherwise\n     ::rb_gvar_var_setter tries to write to `*NULL`, and just causes SEGV.\n\n @param[in]  name   Variable name, in C's string.\n @param[in]  var    Variable storage.\n @param[in]  getter A getter function.\n @param[in]  setter A setter function.\n @post       Ruby level global variable named `name` is defined if absent."]
    pub fn rb_define_hooked_variable(
        name: *const ::std::os::raw::c_char,
        var: *mut VALUE,
        getter: rb_gvar_getter_t,
        setter: rb_gvar_setter_t,
    );
}
extern "C" {
    #[doc = " Identical to rb_define_variable(), except it does not allow Ruby programs to\n assign values  to such  global variable.   C codes can  still set  values at\n will.   This  could be  handy  for  you  when implementing  an  `errno`-like\n experience, where  a method updates a  read-only global variable as  a side-\n effect.\n\n @param[in]  name  Variable (Ruby side).\n @param[in]  var   Variable (C side).\n @post       Ruby level  global variable named  `name` is defined  if absent,\n             and its storage is set to `var`."]
    pub fn rb_define_readonly_variable(name: *const ::std::os::raw::c_char, var: *const VALUE);
}
extern "C" {
    #[doc = " Defines a Ruby level constant under a namespace.\n\n @param[out]  klass            Namespace for the constant to reside.\n @param[in]   name             Name of the constant.\n @param[in]   val              Value of the constant.\n @exception   rb_eTypeError    `klass` is not a kind of ::rb_cModule.\n @exception   rb_eFrozenError  `klass` is frozen.\n @post        Ruby level constant `klass::name` is defined to be `val`.\n @note        This API  does not stop  you from  defining a constant  that is\n              unable  to   reach  from   ruby  (like  for   instance  passing\n              non-capital letter to `name`).\n @note        This API  does not  stop you from  overwriting a  constant that\n              already exist.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_define_const(klass: VALUE, name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    #[doc = " Identical  to  rb_define_const(),  except   it  defines  that  of  \"global\",\n i.e. toplevel constant.\n\n @param[in]   name             Name of the constant.\n @param[in]   val              Value of the constant.\n @exception   rb_eFrozenError  ::rb_cObject is frozen.\n @post        Ruby level constant \\::name is defined to be `val`.\n @note        This API  does not stop  you from  defining a constant  that is\n              unable  to   reach  from   ruby  (like  for   instance  passing\n              non-capital letter to `name`).\n @note        This API  does not  stop you from  overwriting a  constant that\n              already exist."]
    pub fn rb_define_global_const(name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    #[doc = " Asserts  that the  given  constant  is deprecated.   Attempt  to refer  such\n constant will produce a warning.\n\n @param[in]  mod              Namespace of the target constant.\n @param[in]  name             Name of the constant.\n @exception  rb_eNameError    No such constant.\n @exception  rb_eFrozenError  `mod` is frozen.\n @post       `name` under `mod` is deprecated."]
    pub fn rb_deprecate_constant(mod_: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Assigns to a global variable.\n\n @param[in]  name  Target global variable.\n @param[in]  val   Value to assign.\n @return     Passed value.\n @post       Ruby level  global variable named  `name` is defined  if absent,\n             whose value is set to `val`.\n\n @internal\n\n Above  description  is  in  fact   inaccurate.   This  API  interfaces  with\n `set_trace_func`."]
    pub fn rb_gv_set(name: *const ::std::os::raw::c_char, val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Obtains a global variable.\n\n @param[in]  name       Global variable to query.\n @retval     RUBY_Qnil  The global variable does not exist.\n @retval     otherwise  The value assigned to the global variable.\n\n @internal\n\n Unlike rb_gv_set(), there is no way to trace this function."]
    pub fn rb_gv_get(name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Obtains an instance variable.\n\n @param[in]  obj                Target object.\n @param[in]  name               Target instance variable to query.\n @exception  rb_eEncodingError  `name` is corrupt (contains Hanzi etc.).\n @retval     RUBY_nil           No such instance variable.\n @retval     otherwise          The value assigned to the instance variable."]
    pub fn rb_iv_get(obj: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Assigns to an instance variable.\n\n @param[out]  obj                Target object.\n @param[in]   name               Target instance variable.\n @param[in]   val                Value to assign.\n @exception   rb_eFrozenError    Can't modify `obj`.\n @exception   rb_eArgError       `obj` has too many instance variables.\n @return      Passed value.\n @post        An  instance variable  named  `name` is  defined  if absent  on\n              `obj`, whose value is set to `val`.\n\n @internal\n\n This function does not stop you form creating an ASCII-incompatible instance\n variable, but there is no way to get one because rb_iv_get raises exceptions\n for such things.  This design seems broken...  But no idea why."]
    pub fn rb_iv_set(obj: VALUE, name: *const ::std::os::raw::c_char, val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts an object to a path.  It first tries `#to_path` method if any, then\n falls back to `#to_str` method.\n\n @param[in]  obj                 Arbitrary ruby object.\n @exception  rb_eArgError        `obj` contains a NUL byte.\n @exception  rb_eTypeError       `obj` is not path-ish.\n @exception  rb_eEncCompatError  No encoding conversion from `obj` to path.\n @return     Converted path object."]
    pub fn rb_get_path(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @deprecated  This function is an alias  of rb_get_path() now.  The part that\n              did \"no_checksafe\" was deleted.  It  remains here because of no\n              harm."]
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_varargs_bad_length(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the name of the passed class.\n\n @param[in]  klass  An instance of a class.\n @return     The name of `klass`.\n @note       Return value is managed by our GC.  Don't free."]
    pub fn rb_class2name(klass: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Queries the name of the class of the passed object.\n\n @param[in]  obj  Arbitrary ruby object.\n @return     The name of the class of `obj`.\n @note       Return value is managed by our GC.  Don't free."]
    pub fn rb_obj_classname(obj: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Inspects an object.   It first calls the argument's  `#inspect` method, then\n feeds its result string into ::rb_stdout.\n\n This is identical to Ruby level `Kernel#p`, except it takes only one object.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_p(obj: VALUE);
}
extern "C" {
    #[doc = " This function is an optimised version  of calling `#==`.  It checks equality\n between two  objects by first  doing a fast  identity check using  using C's\n `==` (same  as `BasicObject#equal?`).  If  that check fails, it  calls `#==`\n dynamically.   This optimisation  actually affects  semantics, because  when\n `#==`  returns false  for the  same object  obj, `rb_equal(obj,  obj)` would\n still  return true.   This happens  for `Float::NAN`,  where `Float::NAN  ==\n Float::NAN` is `false`, but `rb_equal(Float::NAN, Float::NAN)` is `true`.\n\n @param[in]  lhs          Comparison LHS.\n @param[in]  rhs          Comparison RHS.\n @retval     RUBY_Qtrue   They are the same.\n @retval     RUBY_Qfalse  They are different."]
    pub fn rb_equal(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_require_string(),  except it  takes C's  string instead  of\n Ruby's.\n\n @param[in]  feature           Name of a feature, e.g. `\"json\"`.\n @exception  rb_eLoadError     No such feature.\n @exception  rb_eRuntimeError  `$\"` is frozen; unable to push.\n @retval     RUBY_Qtrue        The feature is loaded for the first time.\n @retval     RUBY_Qfalse       The feature has already been loaded.\n @post       `$\"` is updated."]
    pub fn rb_require(feature: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Allocates a bignum object.\n\n @param[in]  len   Length of the bignum's backend storage, in words.\n @param[in]  sign  Sign of the bignum.\n @return     An allocated new bignum instance.\n @note       This only allocates an object, doesn't fill its value in.\n\n @internal\n\n @shyouhei  finds it  hard to  use from  extension libraries.   `len` is  per\n `BDIGIT` but its definition is hidden."]
    pub fn rb_big_new(len: usize, sign: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Queries if  the passed bignum  instance is a  \"bigzro\".  What is  a bigzero?\n Well, bignums  are for very big  integers, but can also  represent tiny ones\n like -1,  0, 1.   Bigzero are  instances of bignums  whose values  are zero.\n Knowing if a bignum is bigzero can  be handy on occasions, like for instance\n detecting division by zero situation.\n\n @param[in]  x  A bignum.\n @retval     1  It is a bigzero.\n @retval     0  Otherwise."]
    pub fn rb_bigzero_p(x: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Duplicates the given bignum.\n\n @param[in]  num  A bignum.\n @return     An allocated bignum, who is equivalent to `num`."]
    pub fn rb_big_clone(num: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively modify the passed bignum into 2's complement representation.\n\n @note  By default bignums are in signed magnitude system.\n\n @param[out]  num  A bignum to modify."]
    pub fn rb_big_2comp(num: VALUE);
}
extern "C" {
    #[doc = " Normalises the passed bignum.  It for  instance returns a fixnum of the same\n value if fixnum can represent that number.\n\n @param[out]  x  Target bignum (can be destructively modified).\n @return      An integer of the identical value (can be `x` itself)."]
    pub fn rb_big_norm(x: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Destructively resizes the backend storage of the passed bignum.\n\n @param[out]  big  A bignum.\n @param[in]   len  New length of `big`'s backend, in words."]
    pub fn rb_big_resize(big: VALUE, len: usize);
}
extern "C" {
    #[doc = " Parses C's string to convert into a Ruby's integer.  It understands prefixes\n (e.g. `0x`) and underscores.\n\n @param[in]  str           Stringised representation of the return value.\n @param[in]  base          Base of conversion.   Must be `-36..36` inclusive,\n                           except `1`.  `2..36` means  the conversion is done\n                           according to it,  with unmatched prefix understood\n                           as  a part  of  the result.   `-36..-2` means  the\n                           conversion  honours prefix  when  present, or  use\n                           `-base` when  absent. `0` is equivalent  to `-10`.\n                           `-1` mandates a prefix. `1` is an error.\n @param[in]  badcheck      Whether  to raise  ::rb_eArgError on  failure.  If\n                           `0`  is  passed  here  this  function  can  return\n                           `INT2FIX(0)` for parse errors.\n @exception  rb_eArgError  Failed to parse (and `badcheck` is truthy).\n @return     An instance of ::rb_cInteger,  which is a numeric interpretation\n             of what is written in `str`.\n\n @internal\n\n Not sure if it intentionally accepts `base  == -1` or is just buggy.  Nobody\n practically uses negative bases these days."]
    pub fn rb_cstr_to_inum(
        str_: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
        badcheck: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_cstr2inum(), except it takes Ruby's strings instead of C's.\n\n @param[in]  str                 Stringised  representation   of  the  return\n                                 value.\n @param[in]  base                Base  of  conversion.    Must  be  `-36..36`\n                                 inclusive,  except `1`.   `2..36` means  the\n                                 conversion  is done  according  to it,  with\n                                 unmatched prefix understood as a part of the\n                                 result.   `-36..-2`   means  the  conversion\n                                 honours prefix when  present, or use `-base`\n                                 when  absent. `0`  is  equivalent to  `-10`.\n                                 `-1` mandates a prefix. `1` is an error.\n @param[in]  badcheck            Whether to raise  ::rb_eArgError on failure.\n                                 If  `0` is  passed  here  this function  can\n                                 return `INT2FIX(0)` for parse errors.\n @exception  rb_eArgError        Failed to parse (and `badcheck` is truthy).\n @exception  rb_eTypeError       `str` is not a string.\n @exception  rb_eEncCompatError  `str` is not ASCII compatible.\n @return     An instance of ::rb_cInteger,  which is a numeric interpretation\n             of what is written in `str`."]
    pub fn rb_str_to_inum(
        str_: VALUE,
        base: ::std::os::raw::c_int,
        badcheck: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_cstr_to_inum(), except the second argument controls the base\n and badcheck at  once.  It basically doesn't raise for  parse errors, unless\n the base is zero.\n\n This is an older API.  New codes might prefer rb_cstr_to_inum().\n\n @param[in]  str           Stringised representation of the return value.\n @param[in]  base          Base of conversion.   Must be `-36..36` inclusive,\n                           except `1`.  `2..36` means  the conversion is done\n                           according to it,  with unmatched prefix understood\n                           as  a part  of  the result.   `-36..-2` means  the\n                           conversion  honours prefix  when  present, or  use\n                           `-base` when  absent. `0` is equivalent  to `-10`.\n                           `-1` mandates a prefix. `1` is an error.\n @exception  rb_eArgError  Failed to parse (and `base` is zero).\n @return     An instance of ::rb_cInteger,  which is a numeric interpretation\n             of what is written in `str`."]
    pub fn rb_cstr2inum(str_: *const ::std::os::raw::c_char, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_to_inum(), except the  second argument controls the base\n and  badcheck at  once.  It  can  also be  seen  as a  routine identical  to\n rb_cstr2inum(), except it takes Ruby's strings instead of C's.\n\n This is an older API.  New codes might prefer rb_cstr_to_inum().\n\n @param[in]  str                 Stringised  representation   of  the  return\n                                 value.\n @param[in]  base                Base  of  conversion.    Must  be  `-36..36`\n                                 inclusive,  except `1`.   `2..36` means  the\n                                 conversion  is done  according  to it,  with\n                                 unmatched prefix understood as a part of the\n                                 result.   `-36..-2`   means  the  conversion\n                                 honours prefix when  present, or use `-base`\n                                 when  absent. `0`  is  equivalent to  `-10`.\n                                 `-1` mandates a prefix. `1` is an error.\n @exception  rb_eArgError        Failed to parse (and `base` is zero).\n @exception  rb_eTypeError       `str` is not a string.\n @exception  rb_eEncCompatError  `str` is not ASCII compatible.\n @return     An instance of ::rb_cInteger,  which is a numeric interpretation\n             of what is written in `str`."]
    pub fn rb_str2inum(str_: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Generates a place-value representation of the passed integer.\n\n @param[in]  x               An integer to stringify.\n @param[in]  base            `2` to `36` inclusive for each radix.\n @exception  rb_eArgError    `base` is out of range.\n @exception  rb_eRangeError  `x` is too big, cannot represent in string.\n @return     An instance of ::rb_cString which represents `x`."]
    pub fn rb_big2str(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Converts a bignum into C's `long`.\n\n @param[in]  x               A bignum.\n @exception  rb_eRangeError  `x` is out of range of `long`.\n @return     The passed value converted into C's `long`."]
    pub fn rb_big2long(x: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Converts a bignum into C's `unsigned long`.\n\n @param[in]  x               A bignum.\n @exception  rb_eRangeError  `x` is out of range of `unsigned long`.\n @return     The passed value converted into C's `unsigned long`.\n\n @internal\n\n This function  can generate  a very  large positive  integer for  a negative\n input.   For instance  applying  Ruby's  -4,611,686,018,427,387,905 to  this\n function yields C's  13,835,058,055,282,163,711 on my machine.   This is how\n it has been.  Cannot change any longer."]
    pub fn rb_big2ulong(x: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Converts a bignum into C's `long long`.\n\n @param[in]  x               A bignum.\n @exception  rb_eRangeError  `x` is out of range of `long long`.\n @return     The passed value converted into C's `long long`."]
    pub fn rb_big2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Converts a bignum into C's `unsigned long long`.\n\n @param[in]  x               A bignum.\n @exception  rb_eRangeError  `x` is out of range of `unsigned long long`.\n @return     The passed value converted into C's `unsigned long long`.\n\n @internal\n\n This function  can generate  a very  large positive  integer for  a negative\n input.   For instance  applying  Ruby's  -4,611,686,018,427,387,905 to  this\n function yields C's  13,835,058,055,282,163,711 on my machine.   This is how\n it has been.  Cannot change any longer."]
    pub fn rb_big2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Converts a bignum into a series of its parts.\n\n @param[in]   val            An integer.\n @param[out]  buf            Return buffer.\n @param[in]   num_longs      Number of words of `buf`.\n @exception   rb_eTypeError  `val` doesn't respond to `#to_int`.\n @post        `buf` is filled with  `val`'s 2's complement representation, in\n              the host CPU's  native byte order, from  least significant word\n              towards the most significant one, for `num_longs` words.\n @note        The \"pack\" terminology comes from `Array#pack`."]
    pub fn rb_big_pack(
        val: VALUE,
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " Constructs a (possibly very big) bignum from a series of integers.  `buf[0]`\n would be the return value's least significant word; `buf[num_longs-1]` would\n be that of most significant.\n\n @param[in]  buf           A series of integers.\n @param[in]  num_longs     Number of words of `buf`.\n @exception  rb_eArgError  Result would be too big.\n @return     An instance  of ::rb_cInteger which  is an \"unpack\"-ed  value of\n             the parameters.\n @note       The \"unpack\" terminology comes from `String#pack`."]
    pub fn rb_big_unpack(
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Encodes a Unicode codepoint into its UTF-8 representation.\n\n @param[out]  buf             Return buffer, must at least be 6 bytes width.\n @param[in]   uv              An Unicode codepoint.\n @exception   rb_eRangeError  `uv` is out of Unicode.\n @return      Number of bytes written to `buf`\n @post        `buf` holds a UTF-8 representation of `uv`."]
    pub fn rb_uv_to_utf8(
        buf: *mut ::std::os::raw::c_char,
        uv: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a C's `double` into a bignum.\n\n @param[in]  d                     A value to convert.\n @exception  rb_eFloatDomainError  `d` is Inf/NaN.\n @return     An instance of ::rb_cInteger whose value is approximately `d`.\n\n @internal\n\n @shyouhei is not sure if the result  is guaranteed to be the nearest integer\n of `d`."]
    pub fn rb_dbl2big(d: f64) -> VALUE;
}
extern "C" {
    #[doc = " Converts a bignum into C's `double`.\n\n @param[in]  x  A bignum.\n @return     The passed value converted into C's `double`.\n\n @internal\n\n @shyouhei is not sure if the result  is guaranteed to be `x`'s nearest value\n that a `double` can represent."]
    pub fn rb_big2dbl(x: VALUE) -> f64;
}
extern "C" {
    #[doc = " Compares the passed two bignums.\n\n @param[in]  lhs  Comparison LHS.\n @param[in]  rhs  Comparison RHS.\n @retval     -1   `rhs` is bigger than `lhs`.\n @retval     0    They are identical.\n @retval     1    `lhs` is bigger than `rhs`.\n @see        rb_num_coerce_cmp()"]
    pub fn rb_big_cmp(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Equality, in terms of `==`.  This checks if the _value_ is the same, not the\n identity.  For instance `1 == 1.0` must hold.\n\n @param[in]  lhs          Comparison LHS.\n @param[in]  rhs          Comparison RHS.\n @retval     RUBY_Qtrue   They are the same.\n @retval     RUBY_Qfalse  They are different."]
    pub fn rb_big_eq(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Equality,  in terms  of  `eql?`.   Unlike rb_big_eq()  it  does not  convert\n ::rb_cFloat etc.   This function  returns ::RUBY_Qtrue if  and only  if both\n parameters are bignums, which represent the identical numerical value.\n\n @param[in]  lhs          Comparison LHS.\n @param[in]  rhs          Comparison RHS.\n @retval     RUBY_Qtrue   They are identical.\n @retval     RUBY_Qfalse  They are distinct."]
    pub fn rb_big_eql(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs addition of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x + y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_plus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs subtraction of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x - y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_minus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs multiplication of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x * y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_mul(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs division of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x / y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_div(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs \"integer division\".  This is different from rb_big_div().\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x.div y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_idiv(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs modulo of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x % y` evaluates to.\n @see        rb_num_coerce_bin()\n\n @internal\n\n There also is `rb_big_remainder()` internally,  which is different from this\n one."]
    pub fn rb_big_modulo(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs \"divmod\" operation.   The operation in bignum's context  is that it\n calculates rb_big_idiv() and rb_big_modulo() at once.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x.divmod y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_big_divmod(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Raises `x` to the powerof `y`.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x ** y` evaluates to.\n @see        rb_num_coerce_bin()\n @note       This can return  an instance of ::rb_cFloat, even  when both `x`\n             and `y` are bignums.  Or an instance of ::rb_cRational, when for\n             instance `y` is negative."]
    pub fn rb_big_pow(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs bitwise and of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x & y` evaluates to.\n @see        rb_num_coerce_bit()"]
    pub fn rb_big_and(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs bitwise or of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x | y` evaluates to.\n @see        rb_num_coerce_bit()"]
    pub fn rb_big_or(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs exclusive or of the passed two objects.\n\n @param[in]  x  A bignum.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x ^ y` evaluates to.\n @see        rb_num_coerce_bit()"]
    pub fn rb_big_xor(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs shift left.\n\n @param[in]  x              A bignum.\n @param[in]  y              Shift amount.\n @exception  rb_eTypeError  `y` is not an integer.\n @exception  rb_eArgError   `y` is too big.\n @return     `x` shifted left to `y` bits.\n @note       `y` can be negative.  Shifts right then."]
    pub fn rb_big_lshift(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs shift right.\n\n @param[in]  x              A bignum.\n @param[in]  y              Shift amount.\n @exception  rb_eTypeError  `y` is not an integer.\n @return     `x` shifted right to `y` bits.\n @note       This is arithmetic.  Because bignums  are not bitfields there is\n             no shift right logical operator."]
    pub fn rb_big_rshift(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Exports an integer into a buffer.   This function fills the buffer specified\n by `words`  and `numwords` as `val`  in the format specified  by `wordsize`,\n `nails` and `flags`.\n\n @param[in]   val            Integer   or  integer-like   object  which   has\n                             `#to_int` method.\n @param[out]  words          Return buffer.\n @param[in]   numwords       Number of words of `words`.\n @param[in]   wordsize       Number of bytes per word.\n @param[in]   nails          Number  of   padding  bits  in  a   word.   Most\n                             significant nails  bits of each word  are filled\n                             by zero.\n @param[in]   flags          Bitwise  or  of   constants  whose  name  starts\n                             \"INTEGER_PACK_\".\n @exception   rb_eTypeError  `val` doesn't respond to `#to_int`.\n\n Possible flags are:\n\n   - #INTEGER_PACK_MSWORD_FIRST:\n       Stores the most significant word as the first word.\n\n   - #INTEGER_PACK_LSWORD_FIRST:\n       Stores the least significant word as the first word.\n\n   - #INTEGER_PACK_MSBYTE_FIRST:\n       Stores the most  significant byte in a  word as the first  byte in the\n       word.\n\n   - #INTEGER_PACK_LSBYTE_FIRST:\n       Stores the least significant  byte in a word as the  first byte in the\n       word.\n\n   - #INTEGER_PACK_NATIVE_BYTE_ORDER:\n       Either   #INTEGER_PACK_MSBYTE_FIRST    or   #INTEGER_PACK_LSBYTE_FIRST\n       corresponding to the host's endian.\n\n   - #INTEGER_PACK_2COMP:\n       Uses 2's complement representation.\n\n   - #INTEGER_PACK_LITTLE_ENDIAN: Shorthand of\n       `INTEGER_PACK_LSWORD_FIRST|INTEGER_PACK_LSBYTE_FIRST`.\n\n   - #INTEGER_PACK_BIG_ENDIAN: Shorthand of\n       `INTEGER_PACK_MSWORD_FIRST|INTEGER_PACK_MSBYTE_FIRST`.\n\n   - #INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION:\n       Uses generic implementation (for test and debug).\n\n This  function  fills  the  buffer  specified  by  `words`  as  `val`'s  2's\n complement representation  if #INTEGER_PACK_2COMP  is specified  in `flags`.\n Otherwise it fills `words` as `abs(val)`  and signedness is returned via the\n return value.\n\n @return  The  signedness and  overflow  condition.   The overflow  condition\n          depends on #INTEGER_PACK_2COMP.\n\n When #INTEGER_PACK_2COMP is not specified:\n\n   - `-2` :\n       Negative overflow.  `val <= -2**(numwords*(wordsize*CHAR_BIT-nails))`\n\n   - `-1` :\n       Negative without overflow.\n       `-2**(numwords*(wordsize*CHAR_BIT-nails)) < val < 0`\n\n   - `0` : zero.  `val == 0`\n\n   - `1` :\n       Positive without overflow.\n       `0 < val < 2**(numwords*(wordsize*CHAR_BIT-nails))`\n\n   - `2` :\n       Positive overflow.  `2**(numwords*(wordsize*CHAR_BIT-nails)) <= val`\n\n When #INTEGER_PACK_2COMP is specified:\n\n   - `-2` :\n       Negative overflow.  `val < -2**(numwords*(wordsize*CHAR_BIT-nails))`\n\n   - `-1` :\n       Negative without overflow.\n       `-2**(numwords*(wordsize*CHAR_BIT-nails)) <= val < 0`\n\n   - `0` : zero.  `val == 0`\n\n   - `1` :\n       Positive without overflow.\n       `0 < val < 2**(numwords*(wordsize*CHAR_BIT-nails))`\n\n   - `2` :\n       Positive overflow.  `2**(numwords*(wordsize*CHAR_BIT-nails)) <= val`\n\n The value,  `-2**(numwords*(wordsize*CHAR_BIT-nails))`, is  representable in\n 2's complement representation  but not representable in  absolute value.  So\n `-1`  is returned  for the  value  if #INTEGER_PACK_2COMP  is specified  but\n returns `-2` if #INTEGER_PACK_2COMP is not specified.\n\n The least significant words are filled in the buffer when overflow occur."]
    pub fn rb_integer_pack(
        val: VALUE,
        words: *mut ::std::os::raw::c_void,
        numwords: usize,
        wordsize: usize,
        nails: usize,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Import an integer from a buffer.\n\n @param[in]  words         Buffer to import.\n @param[in]  numwords      Number of words of `words`.\n @param[in]  wordsize      Number of bytes per word.\n @param[in]  nails         Number   of  padding   bits  in   a  word.    Most\n                           significant nails bits of each word are ignored.\n @param[in]  flags         Bitwise   or  of   constants  whose   name  starts\n                           \"INTEGER_PACK_\".\n @exception  rb_eArgError  `numwords * wordsize` too big.\n\n Possible flags are:\n\n   - #INTEGER_PACK_MSWORD_FIRST:\n       Interpret the first word as the most significant word.\n\n   - #INTEGER_PACK_LSWORD_FIRST:\n       Interpret the first word as the least significant word.\n\n   - #INTEGER_PACK_MSBYTE_FIRST:\n       Interpret the first byte in a word as the most significant byte in the\n       word.\n\n   - #INTEGER_PACK_LSBYTE_FIRST:\n       Interpret the  first byte in a  word as the least  significant byte in\n       the word.\n\n   - #INTEGER_PACK_NATIVE_BYTE_ORDER:\n       Either   #INTEGER_PACK_MSBYTE_FIRST    or   #INTEGER_PACK_LSBYTE_FIRST\n       corresponding to the host's endian.\n\n   - #INTEGER_PACK_2COMP:\n       Uses 2's complement representation.\n\n   - #INTEGER_PACK_LITTLE_ENDIAN: Shorthand of\n       `INTEGER_PACK_LSWORD_FIRST|INTEGER_PACK_LSBYTE_FIRST`\n\n   - #INTEGER_PACK_BIG_ENDIAN: Shorthand of\n       `INTEGER_PACK_MSWORD_FIRST|INTEGER_PACK_MSBYTE_FIRST`\n\n   - #INTEGER_PACK_FORCE_BIGNUM:\n       Returns a bignum even if its value is representable as a fixnum.\n\n   - #INTEGER_PACK_NEGATIVE:\n       Returns a  non-positive value.  (Returns a  non-negative value  if not\n       specified.)\n\n   - #INTEGER_PACK_FORCE_GENERIC_IMPLEMENTATION:\n       Uses generic implementation (for test and debug).\n\n @return  An  instance  of  ::rb_cInteger  whose  value  is  the  interpreted\n          `words`.    The   range   of    the   result   value   depends   on\n          #INTEGER_PACK_2COMP and #INTEGER_PACK_NEGATIVE.\n\n When #INTEGER_PACK_2COMP is not set:\n\n   - `0 <= val < 2**(numwords*(wordsize*CHAR_BIT-nails))` if\n     `!INTEGER_PACK_NEGATIVE`\n\n   - `-2**(numwords*(wordsize*CHAR_BIT-nails)) < val <= 0` if\n     `INTEGER_PACK_NEGATIVE`\n\n When #INTEGER_PACK_2COMP is set:\n\n   - `-2**(numwords*(wordsize*CHAR_BIT-nails)-1)` `<= val <=`\n     `2**(numwords*(wordsize*CHAR_BIT-nails)-1)-1` if\n     `!INTEGER_PACK_NEGATIVE`\n\n   - `-2**(numwords*(wordsize*CHAR_BIT-nails)) <= val <= -1` if\n     `INTEGER_PACK_NEGATIVE`\n\n Passing  #INTEGER_PACK_2COMP   without  #INTEGER_PACK_NEGATIVE   means  sign\n extension.  #INTEGER_PACK_2COMP  with #INTEGER_PACK_NEGATIVE  means assuming\n the higher bits are `1`.\n\n Note   that  this   function  returns   0  when   `numwords`  is   zero  and\n #INTEGER_PACK_2COMP is set but #INTEGER_PACK_NEGATIVE is not set."]
    pub fn rb_integer_unpack(
        words: *const ::std::os::raw::c_void,
        numwords: usize,
        wordsize: usize,
        nails: usize,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Calculates the number of bytes needed to represent the absolute value of the\n passed integer.\n\n @param[in]   val            Integer   or  integer-like   object  which   has\n                             `#to_int` method.\n @param[out]  nlz_bits_ret   Number  of   leading  zero  bits  in   the  most\n                             significant byte is returned if not `NULL`.\n @exception   rb_eTypeError  `val` doesn't respond to `#to_int`.\n @return      `((val_numbits * CHAR_BIT + CHAR_BIT - 1) / CHAR_BIT)`,   where\n              val_numbits is the number of bits of `abs(val)`.\n @post        If `nlz_bits_ret` is not `NULL`,\n              `(return_value * CHAR_BIT - val_numbits)`    is    stored    in\n              `*nlz_bits_ret`.  In this case,\n              `0 <= *nlz_bits_ret < CHAR_BIT`.\n\n This function should not overflow."]
    pub fn rb_absint_size(val: VALUE, nlz_bits_ret: *mut ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[doc = " Calculates the  number of words needed  represent the absolute value  of the\n passed  integer.  Unlike  rb_absint_size() this  function can  overflow.  It\n returns `(size_t)-1` then.\n\n @param[in]   val            Integer   or  integer-like   object  which   has\n                             `#to_int` method.\n @param[in]   word_numbits   Number of bits per word.\n @param[out]  nlz_bits_ret   Number  of   leading  zero  bits  in   the  most\n                             significant word is returned if not `NULL`.\n @exception   rb_eTypeError  `val` doesn't respond to `#to_int`.\n @retval      (size_t)-1     Overflowed.\n @retval      otherwise\n`((val_numbits * CHAR_BIT + word_numbits - 1) / word_numbits)`,\n              where val_numbits is the number of bits of `abs(val)`.\n @post        If  `nlz_bits_ret` is  not  `NULL` and  there  is no  overflow,\n              `(return_value * word_numbits - val_numbits)`   is  stored   in\n              `*nlz_bits_ret`.  In this case,\n              `0 <= *nlz_bits_ret < word_numbits.`\n"]
    pub fn rb_absint_numwords(val: VALUE, word_numbits: usize, nlz_bits_ret: *mut usize) -> usize;
}
extern "C" {
    #[doc = " Tests `abs(val)` consists only of a bit or not.\n\n @param[in]   val            Integer   or  integer-like   object  which   has\n                             `#to_int` method.\n @exception   rb_eTypeError  `val` doesn't respond to `#to_int`.\n @retval      1              `abs(val) == 1 << n` for some `n >= 0`.\n @retval      0              Otherwise.\n\n rb_absint_singlebit_p() can  be used to  determine required buffer  size for\n rb_integer_pack() used with #INTEGER_PACK_2COMP (two's complement).\n\n Following example  calculates number  of bits required  to represent  val in\n two's complement number, without sign bit.\n\n ```CXX\n   size_t size;\n   int neg = FIXNUM_P(val) ? FIX2LONG(val) < 0 : BIGNUM_NEGATIVE_P(val);\n   size = rb_absint_numwords(val, 1, NULL)\n   if (size == (size_t)-1) ...overflow...\n   if (neg && rb_absint_singlebit_p(val))\n     size--;\n ```\n\n Following example  calculates number of  bytes required to represent  val in\n two's complement number, with sign bit.\n\n ```CXX\n   size_t size;\n   int neg = FIXNUM_P(val) ? FIX2LONG(val) < 0 : BIGNUM_NEGATIVE_P(val);\n   int nlz_bits;\n   size = rb_absint_size(val, &nlz_bits);\n   if (nlz_bits == 0 && !(neg && rb_absint_singlebit_p(val)))\n     size++;\n ```"]
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Canonicalises the passed `val`, which is the return value of `a <=> b`, into\n C's `{-1, 0, 1}`.  This can be  handy when you implement a callback function\n to pass to `qsort(3)` etc.\n\n @param[in]  val           Return value of a space ship operator.\n @param[in]  a             Comparison LHS.\n @param[in]  b             Comparison RHS.\n @exception  rb_eArgError  `a` and `b` are not comparable each other.\n @retval     -1            `val` is less than zero.\n @retval     0             `val` is equal to zero.\n @retval     1             `val` is greater than zero."]
    pub fn rb_cmpint(val: VALUE, a: VALUE, b: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Raises \"comparison failed\" error.\n\n @param[in]  a             Comparison LHS.\n @param[in]  b             Comparison RHS.\n @exception  rb_eArgError  `a` and `b` are not comparable each other."]
    pub fn rb_cmperr(a: VALUE, b: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical  to rb_complex_new(),  except it  assumes both  arguments are  not\n instances of ::rb_cComplex.  It is thus dangerous for extension libraries.\n\n @param[in]  real  Real part, in any numeric except Complex.\n @param[in]  imag  Imaginary part, in any numeric except Complex.\n @return     An instance of ::rb_cComplex whose value is `real + (imag)i`."]
    pub fn rb_complex_raw(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Constructs a Complex, by first multiplying the imaginary part with `1i` then\n adds it  to the real part.   This definition doesn't need  both arguments be\n real numbers.  It  can happily combine two instances  of ::rb_cComplex (with\n rotating the latter one).\n\n @param[in]  real  An instance of ::rb_cNumeric.\n @param[in]  imag  Another instance of ::rb_cNumeric.\n @return     An instance of ::rb_cComplex whose value is `imag * 1i + real`."]
    pub fn rb_complex_new(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Constructs a  Complex using polar representations.   Unlike rb_complex_new()\n it makes no sense to pass non-real instances to this function.\n\n @param[in]  abs  Magnitude, in any numeric except Complex.\n @param[in]  arg  Angle, in radians, in any numeric except Complex.\n @return     An  instance  of ::rb_cComplex  which  denotes  the given  polar\n             coordinates."]
    pub fn rb_complex_new_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @old{rb_complex_new_polar}"]
    pub fn rb_complex_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the real part of the passed Complex.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     Its real part, which is an instance of ::rb_cNumeric."]
    pub fn rb_complex_real(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the imaginary part of the passed Complex.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     Its imaginary part, which is an instance of ::rb_cNumeric."]
    pub fn rb_complex_imag(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs addition of the passed two objects.\n\n @param[in]  x  An instance of ::rb_cComplex.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x + y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_complex_plus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs subtraction of the passed two objects.\n\n @param[in]  x  An instance of ::rb_cComplex.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x - y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_complex_minus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs multiplication of the passed two objects.\n\n @param[in]  x  An instance of ::rb_cComplex.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x * y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_complex_mul(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs division of the passed two objects.\n\n @param[in]  x  An instance of ::rb_cComplex.\n @param[in]  y  Arbitrary ruby object.\n @return     What `x / y` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_complex_div(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs negation of the passed object.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     What `-z` evaluates to."]
    pub fn rb_complex_uminus(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs complex conjugation of the passed object.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     Its complex conjugate, in ::rb_cComplex."]
    pub fn rb_complex_conjugate(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the absolute (or the magnitude) of the passed object.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     Its magnitude, in ::rb_cFloat."]
    pub fn rb_complex_abs(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the argument (or the angle) of the passed object.\n\n @param[in]  z  An instance of ::rb_cComplex.\n @return     Its magnitude, in ::rb_cFloat."]
    pub fn rb_complex_arg(z: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Performs exponentiation of the passed two objects.\n\n @param[in]  base  An instance of ::rb_cComplex.\n @param[in]  exp   Arbitrary ruby object.\n @return     What `base ** exp` evaluates to.\n @see        rb_num_coerce_bin()"]
    pub fn rb_complex_pow(base: VALUE, exp: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_complex_new(),  except it takes the arguments  as C's double\n instead of Ruby's object.\n\n @param[in]  real  Real part.\n @param[in]  imag  Imaginary part.\n @return     An instance of ::rb_cComplex whose value is `real + (imag)i`."]
    pub fn rb_dbl_complex_new(real: f64, imag: f64) -> VALUE;
}
extern "C" {
    #[doc = " Converts various values into a Complex.  This function accepts:\n\n - Instances of ::rb_cComplex (taken as-is),\n - Instances of ::rb_cNumeric (adds `0i`),\n - Instances of ::rb_cString  (parses),\n - Other objects that respond to `#to_c`.\n\n It (possibly recursively) applies `#to_c`  until both sides become a Complex\n value, then computes `imag * 1i + real`.\n\n As a  special case, passing ::RUBY_Qundef  to `imag` is the  same as passing\n `RB_INT2NUM(0)`.\n\n @param[in]  real           Real part (see above).\n @param[in]  imag           Imaginary part (see above).\n @exception  rb_eTypeError  Passed something not described above.\n @return     An instance of ::rb_cComplex whose value is `1i * imag + real`.\n\n @internal\n\n This was the implementation of `Kernel#Complex` before, but they diverged."]
    pub fn rb_Complex(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a Fiber instance from a C-backended block.\n\n @param[in]  func          A function, to become the fiber's body.\n @param[in]  callback_obj  Passed as-is to `func`.\n @return     An allocated  new instance  of rb_cFiber, which  is ready  to be\n             \"resume\"d."]
    pub fn rb_fiber_new(func: rb_block_call_func_t, callback_obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a Fiber instance from a C-backended block with the specified\n storage.\n\n If the given storage is Qundef or Qtrue, this function is equivalent to\n rb_fiber_new() which inherits storage from the current fiber.\n\n If the given storage is Qfalse, this function uses the current fiber's\n storage by reference.\n\n Specifying either Qtrue or Qfalse is experimental and may be changed in the\n future.\n\n If the given storage is Qnil, this function will lazy initialize the\n internal storage which starts of empty (without any inheritance).\n\n Otherwise, the given storage is used as the internal storage.\n\n @param[in]  func          A function, to become the fiber's body.\n @param[in]  callback_obj  Passed as-is to `func`.\n @param[in]  storage       The way to set up the storage for the fiber.\n @return     An allocated  new instance  of rb_cFiber, which  is ready  to be\n             \"resume\"d."]
    pub fn rb_fiber_new_storage(
        func: rb_block_call_func_t,
        callback_obj: VALUE,
        storage: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Queries  the fiber  which  is  calling this  function.   Any ruby  execution\n context has its fiber, either explicitly or implicitly.\n\n @return  The current fiber."]
    pub fn rb_fiber_current() -> VALUE;
}
extern "C" {
    #[doc = " Queries the  liveness of the  passed fiber.   \"Alive\" in this  context means\n that  the fiber  can  still be  resumed.   Once  it reaches  is  its end  of\n execution, this function returns ::RUBY_Qfalse.\n\n @param[in]  fiber        A target fiber.\n @retval     RUBY_Qtrue   It is.\n @retval     RUBY_Qfalse  It isn't."]
    pub fn rb_fiber_alive_p(fiber: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if an object is a fiber.\n\n @param[in]  obj          Arbitrary ruby object.\n @retval     RUBY_Qtrue   It is.\n @retval     RUBY_Qfalse  It isn't."]
    pub fn rb_obj_is_fiber(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resumes the  execution of the passed  fiber, either from the  point at which\n the last  rb_fiber_yield() was  called if  any, or at  the beginning  of the\n fiber body if it is the first call to this function.\n\n Other arguments are passed into the fiber's body, either as return values of\n rb_fiber_yield() in case it switches to  there, or as the block parameter of\n the fiber body if it switches to the beginning of the fiber.\n\n The return  value of this  function is either  the value passed  to previous\n rb_fiber_yield() call, or  the ultimate evaluated value of  the entire fiber\n body if the execution reaches the end of it.\n\n When an exception happens inside of a fiber it propagates to this function.\n\n ```ruby\n f = Fiber.new do |i|\n   puts \"<x> =>> #{i}\"\n   puts \"<y> <-- #{i + 1}\"\n   j = Fiber.yield(i + 1)\n   puts \"<z> =>> #{j}\"\n   puts \"<w> <-- #{j + 1}\"\n   next j + 1\n end\n\n puts \"[a] <-- 1\"\n p = f.resume(1)\n puts \"[b] =>> #{p}\"\n puts \"[c] <-- #{p + 1}\"\n q = f.resume(p + 1)\n puts \"[d] =>> #{q}\"\n ```\n\n Above program executes in `[a] <x> <y> [b] [c] <z> <w> [d]`.\n\n @param[out]  fiber          The fiber to resume.\n @param[in]   argc            Number of objects of `argv`.\n @param[in]   argv            Passed (somehow) to `fiber`.\n @exception   rb_eFiberError  `fib` is terminated etc.\n @exception   rb_eException   Any exceptions happen in `fiber`.\n @return      (See above)\n @note        This function _does_ return.\n\n @internal\n\n @shyouhei  expected  this function  to  raise  ::rb_eFrozenError for  frozen\n fibers but it doesn't in practice.  Intentional or ...?"]
    pub fn rb_fiber_resume(fiber: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_fiber_resume(), except  you can specify  how to  handle the\n last element of the given array.\n\n @param[out]  fiber           The fiber to resume.\n @param[in]   argc            Number of objects of `argv`.\n @param[in]   argv            Passed (somehow) to `fiber`.\n @param[in]   kw_splat        Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception   rb_eFiberError  `fiber` is terminated etc.\n @exception   rb_eException   Any exceptions happen in `fiber`.\n @return      Either what was yielded or the last value of the fiber body."]
    pub fn rb_fiber_resume_kw(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Yields the  control back to the  point where the current  fiber was resumed.\n The passed  objects would  be the return  value of  rb_fiber_resume().  This\n fiber then suspends its execution until next time it is resumed.\n\n This function can  also raise arbitrary exceptions injected  from outside of\n the fiber using rb_fiber_raise().\n\n ```ruby\n exc = Class.new Exception\n\n f = Fiber.new do\n   Fiber.yield\n rescue exc => e\n   puts e.message\n end\n\n f.resume\n f.raise exc, \"Hi!\"\n ```\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Passed to rb_fiber_resume().\n @exception  rb_eException  (See above)\n @return     (See rb_fiber_resume() for details)"]
    pub fn rb_fiber_yield(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_fiber_yield(), except you can specify how to handle the last\n element of the given array.\n\n @param[in]  argc            Number of objects of `argv`.\n @param[in]  argv            Passed to rb_fiber_resume().\n @param[in]  kw_splat        Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eException   What was raised using `Fiber#raise`.\n @return     (See rb_fiber_resume() for details)"]
    pub fn rb_fiber_yield_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Transfers control to  another fiber, resuming it from where  it last stopped\n or starting  it if  it was not  resumed before.  The  calling fiber  will be\n suspended much like in a call to rb_fiber_yield().\n\n The fiber  which receives  the transfer  call treats it  much like  a resume\n call.  Arguments passed to transfer are treated like those passed to resume.\n\n The two style of control passing to and from fiber (one is rb_fiber_resume()\n and  rb_fiber_yield(), another  is  rb_fiber_transfer() to  and from  fiber)\n can't be freely mixed.\n\n   - If the  Fiber's lifecycle had  started with  transfer, it will  never be\n     able to  yield or be  resumed control  passing, only finish  or transfer\n     back.   (It  still can  resume  other  fibers  that  are allowed  to  be\n     resumed.)\n\n   - If  the Fiber's  lifecycle  had started  with resume,  it  can yield  or\n     transfer to  another Fiber, but  can receive  control back only  the way\n     compatible with  the way it  was given away:  if it had  transferred, it\n     only can  be transferred  back, and if  it had yielded,  it only  can be\n     resumed back.  After that, it again can transfer or yield.\n\n If those rules are broken, rb_eFiberError is raised.\n\n For an  individual Fiber design,  yield/resume is  easier to use  (the Fiber\n just gives away control,  it doesn't need to think about  who the control is\n given to),  while transfer is more  flexible for complex cases,  allowing to\n build arbitrary graphs of Fibers dependent on each other.\n\n @param[out]  fiber           Explicit control destination.\n @param[in]   argc            Number of objects of `argv`.\n @param[in]   argv            Passed to rb_fiber_resume().\n @exception   rb_eFiberError  (See above)\n @exception   rb_eException   What was raised using `Fiber#raise`.\n @return      (See rb_fiber_resume() for details)"]
    pub fn rb_fiber_transfer(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_fiber_transfer(),  except you can specify how  to handle the\n last element of the given array.\n\n @param[out]  fiber           Explicit control destination.\n @param[in]   argc            Number of objects of `argv`.\n @param[in]   argv            Passed to rb_fiber_resume().\n @param[in]   kw_splat        Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception   rb_eFiberError  (See above)\n @exception   rb_eException   What was raised using `Fiber#raise`.\n @return      (See rb_fiber_resume() for details)"]
    pub fn rb_fiber_transfer_kw(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_fiber_resume()  but instead of resuming  normal execution of\n the passed fiber, it  raises the given exception in it.   From inside of the\n fiber this would be seen as if rb_fiber_yield() raised.\n\n This function  does return in case  the passed fiber gracefully  handled the\n passed exception.  But  if it does not, the raised  exception propagates out\n of the passed fiber; this function then does not return.\n\n Parameters are passed to rb_make_exception()  to create an exception object.\n See its document for what are allowed here.\n\n It is  a failure to  call this function against  a fiber which  is resuming,\n have never run yet, or has already finished running.\n\n @param[out]  fiber           Where exception is raised.\n @param[in]   argc            Passed as-is to rb_make_exception().\n @param[in]   argv            Passed as-is to rb_make_exception().\n @exception   rb_eFiberError  `fiber` is terminated etc.\n @return      (See rb_fiber_resume() for details)"]
    pub fn rb_fiber_raise(fiber: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the path of the current working directory of the current process.\n\n @return  An instance of ::rb_cString that holds the working directory.\n @note    The returned string  is in \"filesystem\" encoding.   Most notably on\n          Linux this is an alias  of default external encoding.  Most notably\n          on Windows it can be an alias of OS codepage."]
    pub fn rb_dir_getwd() -> VALUE;
}
extern "C" {
    #[doc = " Basically identical to rb_ary_new_form_values(), except it returns something\n different when `argc` < 2.\n\n @param[in]  argc       Number of objects of `argv`.\n @param[in]  argv       Arbitrary objects.\n @retval     RUBY_Qnil  `argc` is zero.\n @retval     argv[0]    `argc` is one.\n @retval     otherwise  Otherwise.\n\n @internal\n\n What  is this  business?   Well,  this function  is  about `yield`'s  taking\n multiple values.  Consider following user-defined class:\n\n ```ruby\n class Foo\n   include Enumerable\n\n   def each\n     yield :q, :w, :e, :r\n   end\n end\n\n Foo.new.each_with_object([]) do |i, j|\n   j << i                      # ^^^ <- What to expect for `i`?\n end\n ```\n\n Here, `Foo#each_with_object` is in fact `Enumerable#each_with_object`, which\n doesn't know what would be yielded.  Yet, it has to take a block of arity 2.\n This function  is used here, to  \"pack\" arbitrary number of  yielded objects\n into one.\n\n If people want to implement their own `Enumerable#each_with_object` this API\n can be handy.  Though @shyouhei suspects it is relatively rare for 3rd party\n extension libraries  to have  such things.  Also  `Enumerable#each_entry` is\n basically this function exposed as a Ruby method."]
    pub fn rb_enum_values_pack(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_raise(), except it  raises the passed exception instance as-\n is instead of creating new one.\n\n @param[in]  exc            An instance of a subclass of ::rb_eException.\n @exception  exc            What is passed.\n @exception  rb_eTypeError  `exc` is not an exception.\n @note       It never returns.\n\n @internal\n\n Wellll  actually, it  can  take more  than what  is  described above.   This\n function tries  to call `exception`  method of  the passed object.   If that\n function returns an exception object that is used instead."]
    pub fn rb_exc_raise(exc: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical to rb_fatal(), except it  raises the passed exception instance as-\n is instead of creating new one.\n\n @param[in]  exc  An instance of a subclass of ::rb_eException.\n @exception  exc  What is passed.\n @note       It never returns.\n\n @internal\n\n You know  what...?  Using this API  you can make arbitrary  exceptions, like\n `RuntimeError`, that doesn't  interface with `rescue` clause.   This is very\n confusing."]
    pub fn rb_exc_fatal(exc: VALUE) -> !;
}
extern "C" {
    #[doc = " Identical to rb_exit(), except how arguments are passed.\n\n @param[in]  argc            Number of objects of `argv`.\n @param[in]  argv            Contains at most one of the following:\n                               - ::RUBY_Qtrue - means `EXIT_SUCCESS`.\n                               - ::RUBY_Qfalse - means `EXIT_FAILURE`.\n                               - Numerical value - takes that value.\n @exception  rb_eArgError    Wrong `argc`.\n @exception  rb_eSystemExit  Exception representing the exit status.\n @note       It never returns."]
    pub fn rb_f_exit(argc: ::std::os::raw::c_int, argv: *const VALUE) -> !;
}
extern "C" {
    #[doc = " This is  similar to rb_f_exit().   In fact  on some situation  it internally\n calls rb_exit().  But can be very esoteric on occasions.\n\n It takes up to one argument.  If  an argument is passed, it tries to display\n that.   Otherwise if  there is  `$!`, displays  that exception  instead.  It\n finally raise ::rb_eSystemExit in both cases.\n\n @param[in]  argc            Number of objects of `argv`.\n @param[in]  argv            Contains at most one string-ish object.\n @exception  rb_eArgError    Wrong `argc`.\n @exception  rb_eTypeError   No conversion from `argv[0]` to String.\n @exception  rb_eSystemExit  Exception representing `EXIT_FAILURE`.\n @note       It never returns."]
    pub fn rb_f_abort(argc: ::std::os::raw::c_int, argv: *const VALUE) -> !;
}
extern "C" {
    #[doc = " Raises an instance of ::rb_eInterrupt.\n\n @exception  rb_eInterrupt  Always raises this exception.\n @note       It never returns."]
    pub fn rb_interrupt() -> !;
}
extern "C" {
    #[doc = " Queries the  name of the  Ruby level method  that is calling  this function.\n The \"name\" in this context is the one assigned to the function for the first\n time (note that methods can have multiple names via aliases).\n\n @retval  0          There is no method (e.g. toplevel context).\n @retval  otherwise  The name of the current method."]
    pub fn rb_frame_this_func() -> ID;
}
extern "C" {
    #[doc = " This function  is to re-throw  global escapes.  Such global  escapes include\n exceptions, `throw`, `break`, for example.\n\n It makes  sense only  when used  in conjunction  with \"protect\"  series APIs\n e.g.  rb_protect(),  rb_load_protect(), rb_eval_string_protect(),  etc.   In\n case  these functions  experience  global escapes,  they  fill their  opaque\n `state` return  buffer.  You  can ignore  such escapes.   But if  you decide\n otherwise, you have to somehow escape globally again.  This function is used\n for that purpose.\n\n @param[in]  state  Opaque state of execution.\n @note       It never returns.\n\n @internal\n\n Though  not  a  part  of  our  public  API,  `state`  is  in  fact  an  enum\n ruby_tag_type.  You can see the potential values by looking at vm_core.h."]
    pub fn rb_jump_tag(state: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Calls `initialize`  method of the  passed object with the  passed arguments.\n It also forwards the implicitly passed block to the method.\n\n @param[in]  obj            Receiver object.\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Passed as-is to `obj.initialize`.\n @exception  rb_eException  Any exceptions happen inside."]
    pub fn rb_obj_call_init(obj: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE);
}
extern "C" {
    #[doc = " Identical to  rb_obj_call_init(), except you  can specify how to  handle the\n last element of the given array.\n\n @param[in]  obj                Receiver object.\n @param[in]  argc               Number of objects of `argv`.\n @param[in]  argv               Passed as-is to `obj.initialize`.\n @param[in]  kw_splat           Handling of keyword parameters:\n   - RB_NO_KEYWORDS             `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS           `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS    it depends if there is a passed block.\n @exception  rb_eNoMethodError  No such method.\n @exception  rb_eException      Any exceptions happen inside."]
    pub fn rb_obj_call_init_kw(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const VALUE,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Identical to rb_frame_this_func(), except it  returns the named used to call\n the method.\n\n @retval  0          There is no method (e.g. toplevel context).\n @retval  otherwise  The name of the current method."]
    pub fn rb_frame_callee() -> ID;
}
extern "C" {
    #[doc = " Constructs  an exception  object from  the list  of arguments,  in a  manner\n similar to Ruby's `raise`.  This function can take:\n\n   - No arguments  at all,  i.e. `argc  == 0`.   This is  not a  failure.  It\n     returns ::RUBY_Qnil then.\n\n   - An  object, which  is  an instance  of ::rb_cString.   In  this case  an\n     instance of  ::rb_eRuntimeError whose  message is  the passed  string is\n     created then returned.\n\n   - An  object, which  responds to  `exception` method,  and optionally  its\n     argument,  and  optionally  its  backtrace.  For  example  instances  of\n     subclasses of ::rb_eException  have this method.  What  is returned from\n     the method is returned.\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           0 up to 3 objects.\n @exception  rb_eArgError   Wrong `argc`.\n @exception  rb_eTypeError  `argv[0].exception` returned non-exception.\n @return     An instance of a subclass of ::rb_eException.\n\n @internal\n\n Historically  this was  _the_  way  `raise` converted  its  arguments to  an\n exception.  However they diverged."]
    pub fn rb_make_exception(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Registers a function  that shall run on process  exit.  Registered functions\n run in  reverse-chronological order,  mixed with  syntactic `END`  block and\n `Kernel#at_exit`.\n\n @param[in]  func  Function to run at process exit.\n @param[in]  arg   Passed as-is to `func`."]
    pub fn rb_set_end_proc(
        func: ::std::option::Option<unsafe extern "C" fn(arg: VALUE)>,
        arg: VALUE,
    );
}
#[doc = " This is the type of functions that rb_enumeratorize_with_size() expects.  In\n theory an enumerator can have indefinite number of elements, but in practice\n it often is  the case we can  compute the size of  an enumerator beforehand.\n If your enumerator has such property, supply a function that calculates such\n values.\n\n @param[in]  recv  The original receiver of the enumerator.\n @param[in]  argv  Arguments passed to `Object#enum_for` etc.\n @param[in]  eobj  The enumerator object.\n @return     The size of `eobj`, in ::rb_cNumeric, or ::RUBY_Qnil if the size\n             is not known until we actually iterate."]
pub type rb_enumerator_size_func =
    ::std::option::Option<unsafe extern "C" fn(recv: VALUE, argv: VALUE, eobj: VALUE) -> VALUE>;
#[doc = " Decomposed   `Enumerator::ArithmeicSequence`.   This   is   a  subclass   of\n ::rb_cEnumerator,  which  represents  a  sequence  of  numbers  with  common\n difference.  Internal  data structure of the  class is opaque to  users, but\n you can obtain a decomposed one using rb_arithmetic_sequence_extract()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_arithmetic_sequence_components_t {
    #[doc = "< \"Left\" or \"lowest\" endpoint of the sequence."]
    pub begin: VALUE,
    #[doc = "< \"Right\" or \"highest\" endpoint of the sequence."]
    pub end: VALUE,
    #[doc = "< Step between a sequence."]
    pub step: VALUE,
    #[doc = "< Whether the endpoint is open or closed."]
    pub exclude_end: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_arithmetic_sequence_components_t() {
    const UNINIT: ::std::mem::MaybeUninit<rb_arithmetic_sequence_components_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rb_arithmetic_sequence_components_t>(),
        16usize,
        concat!("Size of: ", stringify!(rb_arithmetic_sequence_components_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_arithmetic_sequence_components_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rb_arithmetic_sequence_components_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_arithmetic_sequence_components_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_arithmetic_sequence_components_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_arithmetic_sequence_components_t),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclude_end) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_arithmetic_sequence_components_t),
            "::",
            stringify!(exclude_end)
        )
    );
}
extern "C" {
    #[doc = " Constructs an enumerator.  This roughly resembles `Object#enum_for`.\n\n @param[in]  recv           A receiver of `meth`.\n @param[in]  meth           Method ID in a symbol object.\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arguments passed to `meth`.\n @exception  rb_eTypeError  `meth` is not an instance of ::rb_cSymbol.\n @return     A  new   instance  of  ::rb_cEnumerator  which,   when  yielded,\n             enumerates by calling `meth` on `recv` with `argv`."]
    pub fn rb_enumeratorize(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_enumeratorize(),  except you  can additionally  specify the\n size function of return value.\n\n @param[in]  recv           A receiver of `meth`.\n @param[in]  meth           Method ID in a symbol object.\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arguments passed to `meth`.\n @param[in]  func           Size calculator.\n @exception  rb_eTypeError  `meth` is not an instance of ::rb_cSymbol.\n @return     A  new   instance  of  ::rb_cEnumerator  which,   when  yielded,\n             enumerates by calling `meth` on `recv` with `argv`.\n @note       `func` can be zero, which means the size is unknown."]
    pub fn rb_enumeratorize_with_size(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: rb_enumerator_size_func,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_enumeratorize_with_func(),  except you  can specify  how to\n handle the last element of the given array.\n\n @param[in]  recv             A receiver of `meth`.\n @param[in]  meth             Method ID in a symbol object.\n @param[in]  argc             Number of objects of `argv`.\n @param[in]  argv             Arguments passed to `meth`.\n @param[in]  func             Size calculator.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eTypeError    `meth` is not an instance of ::rb_cSymbol.\n @return     A  new   instance  of  ::rb_cEnumerator  which,   when  yielded,\n             enumerates by calling `meth` on `recv` with `argv`.\n @note       `func` can be zero, which means the size is unknown."]
    pub fn rb_enumeratorize_with_size_kw(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: rb_enumerator_size_func,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Extracts components of the passed arithmetic  sequence.  This can be seen as\n an extended version of rb_range_values().\n\n @param[in]   as   Target instance of `Enumerator::ArithmericSequence`.\n @param[out]  buf  Decomposed results buffer.\n @return      0    `as` is not `Enumerator::ArithmericSequence`.\n @return      1    Success.\n @post        `buf` is filled."]
    pub fn rb_arithmetic_sequence_extract(
        as_: VALUE,
        buf: *mut rb_arithmetic_sequence_components_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical   to  rb_range_beg_len(),   except   it  takes   an  instance   of\n `Enumerator::ArithmericSequence`.\n\n @param[in]   as              An `Enumerator::ArithmericSequence` instance.\n @param[out]  begp            Return value buffer.\n @param[out]  lenp            Return value buffer.\n @param[out]  stepp           Return value buffer.\n @param[in]   len             Updated length.\n @param[in]   err             In case `len` is out of range...\n                                - `0`: returns ::RUBY_Qnil.\n                                - `1`: raises  ::rb_eRangeError.\n                                - `2`: `beg` and `len` expanded accordingly.\n @exception   rb_eRangeError  `as` cannot fit into `long`.\n @retval      RUBY_Qfalse     `as` is not `Enumerator::ArithmericSequence`.\n @retval      RUBY_Qnil       `len` is out of `as` but `err` is zero.\n @retval      RUBY_Qtrue      Otherwise.\n @post        `beg` is the (possibly updated) left endpoint.\n @post        `len` is the (possibly updated) length of the range.\n\n @internal\n\n Currently no 3rd party applications of this function is found.  But that can\n be because this function is relatively new."]
    pub fn rb_arithmetic_sequence_beg_len_step(
        as_: VALUE,
        begp: *mut ::std::os::raw::c_long,
        lenp: *mut ::std::os::raw::c_long,
        stepp: *mut ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        err: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_file_expand_path(), except how arguments are passed.\n\n @param[in]  argc                Number of objects of `argv`.\n @param[in]  argv                Filename, and base directory, in that order.\n @exception  rb_eArgError        Wrong `argc`.\n @exception  rb_eTypeError       Non-string passed.\n @exception  rb_eEncCompatError  No conversion from arguments to a path.\n @return     Expanded path.\n\n @internal\n\n It seems nobody actually uses this function right now.  Maybe delete it?"]
    pub fn rb_file_s_expand_path(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_file_absolute_path(),  except  it additionally  understands\n `~`.  If a given pathname starts  with `~someone/`, that part expands to the\n user's home directory (or that of current process' owner's in case of `~/`).\n\n @param[in]  fname               Relative file name.\n @param[in]  dname               Lookup  base  directory  name,  or  in  case\n                                 ::RUBY_Qnil is  passed the  process' current\n                                 working directory is assumed.\n @exception  rb_eArgError        Home directory is not absolute.\n @exception  rb_eTypeError       Non-string passed.\n @exception  rb_eEncCompatError  No conversion from arguments to a path.\n @return     Expanded path."]
    pub fn rb_file_expand_path(fname: VALUE, dname: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_file_absolute_path(), except how arguments are passed.\n\n @param[in]  argc                Number of objects of `argv`.\n @param[in]  argv                Filename, and base directory, in that order.\n @exception  rb_eArgError        Wrong `argc`.\n @exception  rb_eTypeError       Non-string passed.\n @exception  rb_eEncCompatError  No conversion from arguments to a path.\n @return     Expanded path.\n\n @internal\n\n It seems nobody actually uses this function right now.  Maybe delete it?"]
    pub fn rb_file_s_absolute_path(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Maps a  relative path  to its absolute  representation.  Relative  paths are\n referenced  from the  passed directory  name, or  from the  process' current\n working directory in case ::RUBY_Qnil is passed.\n\n @param[in]  fname               Relative file name.\n @param[in]  dname               Lookup  base  directory  name,  or  in  case\n                                 ::RUBY_Qnil is  passed the  process' current\n                                 working directory is assumed.\n @exception  rb_eArgError        Strings contain NUL bytes.\n @exception  rb_eTypeError       Non-string passed.\n @exception  rb_eEncCompatError  No conversion from arguments to a path.\n @return     Expanded path."]
    pub fn rb_file_absolute_path(fname: VALUE, dname: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Strips a file path's last component  (and trailing separators if any).  This\n function is relatively  simple on POSIX environments; just  splits the input\n with  `/`, strips  the  last one,  if something  remains  joins them  again,\n otherwise the return value is `\".\"`.   However when it comes to Windows this\n function is  quite very  much complicated.   We have to  take UNC  etc. into\n account.  So for instance `\"C:foo\"`'s dirname is `\"C:.\"`.\n\n @param[in]  fname               File name to strip.\n @exception  rb_eTypeError       `fname` is not a String.\n @exception  rb_eArgError        `fname` contains NUL bytes.\n @exception  rb_eEncCompatError  `fname`'s encoding is not path-compat.\n @return     A dirname of `fname`.\n @note       This is a \"pure\" operation;  it computes the return value solely\n             from the passed object and never does any file IO."]
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resolves a  feature's path.  This  function takes for instance  `\"json\"` and\n `[\".so\", \".rb\"]`,  and iterates  over the  `$LOAD_PATH` to  see if  there is\n either `json.so` or `json.rb` in the directory.\n\n This is not what everything `require`  does, but at least `require` is built\n on top of it.\n\n @param[in,out]  feature             File to search, and return buffer.\n @param[in]      exts                List of file extensions.\n @exception      rb_eTypeError       `feature` is not a String.\n @exception      rb_eArgError        `feature` contains NUL bytes.\n @exception      rb_eEncCompatError  `feature`'s encoding is not path-compat.\n @retval         0                   Not found\n @retval         otherwise           Found index in `ext`, plus one.\n @post           `*feature` is a resolved path."]
    pub fn rb_find_file_ext(
        feature: *mut VALUE,
        exts: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical  to rb_find_file_ext(),  except it  takes  a feature  name and  is\n extension  at once,  e.g. `\"json.rb\"`.   This  difference is  much like  how\n `require` and `load` are different.\n\n @param[in]  path                A path relative to `$LOAD_PATH`.\n @exception  rb_eTypeError       `path` is not a String.\n @exception  rb_eArgError        `path` contains NUL bytes.\n @exception  rb_eEncCompatError  `path`'s encoding is not path-compat.\n @return     Expanded path."]
    pub fn rb_find_file(path: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries  if  the  given path  is  either  a  directory,  or a  symlink  that\n (potentially recursively) points to such thing.\n\n @param[in]  _                   Ignored (why...?)\n @param[in]  path                String,  or IO.   In  case of  IO it  issues\n                                 `fstat(2)` instead of `stat(2)`.\n @exception  rb_eFrozenError     `path` is a frozen IO (why...?)\n @exception  rb_eTypeError       `path` is neither String nor IO.\n @exception  rb_eArgError        `path` contains NUL bytes.\n @exception  rb_eEncCompatError  `path`'s encoding is not path-compat.\n @retval     RUBY_Qtrue          `path` is a directory.\n @retval     RUBY_Qfalse         Otherwise."]
    pub fn rb_file_directory_p(__: VALUE, path: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts a  string into an  \"OS Path\" encoding,  if any.  In  most operating\n systems there are  no such things like per-OS default  encoding of filename.\n For them this  function is no-op.  However most notably  on MacOS, pathnames\n are UTF-8 encoded.  It converts the given string into such encoding.\n\n @param[in]  path                An instance of ::rb_cString.\n @exception  rb_eEncCompatError  `path`'s encoding is not path-compat.\n @return     `path`'s contents converted to the OS' path encoding."]
    pub fn rb_str_encode_ospath(path: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given path is an  absolute path.  On POSIX environments it is\n as easy  as `path[0]  == '/'`.   However on Windows,  drive letters  and UNC\n paths are also taken into account.\n\n @param[in]  path  A possibly relative path string.\n @retval     1     `path` is absolute.\n @retval     0     `path` is relative."]
    pub fn rb_is_absolute_path(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries  the file  size  of the  given file.   Because  this function  calls\n `fstat(2)`  internally, it  is  a failure  to  pass a  closed  file to  this\n function.\n\n This function flushes the passed file's buffer if any.  Can take time.\n\n @param[in]   file                 A file object.\n @exception   rb_eFrozenError      `file` is frozen.\n @exception   rb_eIOError          `file` is closed.\n @exception   rb_eSystemCallError  Permission denied etc.\n @exception   rb_eNoMethodError    The given non-file object doesn't respond\n                                   to `#size`.\n @return      The size of the passed file.\n @note        Passing a non-regular file such as a UNIX domain socket to this\n              function  is   not  a  failure.    But  the  return   value  is\n              unpredictable.  POSIX's `<sys/stat.h>` states  that \"the use of\n              this field is unspecified\" then."]
    pub fn rb_file_size(file: VALUE) -> off_t;
}
extern "C" {
    #[doc = " Triggers out-of-memory error.  If  possible it raises ::rb_eNoMemError.  But\n because  we are  running out  of  memory that  is not  always doable.   This\n function tries hard to show something, but ultimately can die silently.\n\n @exception  rb_eNoMemError  Raises it if possible."]
    pub fn rb_memerror() -> !;
}
extern "C" {
    #[doc = " Queries if the GC is busy.\n\n @retval  0  It isn't.\n @retval  1  It is."]
    pub fn rb_during_gc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Marks  objects between  the two  pointers.  This  is one  of the  GC utility\n functions    that   you    can    call   when    you    design   your    own\n ::rb_data_type_struct::dmark.\n\n @pre         Continuous memory region  from `start` to `end`  shall be fully\n              addressable.\n @param[out]  start  Pointer to an array of objects.\n @param[out]  end    Pointer that terminates the array of objects.\n @post        Objects from `start` to `end`, both inclusive, are marked.\n\n @internal\n\n `end` can be NULL...  But that just results in no-op."]
    pub fn rb_gc_mark_locations(start: *const VALUE, end: *const VALUE);
}
extern "C" {
    #[doc = " Identical to  rb_mark_hash(), except it marks  only values of the  table and\n leave  their  associated keys  unmarked.  This  is  one  of the  GC  utility\n functions    that   you    can    call   when    you    design   your    own\n ::rb_data_type_struct::dmark.\n\n @warning    Of course it can break GC.  Leave it unused if unsure.\n @param[in]  tbl  A table to mark.\n @post       Values stored in `tbl` are marked."]
    pub fn rb_mark_tbl(tbl: *mut st_table);
}
extern "C" {
    #[doc = " Identical    to   rb_mark_tbl(),    except    it    marks   objects    using\n rb_gc_mark_movable().  This is one of the  GC utility functions that you can\n call when you design your own ::rb_data_type_struct::dmark.\n\n @warning    Of course it can break GC.  Leave it unused if unsure.\n @param[in]  tbl  A table to mark.\n @post       Values stored in `tbl` are marked."]
    pub fn rb_mark_tbl_no_pin(tbl: *mut st_table);
}
extern "C" {
    #[doc = " Identical to  rb_mark_hash(), except  it marks  only keys  of the  table and\n leave  their associated  values unmarked.   This is  one of  the GC  utility\n functions    that   you    can    call   when    you    design   your    own\n ::rb_data_type_struct::dmark.\n\n @warning    Of course it can break GC.  Leave it unused if unsure.\n @param[in]  tbl  A table to mark.\n @post       Keys stored in `tbl` are marked."]
    pub fn rb_mark_set(tbl: *mut st_table);
}
extern "C" {
    #[doc = " Marks keys and values  associated inside of the given table.  This is one of\n the  GC  utility functions  that  you  can call  when  you  design your  own\n ::rb_data_type_struct::dmark.\n\n @param[in]  tbl  A table to mark.\n @post       Objects stored in `tbl` are marked."]
    pub fn rb_mark_hash(tbl: *mut st_table);
}
extern "C" {
    #[doc = " Updates  references  inside  of  tables.   After  you  marked  values  using\n rb_mark_tbl_no_pin(), the  objects inside  of the table  could of  course be\n moved.  This function is to fixup  those references.  You can call this from\n your ::rb_data_type_struct::dcompact.\n\n @param[out]  ptr  A table that potentially includes moved references.\n @post        Moved references, if any, are corrected."]
    pub fn rb_gc_update_tbl_refs(ptr: *mut st_table);
}
extern "C" {
    #[doc = " Identical  to  rb_gc_mark(),  except  it   allows  the  passed  value  be  a\n non-object.  For instance  pointers to different type of  memory regions are\n allowed here.   Such values  are silently  ignored.  This is  one of  the GC\n utility   functions  that   you  can   call   when  you   design  your   own\n ::rb_data_type_struct::dmark.\n\n @param[out]  obj  A possible object.\n @post        `obj` is marked, if possible."]
    pub fn rb_gc_mark_maybe(obj: VALUE);
}
extern "C" {
    #[doc = " Marks an object.  This is one of  the GC utility functions that you can call\n when you design your own ::rb_data_type_struct::dmark.\n\n @param[out]  obj  Arbitrary Ruby object.\n @post        `obj` is marked."]
    pub fn rb_gc_mark(obj: VALUE);
}
extern "C" {
    #[doc = " Maybe this  is the only  function provided for  C extensions to  control the\n pinning of objects, so  let us describe it in detail.   These days Ruby's GC\n is copying.  As far as an object's physical address is guaranteed unused, it\n can move  around the object space.   Our GC engine rearranges  these objects\n after it  reclaims unreachable objects  from our  object space, so  that the\n space  is   compact  (improves  memory   locality).   This  is   called  the\n \"compaction\" phase, and works  well most of the time... as  far as there are\n no C  extensions.  C  extensions complicate the  scenario because  Ruby core\n cannot detect  any use  of the  physical address  of an  object inside  of C\n functions.  In order to prevent  memory corruptions, objects observable from\n C extensions are \"pinned\"; they stick to where they are born until they die,\n just in  case any C  extensions touch their  raw pointers.  This  variant of\n scheme  is   called  \"Mostly-Copying\"  garbage  collector.    Authors  of  C\n extensions,  however,   can  extremely   carefully  write  them   to  become\n compaction-aware.  To do so avoid referring  to a Ruby object from inside of\n your struct  in the  first place.   But if  that is  not possible,  use this\n function  from your  ::rb_data_type_struct::dmark  then.   This way  objects\n marked using it are  considered movable.  If you chose this  way you have to\n manually fix up locations of such moved pointers using rb_gc_location().\n\n @see  Bartlett,  Joel  F.,  \"Compacting Garbage  Collection  with  Ambiguous\n       Roots\",  ACM  SIGPLAN  Lisp  Pointers  Volume  1  Issue  6  pp.  3-12,\n       April-May-June, 1988. https://doi.org/10.1145/1317224.1317225\n\n @param[in]  obj  Object that is movable.\n @post       Values stored in `tbl` are marked."]
    pub fn rb_gc_mark_movable(obj: VALUE);
}
extern "C" {
    #[doc = " Finds a new \"location\" of an object.   An object can be moved on compaction.\n This function projects  its new abode, or just returns  the passed object if\n not moved.  This is  one of the GC utility functions that  you can call when\n you design your own ::rb_data_type_struct::dcompact.\n\n @param[in]  obj  An object, possibly already moved to somewhere else.\n @return     An object, which holds the current contents of former `obj`."]
    pub fn rb_gc_location(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Asserts  that the  passed  object is  no longer  needed.   Such objects  are\n reclaimed sooner or later so this  function is not mandatory.  But sometimes\n you can know  from your application knowledge that an  object is surely dead\n at some point.  Calling this as a hint can be a polite way.\n\n @param[out]  obj  Object, dead.\n @pre         `obj` have never been passed to this function before.\n @post        `obj` could be invalidated.\n @warning     It  is a  failure  to pass  an object  multiple  times to  this\n              function.\n @deprecated  This is now a no-op function."]
    pub fn rb_gc_force_recycle(obj: VALUE);
}
extern "C" {
    #[doc = " Triggers a GC process.  This was the only  GC entry point that we had at the\n beginning.  Over time our GC evolved.  Now what this function does is just a\n very  simplified  variation  of  the  entire GC  algorithms.   A  series  of\n procedures kicked by this API is called a \"full\" GC.\n\n   - It immediately scans the entire object space to sort the dead.\n   - It immediately reclaims any single dead bodies to reuse later.\n\n It is worth  noting that the procedures above do  not include evaluations of\n finalisers.  They run later.\n\n @internal\n\n Finalisers   are   deferred   until   we   can   handle   interrupts.    See\n `rb_postponed_job_flush` in vm_trace.c.\n\n Of course there are  GC that are not \"full\".  For instance  this one and the\n GC  which  runs when  we  are  running out  of  memory  are different.   See\n `gc_profile_record_flag` defined in gc.c for the kinds of GC.\n\n In spite of the name this is not  what everything that a GC can trigger.  As\n of writing  it seems this  function does  not trigger compaction.   But this\n might change in future."]
    pub fn rb_gc();
}
extern "C" {
    #[doc = " Copy&paste an object's finaliser to another.   This is one of the GC utility\n functions  that you  can call  when you  design your  own `initialize_copy`,\n `initialize_dup`, `initialize_clone`.\n\n @param[out]  dst  Destination object.\n @param[in]   src  Source object.\n @post        `dst` and `src` share the same finaliser.\n\n @internal\n\n But isn't it  easier for you to call super,  and let `Object#initialize_copy`\n call this function instead?"]
    pub fn rb_gc_copy_finalizer(dst: VALUE, src: VALUE);
}
extern "C" {
    #[doc = " (Re-) enables GC.  This makes sense only after you called rb_gc_disable().\n\n @retval  RUBY_Qtrue   GC was disabled before.\n @retval  RUBY_Qfalse  GC was enabled before.\n @post    GC is enabled.\n\n @internal\n\n This is  one of  such exceptional  functions that does  not raise  both Ruby\n exceptions and C++ exceptions."]
    pub fn rb_gc_enable() -> VALUE;
}
extern "C" {
    #[doc = " Disables GC.   This prevents automatic GC  runs when the process  is running\n out of memory.  Such situations shall result in rb_memerror().  However this\n does not  prevent users from  manually invoking rb_gc().  That  should work.\n People  abused this  by disabling  GC  at the  beginning of  an event  loop,\n process events without GC overheads,  then manually force reclaiming garbage\n at the bottom of the loop.  However  because our GC is now much smarter than\n just calling rb_gc(), this technique is proven to be sub-optimal these days.\n It  is  believed that  there  is  currently  practically  no needs  of  this\n function.\n\n @retval  RUBY_Qtrue   GC was disabled before.\n @retval  RUBY_Qfalse  GC was enabled before.\n @post    GC is disabled."]
    pub fn rb_gc_disable() -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_gc(), except the return value.\n\n @return  Always returns ::RUBY_Qnil."]
    pub fn rb_gc_start() -> VALUE;
}
extern "C" {
    #[doc = " Assigns a finaliser for an object.  Each objects can have objects (typically\n blocks)  that run  immediately  after  that object  dies.   They are  called\n finalisers of an object.  This function associates a finaliser object with a\n target object.\n\n @note  Note that finalisers run _after_  the object they finalise dies.  You\n        cannot for instance call its methods.\n @note  If  your finaliser  references the  object it  finalises that  object\n        loses any chance to become  a garbage; effectively leaks memory until\n        the end of the process.\n\n @param[in]  obj               Target to finalise.\n @param[in]  block             Something `call`able.\n @exception  rb_eRuntimeError  Somehow `obj` cannot have finalisers.\n @exception  rb_eFrozenError   `obj` is frozen.\n @exception  rb_eArgError      `block` doesn't respond to `call`.\n @return     The passed `block`.\n @post       `block` runs after `obj` dies."]
    pub fn rb_define_finalizer(obj: VALUE, block: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Modifies the object so  that it has no finalisers at  all.  This function is\n mainly provided for symmetry.  No practical usages can be thought of.\n\n @param[out]  obj               Object to clear its finalisers.\n @exception   rb_eFrozenError  `obj` is frozen.\n @return      The passed `obj`.\n @post        `obj` has no finalisers.\n @note        There is no way to undefine  a specific part of many finalisers\n              that `obj` could have.  All you can do is to clear them all."]
    pub fn rb_undefine_finalizer(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_gc_stat(), with \"count\" parameter.\n\n @return  Lifetime total number of runs of GC."]
    pub fn rb_gc_count() -> usize;
}
extern "C" {
    #[doc = " Obtains various GC  related profiles.  The parameter can be  either a Symbol\n or a  Hash.  If  a Hash is  passed, it is  filled with  everything currently\n available.  If a Symbol is passed just that portion is returned.\n\n Possible  variations of  keys  you  can pass  here  change  from version  to\n version.  You can  get the list of  known keys by passing an  empty hash and\n let it be filled.\n\n @param[in,out]  key_or_buf       A Symbol, or a Hash.\n @exception      rb_eTypeError    Neither Symbol nor Hash.\n @exception      rb_eFrozenError  Frozen hash is passed.\n @return         In  case a  Hash  is  passed it  returns  0.  Otherwise  the\n                 profile value associated with the given key is returned.\n @post           In case a Hash is passed it is filled with values."]
    pub fn rb_gc_stat(key_or_buf: VALUE) -> usize;
}
extern "C" {
    #[doc = " Obtains various  info regarding the most  recent GC run.  This  includes for\n instance the reason  of the GC.  The  parameter can be either a  Symbol or a\n Hash.   If  a  Hash  is  passed, it  is  filled  with  everything  currently\n available.  If a Symbol is passed just that portion is returned.\n\n Possible  variations of  keys  you  can pass  here  change  from version  to\n version.  You can  get the list of  known keys by passing an  empty hash and\n let it be filled.\n\n @param[in,out]  key_or_buf       A Symbol, or a Hash.\n @exception      rb_eTypeError    Neither Symbol nor Hash.\n @exception      rb_eFrozenError  Frozen hash is passed.\n @return         In case  a Hash is  passed it returns that  hash.  Otherwise\n                 the profile value associated with the given key is returned.\n @post           In case a Hash is passed it is filled with values."]
    pub fn rb_gc_latest_gc_info(key_or_buf: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Informs that  there are  external memory  usages.  Our GC  runs when  we are\n running out of memory.  The amount of memory, however, can increase/decrease\n behind-the-scene.  For  instance DLLs can allocate  memories using `mmap(2)`\n etc, which  are opaque to  us.  Registering such external  allocations using\n this function enables  proper detection of how much memories  an object used\n as a whole.  That will trigger GCs  more often than it would otherwise.  You\n can  also  pass  negative  numbers  here, to  indicate  that  such  external\n allocations are gone.\n\n @param[in]  diff  Amount of memory increased(+)/decreased(-)."]
    pub fn rb_gc_adjust_memory_usage(diff: isize);
}
extern "C" {
    #[doc = " The field  separator character for  inputs, or  the `$;`.  This  affects how\n `String#split` works.   You can set this  via the `-F` command  line option.\n You can  also assign arbitrary  ruby objects programmatically, but  it makes\n best sense for you to assign a regular expression here.\n\n @internal\n\n Tidbit: \"fs\" comes from AWK's `FS` variable."]
    pub static mut rb_fs: VALUE;
}
extern "C" {
    #[doc = " The field  separator character for outputs,  or the `$,`.  This  affects how\n `Array#join` works.\n\n @deprecated Assigning  anything other than  ::RUBY_Qnil to this  variable is\n             deprecated."]
    pub static mut rb_output_fs: VALUE;
}
extern "C" {
    #[doc = " The record  separator character for inputs,  or the `$/`.  This  affects how\n `IO#gets` works.  You can set this via the `-0` command line option.\n\n @deprecated Assigning  anything other than  ::RUBY_Qnil to this  variable is\n             deprecated.\n\n @internal\n\n Tidbit: \"rs\" comes from AWK's `RS` variable."]
    pub static mut rb_rs: VALUE;
}
extern "C" {
    #[doc = " This is the default  value of ::rb_rs, i.e. `\"\\n\"`.  It  seems it has always\n been just a newline string since the beginning.  Not sure why C codes has to\n use this, given there is no way for ruby programs to interface.\n\n Also it has not been deprecated for unknown reasons."]
    pub static mut rb_default_rs: VALUE;
}
extern "C" {
    #[doc = " The record separator  character for outputs, or the `$\\`.   This affects how\n `IO#print` works.\n\n @deprecated Assigning  anything other than  ::RUBY_Qnil to this  variable is\n             deprecated."]
    pub static mut rb_output_rs: VALUE;
}
extern "C" {
    #[doc = " Writes the given string to the given IO.\n\n @param[out]  io                   An IO, opened for writing.\n @param[in]   str                  A String-like object to write to `io`.\n @exception   rb_eIOError          `io` isn't opened for writing.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eTypeError        No conversion from `str` to String.\n @exception   rb_eSystemCallError  `write(2)` failed for some reason.\n @return      The number of bytes written to the `io`.\n @post        `str` (up to the length of return value) is written to `io`.\n @note        This function blocks.\n @note        Partial write is a thing.  It must be at least questionable not\n              to check the return value.\n\n @internal\n\n Above description is  in fact inaccurate.  This function  can take arbitrary\n objects, and  calls their  `write` method.   What is  written above  in fact\n describes how `IO#write` works.  You can  pass StringIO etc. here, and would\n work completely differently."]
    pub fn rb_io_write(io: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Reads a \"line\" from  the given IO.  A line here means  a chunk of characters\n which is terminated by either `\"\\n\"` or an EOF.\n\n @param[in,out]  io               An IO, opened for reading.\n @exception      rb_eIOError      `io` isn't opened for reading.\n @exception      rb_eFrozenError  `io` is frozen.\n @retval         RUBY_Qnil        `io` is at EOF.\n @retval         otherwise        An instance of ::rb_cString.\n @post           `io` is read.\n @note           Unlike `IO#gets` it doesn't set `$_`.\n @note           Unlike `IO#gets` it doesn't consider `$/`."]
    pub fn rb_io_gets(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Reads a byte from the given IO.\n\n @note           In Ruby a \"byte\" always means  an 8 bit integer ranging from\n                 0 to 255 inclusive.\n @param[in,out]  io               An IO, opened for reading.\n @exception      rb_eIOError      `io` is not opened for reading.\n @exception      rb_eFrozenError  `io` is frozen.\n @retval         RUBY_Qnil        `io` is at EOF.\n @retval         otherwise        An instance of ::rb_cInteger.\n @post           `io` is read.\n\n @internal\n\n Of course  there was a  function called  `rb_io_getc()`.  It was  removed in\n commit a25fbe3b3e531bbe479f344af24eaf9d2eeae6ea."]
    pub fn rb_io_getbyte(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " \"Unget\"s a  string.  This function  pushes back  the passed string  onto the\n passed IO,  such that  a subsequent  buffered read will  return it.   If the\n passed content  is in  fact an  integer, a single  character string  of that\n codepoint of the encoding of the IO will be pushed back instead.\n\n It  might be  counter-intuitive but  this  function can  push back  multiple\n characters at  once.  Also this function  can be called multiple  times on a\n same IO.   Also a  \"character\" can be  wider than a  byte, depending  on the\n encoding of the IO.\n\n @param[out]  io               An IO, opened for reading.\n @param[in]   c                Either a String, or an Integer.\n @exception   rb_eIOError      `io` is not opened for reading.\n @exception   rb_eFrozenError  `io` is frozen.\n @exception   rb_eTypeError    No conversion from `c` to ::rb_cString.\n @return      Always returns ::RUBY_Qnil.\n\n @internal\n\n Why there is ungetc, given there is no getc?"]
    pub fn rb_io_ungetc(io: VALUE, c: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_io_ungetc(),  except it  doesn't take  the encoding  of the\n passed IO into account.  When an integer is passed, it just casts that value\n to C's `unsigned char`, and pushes that back.\n\n @param[out]  io               An IO, opened for reading.\n @param[in]   b                Either a String, or an Integer.\n @exception   rb_eIOError      `io` is not opened for reading.\n @exception   rb_eFrozenError  `io` is frozen.\n @exception   rb_eTypeError    No conversion from `b` to ::rb_cString.\n @return      Always returns ::RUBY_Qnil."]
    pub fn rb_io_ungetbyte(io: VALUE, b: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Closes the IO.   Any buffered contents are flushed to  the operating system.\n Any future operations against the IO would raise ::rb_eIOError.  In case the\n io was created using `IO.popen`, it also sets the `$?`.\n\n @param[out]  io  Target IO to close.\n @return      Always returns ::RUBY_Qnil.\n @post        `$?` is set in case IO is a pipe.\n @post        No operations are possible against `io` any further.\n @note        This can block to flush the contents.\n @note        This  can  wake other  threads  up,  especially those  who  are\n              `select()`-ing the passed IO.\n @note        Multiple invocations  of this function  over the same  IO again\n              and again is not an error, since Ruby 2.3.\n\n @internal\n\n You can close a frozen IO... Is this intentional?"]
    pub fn rb_io_close(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Flushes any buffered  data within the passed IO to  the underlying operating\n system.\n\n @param[out]  io                   Target IO to flush.\n @exception   rb_eIOError          `io` is closed.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eSystemCallError  `write(2)` failed for some reason.\n @return      The passed `io`.\n @post        `io`'s buffers are empty.\n @note        This operation also discards the read buffer.  Should basically\n              be harmless, but in an esoteric situation like when user pushed\n              something  different from  what was  read using  `ungetc`, this\n              operation in fact changes the behaviour of the `io`.\n @note        Buffering is  difficult.  This operation flushes  the data from\n              our userspace to  the kernel, but that doesn't  always mean you\n              can expect them stored persistently onto your hard drive."]
    pub fn rb_io_flush(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the passed IO is at the end of file.  \"The end of file\" here mans\n that there are  no more data to  read.  This function blocks  until the read\n buffer is filled in, and if that operation reached the end of file, it still\n returns  ::RUBY_Qfalse (because  there are  data  yet in  that buffer).   It\n returns ::RUBY_Qtrue once after the buffer is cleared.\n\n @param[in,out]  io              Target io to query.\n @exception      rb_eIOError     `io` is not opened for reading.\n @exception      rb_eFrozenError  `io` is frozen.\n @retval         RUBY_Qfalse     There are things yet to be read.\n @retval         RUBY_Qtrue      \"The end of file\" situation."]
    pub fn rb_io_eof(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Sets the binmode.  This operation  nullifies the effect of textmode (newline\n conversion from  `\"\\r\\n\"` to `\"\\n\"`  or vice  versa).  Note that  it doesn't\n stop character encodings conversions.  For instance an IO created using:\n\n ```ruby\n File.open(\n   \"/dev/urandom\",\n   textmode: true,\n   external_encoding: Encoding::GB18030,\n   internal_encoding: Encoding::Windows_31J)\n ```\n\n has both  newline and character  conversions.  If you  pass such IO  to this\n function, only  the `textmode:true` part  is cancelled.  Texts  read through\n the IO would still  be encoded in Windows-31J; texts written  to the IO will\n be encoded in GB18030.\n\n @param[out]  io               Target IO to modify.\n @exception   rb_eFrozenError  `io` is frozen.\n @return      The passed `io`.\n @post        `io` is in binmode.\n @note        There is no equivalent operation in Ruby.  You can do this only\n              in C."]
    pub fn rb_io_binmode(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Forces no conversions be applied  to the passed IO.  Unlike rb_io_binmode(),\n this cancels any  newline conversions as well as  encoding conversions.  Any\n texts read/written through the IO will be the verbatim binary contents.\n\n @param[out]  io               Target IO to modify.\n @exception   rb_eFrozenError  `io` is frozen.\n @return      The passed `io`.\n @post        `io` is in binmode.  Both external/internal encoding are set to\n              rb_ascii8bit_encoding().\n @note        This is the implementation of `IO#binmode`."]
    pub fn rb_io_ascii8bit_binmode(io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_io_write(), except it always returns the passed IO.\n\n @param[out]  io                   An IO, opened for writing.\n @param[in]   str                  A String-like object to write to `io`.\n @exception   rb_eIOError          `io` isn't opened for writing.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eTypeError        No conversion from `str` to String.\n @exception   rb_eSystemCallError  `write(2)` failed.\n @return      The passed `io`.\n @post        `str` is written to `io`.\n @note        This function blocks.\n\n @internal\n\n As rb_io_write(), above description is a fake."]
    pub fn rb_io_addstr(io: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is a rb_f_sprintf() + rb_io_write() combo.\n\n @param[in]   argc                 Number of objects of `argv`.\n @param[in]   argv                 A format string followed by its arguments.\n @param[out]  io                   An IO, opened for writing.\n @exception   rb_eIOError          `io` isn't opened for writing.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eTypeError        No conversion from `str` to String.\n @exception   rb_eSystemCallError  `write(2)` failed.\n @return      Always returns ::RUBY_Qnil.\n @post        `argv` is formatted, then written to `io`.\n @note        This function blocks.\n\n @internal\n\n As rb_io_write(), above descriptions include fakes."]
    pub fn rb_io_printf(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Iterates  over the  passed array  to apply  rb_io_write() individually.   If\n there  is  `$,`,  this  function  inserts  the  string  in  middle  of  each\n iterations.  If there is `$\\`, this  function appends the string at the end.\n If the array is empty, this function outputs `$_`.\n\n @param[in]   argc                 Number of objects of `argv`.\n @param[in]   argv                 An array of strings to display.\n @param[out]  io                   An IO, opened for writing.\n @exception   rb_eIOError          `io` isn't opened for writing.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eTypeError        No conversion from `str` to String.\n @exception   rb_eSystemCallError  `write(2)` failed.\n @return      Always returns ::RUBY_Qnil.\n @post        `argv` is written to `io`.\n @note        This function blocks.\n @note        This function calls rb_io_write() multiple times.  Which means,\n              it is not  an atomic operation.  Outputs  from multiple threads\n              can interleave.\n\n @internal\n\n As rb_io_write(), above descriptions include fakes."]
    pub fn rb_io_print(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Iterates over the passed array  to apply rb_io_write() individually.  Unlike\n rb_io_print(), this  function prints  a newline per  each element.   It also\n flattens   the   passed   array   (OTOH  rb_io_print()   just   resorts   to\n rb_ary_to_s()).\n\n @param[in]   argc                 Number of objects of `argv`.\n @param[in]   argv                 An array of strings to display.\n @param[out]  io                   An IO, opened for writing.\n @exception   rb_eIOError          `io` isn't opened for writing.\n @exception   rb_eFrozenError      `io` is frozen.\n @exception   rb_eTypeError        No conversion from `str` to String.\n @exception   rb_eSystemCallError  `write(2)` failed.\n @return      Always returns ::RUBY_Qnil.\n @post        `argv` is written to `io`.\n @note        This function blocks.\n @note        This function calls rb_io_write() multiple times.  Which means,\n              it is not  an atomic operation.  Outputs  from multiple threads\n              can interleave.\n\n @internal\n\n As rb_io_write(), above descriptions include fakes."]
    pub fn rb_io_puts(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates  an IO  instance  whose backend  is the  given  file descriptor.   C\n extension libraries sometimes have file descriptors created elsewhere (maybe\n deep inside  of another shared  library), which  they want ruby  programs to\n handle.  This function is handy for such situations.\n\n @param[in]  fd     Target file descriptor.\n @param[in]  flags  Flags, e.g. `O_CREAT|O_EXCL`\n @param[in]  path   The path of the file that backs `fd`, for diagnostics.\n @return     An allocated instance of ::rb_cIO.\n @note       Leave `path` NULL if you don't know."]
    pub fn rb_io_fdopen(
        fd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Opens a file located at the given path.\n\n `fmode` is a C string that represents the open mode.  It can be one of:\n\n   - `r` (means `O_RDONLY`),\n   - `w` (means `O_WRONLY | O_TRUNC | O_CREAT`),\n   - `a` (means `O_WRONLY | O_APPEND | O_CREAT`),\n\n  Followed by zero or more combinations of:\n\n   - `b` (means `_O_BINARY`),\n   - `t` (means `_O_TEXT`),\n   - `+` (means `O_RDWR`),\n   - `x` (means `O_TRUNC`), or\n   - `:[BOM|]enc[:enc]` (see below).\n\n This  last  one   specifies  external  (and  internal   if  any)  encodings,\n respectively.  If  optional `BOM|` is  specified and the  specified external\n encoding is capable of expressing  BOMs, opening file's contents' byte order\n is auto-detected using the mechanism.\n\n So for instance, fmode of `\"rt|BOM:utf-16le:utf-8\"` specifies that...\n\n   - the physical representation of the contents of the file is in UTF-16;\n   - honours its BOM but assumes little endian if absent;\n   - opens the file for reading;\n   - what is read is converted into UTF-8;\n   - with newlines cannibalised to `\\n`.\n\n @param[in]  fname                Path to open.\n @param[in]  fmode                Mode specifier much like `fopen(3)`.\n @exception  rb_eArgError         `fmode` contradicted (e.g. `\"bt\"`).\n @exception  rb_eSystemCallError  `open(2)` failed for some reason.\n @return     An instance of ::rb_cIO."]
    pub fn rb_file_open(
        fname: *const ::std::os::raw::c_char,
        fmode: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_file_open(), except it takes the pathname as a Ruby's string\n instead of C's.  In case the passed  Ruby object is a non-String it tries to\n call `#to_path`.\n\n @param[in]  fname                Path to open.\n @param[in]  fmode                Mode specifier much like `fopen(3)`.\n @exception  rb_eTypeError        `fname` is not a String.\n @exception  rb_eEncCompatError   `fname` is not ASCII-compatible.\n @exception  rb_eArgError         `fmode` contradicted (e.g. `\"bt\"`).\n @exception  rb_eSystemCallError  `open(2)` failed for some reason.\n @return     An instance of ::rb_cIO."]
    pub fn rb_file_open_str(fname: VALUE, fmode: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Much like rb_io_gets(), but it reads  from the mysterious ARGF object.  ARGF\n in this context can  be seen as a virtual IO  which concatenates contents of\n the files passed to the process via the  ARGV, or just STDIN if there are no\n such files.\n\n Unlike rb_io_gets() this function sets `$_`.\n\n @exception      rb_eFrozenError  ARGF resorts to STDIN but it is frozen.\n @retval         RUBY_Qnil        ARGF is at EOF.\n @retval         otherwise        An instance of ::rb_cString.\n @post           ARGF is read.\n @post           `$_` is set.\n\n @internal\n\n In reality, this function can call `ARGF.gets`.  Its redefinition can affect\n the behaviour.\n\n Also, you can tamper ARGV on-the-fly in middle of ARGF usages:\n\n ```\n gets                        # Reads the first file.\n ARGV << '/proc/self/limits' # Adds a file.\n gets                        # Can read from /proc/self/limits.\n ```"]
    pub fn rb_gets() -> VALUE;
}
extern "C" {
    #[doc = " Writes the given error message to  somewhere applicable.  On Windows it goes\n to the console.  On POSIX environments it goes to the standard error.\n\n @warning  IT IS  A BAD  IDEA to  use this function  form your  C extensions.\n           It  is often  annoying when  GUI applications  write to  consoles;\n           users  don't want  to look  at  there.  Programmers  also want  to\n           control  the cause  of the  message  itself, like  by rescuing  an\n           exception.  Just let ruby handle errors.  That must be better than\n           going your own way.\n\n @param[in]  str  Error message to display.\n @post       `str` is written to somewhere.\n\n @internal\n\n AFAIK this function  is listed here without marked  deprecated because there\n are usages of this function in the wild."]
    pub fn rb_write_error(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical to  rb_write_error(), except  it additionally takes  the message's\n length.  Necessary when you want to handle wide characters.\n\n @param[in]  str  Error message to display.\n @param[in]  len  Length of `str`, in bytes.\n @post       `str` is written to somewhere."]
    pub fn rb_write_error2(str_: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Closes everything.  In case of  POSIX environments, a child process inherits\n its parent's opened  file descriptors.  Which is nowadays  considered as one\n of the UNIX mistakes.  This function closes such inherited file descriptors.\n When your C  extension needs to have  a child process, don't  forget to call\n this from your child process right before exec.\n\n @param[in]  lowfd        Lower bound of FDs (you want STDIN to remain, no?).\n @param[in]  maxhint      Hint of max FDs.\n @param[in]  noclose_fds  A hash, whose keys are an allowlist.\n\n @internal\n\n As of writing, in  spite of the name, this function  does not actually close\n anything.  It just  sets `FD_CLOEXEC` for everything and  let `execve(2)` to\n atomically close them at once.  This is  because as far as we know there are\n no such platform that has `fork(2)` but lacks `FD_CLOEXEC`.\n\n Because this function is expected to run  on a forked process it is entirely\n async-signal-safe."]
    pub fn rb_close_before_exec(
        lowfd: ::std::os::raw::c_int,
        maxhint: ::std::os::raw::c_int,
        noclose_fds: VALUE,
    );
}
extern "C" {
    #[doc = " This is an rb_cloexec_pipe() + rb_update_max_fd() combo.\n\n @param[out]  pipes  Return buffer.  Must at least hold 2 elements.\n @retval      0      Successful creation of a pipe.\n @retval      -1     Failure in underlying system call(s).\n @post        `pipes` is filled with file descriptors.\n @post        `errno` is set on failure."]
    pub fn rb_pipe(pipes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries if the  given FD is reserved or not.   Occasionally Ruby interpreter\n opens files  for its own  purposes.  Use  this function to  prevent touching\n such behind-the-scene descriptors.\n\n @param[in]  fd  Target file descriptor.\n @retval     1   `fd` is reserved.\n @retval     0   Otherwise."]
    pub fn rb_reserved_fd_p(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Opens a file  that closes on exec.   In case of POSIX  environments, a child\n process inherits  its parent's opened  file descriptors.  Which  is nowadays\n considered  as  one of  the  UNIX  mistakes.   This  function opens  a  file\n descriptor  as  `open(2)` does,  but  additionally  instructs the  operating\n system that we don't want it be seen from child processes.\n\n @param[in]  pathname   File path to open.\n @param[in]  flags      Open mode, as in `open(2)`.\n @param[in]  mode       File mode, in case of `O_CREAT`.\n @retval     -1         `open(2)` failed for some reason.\n @retval     otherwise  An allocated new file descriptor.\n @note       This function does not raise.\n\n @internal\n\n Whether this function can take NULL or not depends on the underlying open(2)\n system call implementation but @shyouhei doesn't think it's worth trying."]
    pub fn rb_cloexec_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_cloexec_fcntl_dupfd(), except it implies minfd is 3.\n\n @param[in]  oldfd     File descriptor to duplicate.\n @retval     -1        `dup2(2)` failed for some reason.\n @retval     otherwise  An allocated new file descriptor.\n @note       This function does not raise."]
    pub fn rb_cloexec_dup(oldfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_cloexec_dup(),  except you can specify  the destination file\n descriptor.   If  the  destination  is  already  squatted  by  another  file\n descriptor that gets silently closed without  any warnings.  (This is a spec\n requested by POSIX.)\n\n @param[in]  oldfd  File descriptor to duplicate.\n @param[in]  newfd  Return value destination.\n @retval     -1     `dup2(2)` failed for some reason.\n @retval     newfd  An allocated new file descriptor.\n @post       Whatever sat at `newfd` gets closed with no notifications.\n @post       In case return value is -1 `newfd` is untouched.\n @note       This function does not raise."]
    pub fn rb_cloexec_dup2(
        oldfd: ::std::os::raw::c_int,
        newfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Opens a pipe with  closing on exec.  In case of  POSIX environments, a child\n process inherits  its parent's opened  file descriptors.  Which  is nowadays\n considered  as one  of the  UNIX mistakes.   This function  opens a  pipe as\n `pipe(2)`  does, but  additionally instructs  the operating  system that  we\n don't want the duplicated FDs be seen from child processes.\n\n @param[out]  fildes  Return buffer.  Must at least hold 2 elements.\n @retval      0       Successful creation of a pipe.\n @retval      -1      Failure in underlying system call(s).\n @post        `pipes` is filled with file descriptors.\n @post        `errno` is set on failure."]
    pub fn rb_cloexec_pipe(fildes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Duplicates  a file  descriptor  with  closing on  exec.   In  case of  POSIX\n environments, a child process inherits its parent's opened file descriptors.\n Which is  nowadays considered as  one of  the UNIX mistakes.   This function\n duplicates a  file descriptor as  `dup(2)` does, but  additionally instructs\n the operating system that we don't want the duplicated FD be seen from child\n processes.\n\n @param[in]  fd         File descriptor to duplicate.\n @param[in]  minfd      Minimum allowed FD to return.\n @retval     -1         `dup(2)` failed for some reason.\n @retval     otherwise  An allocated new file descriptor.\n @note       This function does not raise.\n\n `minfd` is handy  when for instance STDERR  is closed but you  don't want to\n use fd 2."]
    pub fn rb_cloexec_fcntl_dupfd(
        fd: ::std::os::raw::c_int,
        minfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Informs the interpreter that the passed fd can be the max.  This information\n is used from rb_close_before_exec().\n\n @param[in]  fd  An open FD, which can be large."]
    pub fn rb_update_max_fd(fd: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sets or clears  the close-on-exec flag of the passed  file descriptor to the\n desired state.  STDIN,  STDOUT, STDERR are the  exceptional file descriptors\n that shall  remain open.  All  others are  to be closed  on exec.  When  a C\n extension  library  opens  a  file  descriptor  using  anything  other  than\n rb_cloexec_open() etc., that file descriptor shall experience this function.\n\n @param[in]  fd  An open file descriptor."]
    pub fn rb_fd_fix_cloexec(fd: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Loads and executes the Ruby program in the given file.\n\n If the path is  an absolute path (e.g. starts with `'/'`),  the file will be\n loaded  directly using  the  absolute  path.  If  the  path  is an  explicit\n relative path (e.g. starts with `'./'`  or `'../'`), the file will be loaded\n using the  relative path  from the current  directory.  Otherwise,  the file\n will be searched for in the  library directories listed in the `$LOAD_PATH`.\n If the file is found in a  directory, this function will attempt to load the\n file relative  to that directory.  If  the file is  not found in any  of the\n directories in the `$LOAD_PATH`, the file  will be loaded using the relative\n path from the current directory.\n\n If the file doesn't  exist when there is an attempt to  load it, a LoadError\n will be raised.\n\n If the `wrap` parameter is true, the loaded script will be executed under an\n anonymous module, protecting the calling  program's global namespace.  In no\n circumstance will  any local variables in  the loaded file be  propagated to\n the loading environment.\n\n @param[in]  path                Pathname of a file to load.\n @param[in]  wrap                Either to load under an anonymous module.\n @exception  rb_eTypeError       `path` is not a string.\n @exception  rb_eArgError        `path` is broken as a pathname.\n @exception  rb_eEncCompatError  `path` is incompatible with pathnames.\n @exception  rb_eLoadError       `path` not found.\n @exception  rb_eException       Any exceptions while loading the contents.\n\n @internal\n\n It seems this function is under the rule of bootsnap's regime?"]
    pub fn rb_load(path: VALUE, wrap: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Identical to  rb_load(), except  it avoids  potential global  escapes.  Such\n global escapes include exceptions, `throw`, `break`, for example.\n\n It first  evaluates the given file  as rb_load() does.  If  no global escape\n occurred  during the  evaluation,  it `*state`  is set  to  zero on  return.\n Otherwise, it sets `*state`  to nonzero.  If state is `NULL`,  it is not set\n in both cases.\n\n @param[in]   path   Pathname of a file to load.\n @param[in]   wrap   Either to load under an anonymous module.\n @param[out]  state  State of execution.\n @post        `*state` is set to zero if succeeded.  Nonzero otherwise.\n @warning     You have to clear the error info with `rb_set_errinfo(Qnil)` if\n              you decide to ignore the caught exception.\n @see         rb_load\n @see         rb_protect\n\n @internal\n\n Though   not  a   part  of   our  public   API,  `state`   is  in   fact  an\n enum ruby_tag_type.  You can  see the potential \"nonzero\"  values by looking\n at vm_core.h."]
    pub fn rb_load_protect(
        path: VALUE,
        wrap: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Queries if  the given  feature has  already been  loaded into  the execution\n context.  The \"feature\" head are things like `\"json\"` or `\"socket\"`.\n\n @param[in]  feature  Name of a library you want to know about.\n @retval     1        Yes there is.\n @retval     0        Not yet."]
    pub fn rb_provided(feature: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to  rb_provided(), except it additionally  returns the \"canonical\"\n name of the loaded feature.  This can be handy when for instance you want to\n know the actually loaded library is either `foo.rb` or `foo.so`.\n\n @param[in]   feature  Name of a library you want to know about.\n @param[out]  loading  Return buffer.\n @retval      1        Yes there is.\n @retval      0        Not yet."]
    pub fn rb_feature_provided(
        feature: *const ::std::os::raw::c_char,
        loading: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Declares that the  given feature is already provided by  someone else.  This\n API can  be handy  when you  have an extension  called `foo.so`  which, when\n required, also provides functionality of `bar.so`.\n\n @param[in]  feature  Name of a library which had already been provided.\n @post       No further `require` would search `feature`."]
    pub fn rb_provide(feature: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical to rb_require_string(),  except it ignores the  first argument for\n no reason.  There seems to be no reason for 3rd party extension libraries to\n use it.\n\n @param[in]  self              Ignored.  Can be anything.\n @param[in]  feature           Name of a feature, e.g. `\"json\"`.\n @exception  rb_eLoadError     No such feature.\n @exception  rb_eRuntimeError  `$\"` is frozen; unable to push.\n @retval     RUBY_Qtrue        The feature is loaded for the first time.\n @retval     RUBY_Qfalse       The feature has already been loaded.\n @post       `$\"` is updated."]
    pub fn rb_f_require(self_: VALUE, feature: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Finds and loads the given feature, if absent.\n\n If the  feature is an  absolute path (e.g.  starts with `'/'`),  the feature\n will  be loaded  directly using  the absolute  path.  If  the feature  is an\n explicit relative  path (e.g.  starts with `'./'`  or `'../'`),  the feature\n will  be  loaded  using  the  relative  path  from  the  current  directory.\n Otherwise,  the feature  will be  searched  for in  the library  directories\n listed in the `$LOAD_PATH`.\n\n If the feature has the extension `\".rb\"`,  it is loaded as a source file; if\n the extension is `\".so\"`, `\".o\"`, or `\".dll\"`, or the default shared library\n extension on the  current platform, Ruby loads the shared  library as a Ruby\n extension.  Otherwise, Ruby tries adding `\".rb\"`,  `\".so\"`, and so on to the\n name until found.   If the file named  cannot be found, a  LoadError will be\n raised.\n\n For  extension  libraries the  given  feature  may  use any  shared  library\n extension.  For example, on Linux you can require `\"socket.dll\"` to actually\n load `socket.so`.\n\n The absolute path of the loaded file is added to `$LOADED_FEATURES`.  A file\n will not be loaded again if its path already appears in there.\n\n Any constants or globals within the  loaded source file will be available in\n the calling program's  global namespace.  However, local  variables will not\n be propagated to the loading environment.\n\n @param[in]  feature           Name of a feature, e.g. `\"json\"`.\n @exception  rb_eLoadError     No such feature.\n @exception  rb_eRuntimeError  `$\"` is frozen; unable to push.\n @retval     RUBY_Qtrue        The feature is loaded for the first time.\n @retval     RUBY_Qfalse       The feature has already been loaded.\n @post       `$\"` is updated."]
    pub fn rb_require_string(feature: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Asserts that  the extension  library that  calls this  function is  aware of\n Ractor.  Multiple Ractors  run without protecting each  other.  This doesn't\n interface  well   with  C  programs,   unless  designed  with   an  in-depth\n understanding of  how Ractors work.   Extension libraries are shut  out from\n Ractors by default.  This API is  to bypass that restriction.  Once after it\n was called,  successive calls to rb_define_method()  etc. become definitions\n of methods  that are  aware of  Ractors.  The amendment  would be  in effect\n until the end of rb_require_string() etc.\n\n @param[in]  flag  Either the library is aware of Ractors or not.\n @post       Methods would be callable form Ractors, if `flag` is true."]
    pub fn rb_ext_ractor_safe(flag: bool);
}
extern "C" {
    #[doc = " Serialises the  given object and  all its  referring objects, to  write them\n down to the passed port.\n\n @param[in]   obj               Target object to dump.\n @param[out]  port              IO-like destination buffer.\n @exception   rb_eTypeError     `obj` cannot be dumped for some reason.\n @exception   rb_eRuntimeError  `obj` was tampered during dumping.\n @exception   rb_eArgError      Traversal too deep.\n @return      The passed `port` as-is.\n @post        Serialised representation of `obj` is written to `port`.\n @note        `port` is basically an IO but StringIO is also possible."]
    pub fn rb_marshal_dump(obj: VALUE, port: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Deserialises  a  previous output  of  rb_marshal_dump()  into a  network  of\n objects.\n\n @param[in,out]  port           Either IO or String.\n @exception      rb_eTypeError  `port` is in unexpected type.\n @exception      rb_eArgError   Contents of `port` is broken.\n @return         Object(s) rebuilt using the info from `port`.\n\n SECURITY  CONSIDERATIONS\n ========================\n\n @warning        By  design,  rb_marshal_load()  can deserialise  almost  any\n                 class loaded into the Ruby  process.  In many cases this can\n                 lead to remote code execution  if the Marshal data is loaded\n                 from an untrusted source.\n @warning        As a result, rb_marshal_load() is  not suitable as a general\n                 purpose serialisation format and  you should never unmarshal\n                 user supplied input or other untrusted data.\n @warning        If  you need  to  deserialise untrusted  data,  use JSON  or\n                 another  serialisation  format that  is  only  able to  load\n                 simple, 'primitive' types such  as String, Array, Hash, etc.\n                 Never  allow  user  input  to  specify  arbitrary  types  to\n                 deserialise into."]
    pub fn rb_marshal_load(port: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Marshal  format compatibility  layer.  Over  time, classes  evolve, so  that\n their internal data structure change  drastically.  For instance an instance\n of ::rb_cRange  was made  of ::RUBY_T_OBJECT  in 1.x.,  but in  3.x it  is a\n ::RUBY_T_STRUCT now.  In  order to keep binary compatibility,  we \"fake\" the\n marshalled representation to stick to old  types.  This is the API to enable\n that manoeuvre.  Here is how:\n\n First, because  you are going to  keep backwards compatibility, you  need to\n retain the old implementation of your  class.  Rename it, and keep the class\n somewhere  (for  instance  rb_register_global_address() could  help).   Next\n create your new class.  Do whatever you want.\n\n Then, this is the key point.  Create two new \"bridge\" functions that convert\n the structs back and forth:\n\n   - the  \"dumper\" function  that takes  an instance  of the  new class,  and\n     returns   an  instance   of  the   old   one.   This   is  called   from\n     rb_marshal_dump(), to keep it possible for old programs to read your new\n     data.\n\n   - the \"loader\" function that takes two  arguments, new one and old one, in\n     that  order.  rb_marshal_load()  calls  this function  when  it finds  a\n     representation of  the retained old class.   The old one passed  to this\n     function   is   the   reconstructed   instance   of   the   old   class.\n     Reverse-engineer  that to  modify the  new  one, to  have the  identical\n     contents.\n\n Finally, connect all of them using this function.\n\n @param[in]  newclass       The class that needs conversion.\n @param[in]  oldclass       Old implementation of `newclass`.\n @param[in]  dumper         Function that converts `newclass` to `oldclass`.\n @param[in]  loader         Function that converts `oldclass` to `newclass`.\n @exception  rb_eTypeError  `newclass` has no allocator."]
    pub fn rb_marshal_define_compat(
        newclass: VALUE,
        oldclass: VALUE,
        dumper: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        loader: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
    );
}
extern "C" {
    #[doc = " Just always raises an exception.\n\n @exception  rb_eZeroDivError  Division by zero error."]
    pub fn rb_num_zerodiv() -> !;
}
extern "C" {
    #[doc = " Coerced binary operation.  This function first coerces the two objects, then\n applies the operation.\n\n @param[in]  lhs            LHS operand.\n @param[in]  rhs            RHS operand.\n @param[in]  op             Operator method name.\n @exception  rb_eTypeError  Coercion failed for some reason.\n @return     `lhs op rhs`, in a coerced way."]
    pub fn rb_num_coerce_bin(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_num_coerce_bin(), except for return  values.  This function\n best suits for comparison operators e.g. `<=>`.\n\n @param[in]  lhs        LHS operand.\n @param[in]  rhs        RHS operand.\n @param[in]  op         Operator method name.\n @retval     RUBY_Qnil  Coercion failed for some reason.\n @retval     otherwise  `lhs op rhs`, in a coerced way."]
    pub fn rb_num_coerce_cmp(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_num_coerce_cmp(), except for return  values.  This function\n best suits for relationship operators e.g. `<=`.\n\n @param[in]  lhs           LHS operand.\n @param[in]  rhs           RHS operand.\n @param[in]  op            Operator method name.\n @exception  rb_eArgError  Coercion failed for some reason.\n @return     `lhs op rhs`, in a coerced way."]
    pub fn rb_num_coerce_relop(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    #[doc = " This one  is optimised for bitwise  operations, but the API  is identical to\n rb_num_coerce_bin().\n\n @param[in]  lhs           LHS operand.\n @param[in]  rhs           RHS operand.\n @param[in]  op            Operator method name.\n @exception  rb_eArgError  Coercion failed for some reason.\n @return     `lhs op rhs`, in a coerced way."]
    pub fn rb_num_coerce_bit(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    #[doc = " Converts  a  numeric  value  into  a  Fixnum.   This  is  not  a  preserving\n conversion; for instance 1.5 would be converted into 1.\n\n @param[in]  val             A numeric object.\n @exception  rb_eTypeError   No conversion from `val` to Integer.\n @exception  rb_eRangeError  `val` out of range.\n @return     A fixnum converted from `val`.\n\n @internal\n\n This seems used from nowhere?"]
    pub fn rb_num2fix(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Generates  a place-value  representation  of the  given  Fixnum, with  given\n radix.\n\n @param[in]  val           A fixnum to stringify.\n @param[in]  base          `2` to `36` inclusive for each radix.\n @exception  rb_eArgError  `base` is out of range.\n @return     An instance of ::rb_cString representing `val`.\n @pre        `val` must be a Fixnum (no checks performed)."]
    pub fn rb_fix2str(val: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Compares two `double`s.  Handy when implementing a spaceship operator.\n\n @param[in]  lhs             A value.\n @param[in]  rhs             Another value.\n @retval     RB_INT2FIX(-1)  `lhs` is \"bigger than\" `rhs`.\n @retval     RB_INT2FIX(1)   `rhs` is \"bigger than\" `lhs`.\n @retval     RB_INT2FIX(0)   They are equal.\n @retval     RUBY_Qnil       Not comparable, e.g. NaN."]
    pub fn rb_dbl_cmp(lhs: f64, rhs: f64) -> VALUE;
}
extern "C" {
    #[doc = " Raises the passed `x` to the power of `y`.\n\n @note       The return value can be really big.\n @note       Also the  return value  can be  really small, in  case `x`  is a\n             negative number.\n @param[in]  x          A number.\n @param[in]  y          Another number.\n @retval     Inf        Cannot express the result.\n @retval     1          Either `y` is 0 or `x` is 1.\n @retval     otherwise  An instance of ::rb_cInteger whose value is `x ** y`.\n\n @internal\n\n This function  returns Infinity  when `y` is  big enough not  to fit  into a\n Fixnum.  Warning is issued then."]
    pub fn rb_int_positive_pow(x: ::std::os::raw::c_long, y: ::std::os::raw::c_ulong) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_class_new_instance(), except it passes  the passed keywords\n if any to the `#initialize` method.\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arbitrary number of method arguments.\n @param[in]  klass          An instance of ::rb_cClass.\n @exception  rb_eTypeError  `klass`'s allocator is undefined.\n @exception  rb_eException  Any exceptions can happen inside.\n @return     An allocated new instance of `klass`.\n @note       This is _the_ implementation of `Object.new`."]
    pub fn rb_class_new_instance_pass_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Allocates, then initialises an instance of  the given class.  It first calls\n the passed  class' allocator to  obtain an uninitialised object,  then calls\n its initialiser with the remaining arguments.\n\n @param[in]  argc           Number of objects of `argv`.\n @param[in]  argv           Arguments passed to `#initialize`.\n @param[in]  klass          An instance of ::rb_cClass.\n @exception  rb_eTypeError  `klass`'s allocator is undefined.\n @exception  rb_eException  Any exceptions can happen inside.\n @return     An allocated new instance of `klass`."]
    pub fn rb_class_new_instance(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_class_new_instance(),  except you can specify  how to handle\n the last element of the given array.\n\n @param[in]  argc             Number of objects of `argv`.\n @param[in]  argv             Arbitrary number of method arguments.\n @param[in]  klass            An instance of ::rb_cClass.\n @param[in]  kw_splat         Handling of keyword parameters:\n   - RB_NO_KEYWORDS           `argv`'s last is not a keyword argument.\n   - RB_PASS_KEYWORDS         `argv`'s last is a keyword argument.\n   - RB_PASS_CALLED_KEYWORDS  it depends if there is a passed block.\n @exception  rb_eTypeError    `klass`'s allocator is undefined.\n @exception  rb_eException    Any exceptions can happen inside.\n @return     An allocated new instance of `klass`."]
    pub fn rb_class_new_instance_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Checks for equality of the passed objects, in terms of `Object#eql?`.\n\n @param[in]  lhs          Comparison left hand side.\n @param[in]  rhs          Comparison right hand side.\n @retval     non-zero     They are equal.\n @retval     0            Otherwise.\n @note       This  function  actually  calls `lhs.eql?(rhs)`  so  you  cannot\n             implement your class' `#eql?` method using it."]
    pub fn rb_eql(lhs: VALUE, rhs: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates a textual representation of the given object.\n\n @param[in]  obj  Arbitrary ruby object.\n @return     An instance of ::rb_cString that represents `obj`.\n @note       This is  the default  implementation of `Object#to_s`  that each\n             subclasses want to override."]
    pub fn rb_any_to_s(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Generates a human-readable textual representation of the given object.  This\n is  largely similar  to Ruby  level `Object#inspect`  but not  the same;  it\n additionally escapes the inspection result  so that the string be compatible\n with that of default internal (or default external, if absent).\n\n @param[in]  obj  Arbitrary ruby object.\n @return     An instance of ::rb_cString that represents `obj`."]
    pub fn rb_inspect(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given object is a direct instance of the given class.\n\n @param[in]  obj            Arbitrary ruby object.\n @param[in]  klass          An instance of ::rb_cModule.\n @exception  rb_eTypeError  `klass` is neither module nor class.\n @retval     RUBY_Qtrue     `obj` is an instance of `klass`.\n @retval     RUBY_Qfalse    Otherwise."]
    pub fn rb_obj_is_instance_of(obj: VALUE, klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given object is  an instance (of possibly descendants) of the\n given class.\n\n @param[in]  obj            Arbitrary ruby object.\n @param[in]  klass          An instance of ::rb_cModule.\n @exception  rb_eTypeError  `klass` is neither module nor class.\n @retval     RUBY_Qtrue     `obj` is a `klass`.\n @retval     RUBY_Qfalse    Otherwise."]
    pub fn rb_obj_is_kind_of(obj: VALUE, klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Allocates an instance of the given class.\n\n @param[in]  klass          A class to instantiate.\n @exception  rb_eTypeError  `klass` is not a class.\n @return     An allocated, not yet initialised instance of `klass`.\n @note       It calls  the allocator defined by  rb_define_alloc_func().  You\n             cannot  use   this  function   to  define  an   allocator.   Use\n             rb_newobj_of(), #TypedData_Make_Struct or others, instead.\n @note       Usually  prefer  rb_class_new_instance() to  rb_obj_alloc()  and\n             rb_obj_call_init().\n @see        rb_class_new_instance()\n @see        rb_obj_call_init()\n @see        rb_define_alloc_func()\n @see        rb_newobj_of()\n @see        #TypedData_Make_Struct"]
    pub fn rb_obj_alloc(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Produces a shallow copy of the given object.  Its list of instance variables\n are copied, but  not the objects they reference.  It  also copies the frozen\n value state.\n\n @param[in]  obj            Arbitrary ruby object.\n @exception  rb_eException  `#initialize_copy` can raise anything.\n @return     A \"clone\" of `obj`.\n\n @internal\n\n Unlike ruby-level `Object#clone`, there is no way to control the frozen-ness\n of the return value."]
    pub fn rb_obj_clone(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Duplicates  the  given   object.   This  does  almost  the   same  thing  as\n rb_obj_clone() do.  However  it does not copy the singleton  class (if any).\n It also doesn't copy frozen-ness.\n\n @param[in]  obj            Arbitrary ruby object.\n @exception  rb_eException  `#initialize_copy` can raise anything.\n @return     A shallow copy of `obj`."]
    pub fn rb_obj_dup(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Default   implementation   of  `#initialize_copy`,   `#initialize_dup`   and\n `#initialize_clone`.  It  does almost  nothing.  Just raises  exceptions for\n checks.\n\n @param[in]  dst              The destination object.\n @param[in]  src              The source object.\n @exception  rb_eFrozenError  `dst` is frozen.\n @exception  rb_eTypeError    `dst` and `src` have different classes.\n @return     Always returns `dst`."]
    pub fn rb_obj_init_copy(src: VALUE, dst: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Just  calls  rb_obj_freeze_inline() inside.   Does  this  make any  sens  to\n extension libraries?\n\n @param[out]  obj  Object to freeze.\n @return      Verbatim `obj`."]
    pub fn rb_obj_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Just calls  RB_OBJ_FROZEN() inside.   Does this make  any sens  to extension\n libraries?\n\n @param[in]  obj          Object in question.\n @retval     RUBY_Qtrue   Yes it is.\n @retval     RUBY_Qfalse  No it isn't."]
    pub fn rb_obj_frozen_p(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Finds or  creates an integer  primary key of the  given object.  In  the old\n days  this  function  was  a  purely  arithmetic  operation  that  maps  the\n underlying memory  address where the  object resides into a  Ruby's integer.\n Some time around  2.x this changed.  It no longer  relates its return values\n to C level pointers.  This function  assigns some random number to the given\n object  if absent.   The  same number  will be  returned  on all  subsequent\n requests.  No two active objects share a number.\n\n @param[in]  obj  Arbitrary ruby object.\n @return     An instance of ::rb_cInteger which is an \"identifier\" of `obj`.\n\n @internal\n\n The \"some  random number\" is  in fact a  monotonic-increasing process-global\n unique integer, much like an  `INTEGER AUTO_INCREMENT PRIMARY KEY` column in\n a MySQL table."]
    pub fn rb_obj_id(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_obj_id(), except it hesitates from allocating a new instance\n of ::rb_cInteger.  rb_obj_id() could allocate ::RUBY_T_BIGNUM objects.  That\n allocation  might  perhaps  impact  negatively.  On  such  situations,  this\n function  instead returns  one-shot temporary  small integers  that need  no\n allocations at all.  The values are  guaranteed unique at the moment, but no\n future promise  is made; could  be reused.  Use of  this API should  be very\n instant.  It is a failure to store the returned integer to somewhere else.\n\n In short it is difficult to use.\n\n @param[in]  obj  Arbitrary ruby object.\n @return     An instance of ::rb_cInteger unique at the moment.\n\n @internal\n\n This is roughly the old behaviour of rb_obj_id()."]
    pub fn rb_memory_id(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Finds a \"real\" class.  As the name  implies there are class objects that are\n surreal.   This function  takes a  class, traverses  its ancestry  tree, and\n returns  its nearest  ancestor which  is neither  a module  nor a  singleton\n class.\n\n @param[in]  klass        An instance of ::rb_cClass.\n @retval     RUBY_Qfalse  No real class in `klass`' ancestry tree.\n @retval     klass        `klass` itself is a real class.\n @retval     otherwise    Nearest ancestor of `klass` who is real."]
    pub fn rb_class_real(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Determines if the given two modules are relatives.\n\n @param[in]  scion          Possible subclass.\n @param[in]  ascendant      Possible superclass.\n @exception  rb_eTypeError  `ascendant` is not a module.\n @retval     RUBY_Qtrue     `scion` inherits, or is equal to `ascendant`.\n @retval     RUBY_Qfalse    `ascendant` inherits `scion`.\n @retval     RUBY_Qnil      They are not relatives."]
    pub fn rb_class_inherited_p(scion: VALUE, ascendant: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the parent of the given class.\n\n @param[in]  klass          A child class.\n @exception  rb_eTypeError  `klass` is a `Class.allocate`.\n @retval     RUBY_Qfalse    `klass` has no superclass.\n @retval     otherwise      `klass`' superclass.\n\n @internal\n\n Is there any class except ::rb_cBasicObject, that has no superclass?"]
    pub fn rb_class_superclass(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts an object into another type.  Calls the specified conversion method\n if necessary.\n\n @param[in]  val            An object to convert.\n @param[in]  type           A value of enum ::ruby_value_type.\n @param[in]  name           Name to display on error (e.g. \"Array\").\n @param[in]  mid            Conversion method (e.g. \"to_ary\").\n @exception  rb_eTypeError  Failed to convert.\n @return     An object of the specified type."]
    pub fn rb_convert_type(
        val: VALUE,
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        mid: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_convert_type(),  except it  returns ::RUBY_Qnil  instead of\n raising  exceptions,  in  case  of  conversion  failure.   It  still  raises\n exceptions  for various  reasons,  like when  the  conversion method  itself\n raises, though.\n\n @param[in]  val            An object to convert.\n @param[in]  type           A value of enum ::ruby_value_type.\n @param[in]  name           Name to display on error (e.g. \"Array\").\n @param[in]  mid            Conversion method (e.g. \"to_ary\").\n @exception  rb_eTypeError  The `mid` does not generate `type`.\n @retval     RUBY_Qnil      No conversion defined.\n @retval     otherwise      An object of the specified type."]
    pub fn rb_check_convert_type(
        val: VALUE,
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        mid: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_check_convert_type(), except the  return value type is fixed\n to ::rb_cInteger.\n\n @param[in]  val            An object to convert.\n @param[in]  mid            Conversion method (e.g. \"to_ary\").\n @exception  rb_eTypeError  The `mid` does not generate an integer.\n @retval     RUBY_Qnil      No conversion defined.\n @retval     otherwise      An instance of ::rb_cInteger."]
    pub fn rb_check_to_integer(val: VALUE, mid: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " This is complicated.\n\n   - When  the passed  object is  already  an instance  of ::rb_cFloat,  just\n     returns it as-is.\n\n   - When  the passed  object is  something  numeric, the  function tries  to\n     convert it using `#to_f` method.\n\n       - If that conversion fails (this happens for instance when the numeric\n         is a complex) it returns ::RUBY_Qnil.\n\n       - Otherwise returns the conversion result.\n\n   - Otherwise it also returns ::RUBY_Qnil.\n\n @param[in]  val        An object to convert.\n @retval     RUBY_Qnil  Conversion from `val` to float is undefined.\n @retval     otherwise  Converted result."]
    pub fn rb_check_to_float(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_check_to_int(),  except  it raises  in  case of  conversion\n mismatch.\n\n @param[in]  val            An object to convert.\n @exception  rb_eTypeError  `#to_int` does not generate an integer.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_to_int(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_check_to_integer(), except it uses `#to_int` for conversion.\n\n @param[in]  val            An object to convert.\n @exception  rb_eTypeError  `#to_int` does not return an integer.\n @retval     RUBY_Qnil      No conversion defined.\n @retval     otherwise      An instance of ::rb_cInteger."]
    pub fn rb_check_to_int(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This  is the  logic behind  `Kernel#Integer`.  Numeric  types are  converted\n directly,  with  floating  point   numbers  being  truncated.   Strings  are\n interpreted  strictly; only  leading/trailing whitespaces,  plus/minus sign,\n radix  indicators  such  as  `0x`,  digits,  and  underscores  are  allowed.\n Anything else are converted by first trying `#to_int`, then `#to_i`.\n\n This is slightly stricter than `String#to_i`.\n\n @param[in]  val            An object to convert.\n @exception  rb_eArgError   Malformed `val` passed.\n @exception  rb_eTypeError  No conversion defined.\n @return     An instance of ::rb_cInteger."]
    pub fn rb_Integer(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_check_to_float(), except it raises on error.\n\n @param[in]  val            An object to convert.\n @exception  rb_eTypeError  No conversion defined.\n @return     An instance of ::rb_cFloat."]
    pub fn rb_to_float(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This  is  the logic  behind  `Kernel#Float`.   Numeric types  are  converted\n directly  to the  nearest value  that a  Float can  represent.  Strings  are\n interpreted strictly;  only leading/trailing whitespaces are  allowed except\n what `strtod` understands.  Anything else are converted using `#to_f`.\n\n This is slightly stricter than `String#to_f`.\n\n @param[in]  val            An object to convert.\n @exception  rb_eArgError   Malformed `val` passed.\n @exception  rb_eTypeError  No conversion defined.\n @return     An instance of ::rb_cFloat."]
    pub fn rb_Float(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is the logic behind  `Kernel#String`.  Arguments are converted by first\n trying `#to_str`, then `#to_s`.\n\n @param[in]  val            An object to convert.\n @exception  rb_eTypeError  No conversion defined.\n @return     An instance of ::rb_cString."]
    pub fn rb_String(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is the  logic behind `Kernel#Array`.  Arguments are  converted by first\n trying `#to_ary`,  then `#to_a`,  and if  both failed,  returns an  array of\n length 1 that contains the passed argument as the sole contents.\n\n @param[in]  val  An object to convert.\n @return     An instance of ::rb_cArray."]
    pub fn rb_Array(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is  the logic behind  `Kernel#Hash`.  Arguments are converted  by first\n trying `#to_hash`.  if it failed, and  the argument is either ::RUBY_Qnil or\n an empty array, returns an empty hash.  Otherwise an exception is raised.\n\n @param[in]  val            An object to convert.\n @exception  rb_eTypeError  No conversion defined.\n @return     An instance of ::rb_cHash."]
    pub fn rb_Hash(val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts a textual representation of a  real number into a numeric, which is\n the nearest value that the return type  can represent, of the value that the\n argument represents.  This is in fact  a 2-in-1 function whose behaviour can\n be controlled using  the second (mode) argument.  If the  mode is zero, this\n function is in \"historical\"  mode which only understands \"floating-constant\"\n defined at ISO/IEC 9899:1990 section 6.1.3.1.  If the mode is nonzero, it is\n in  \"extended\"  mode,  which  also  accepts  \"hexadecimal-floating-constant\"\n defined at ISO/IEC 9899:2018 section 6.4.4.2.\n\n @param[in]  str           A textual representation of a real number.\n @param[in]  mode          Conversion mode, as described above.\n @exception  rb_eArgError  Malformed `str` passed.\n @see        https://bugs.ruby-lang.org/issues/2969\n @note       Null pointers are allowed, and it returns 0.0 then."]
    pub fn rb_cstr_to_dbl(str_: *const ::std::os::raw::c_char, mode: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Identical to rb_cstr_to_dbl(), except it  accepts a Ruby's string instead of\n C's.\n\n @param[in]  str           A textual representation of a real number.\n @param[in]  mode          Conversion mode, as described in rb_cstr_to_dbl().\n @exception  rb_eArgError  Malformed `str` passed.\n @see        https://bugs.ruby-lang.org/issues/2969"]
    pub fn rb_str_to_dbl(str_: VALUE, mode: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Calculates an ID of attribute writer.   For instance it returns `:foo=` when\n passed `:foo`.\n\n @param[in]  id             An id.\n @exception  rb_eNameError  `id` is not for attributes (e.g. operator).\n @return     Calculated name of attribute writer."]
    pub fn rb_id_attrset(id: ID) -> ID;
}
extern "C" {
    #[doc = " Classifies the given ID, then sees if it is a constant.  In case an ID is in\n Unicode (likely), its  \"constant\"-ness is determined if  its first character\n is  either upper  case or  title case.   Otherwise it  is detected  if case-\n folding the first character changes its case or not.\n\n @param[in]  id  An id to classify.\n @retval     1   It is a constant.\n @retval     0   It isn't."]
    pub fn rb_is_const_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies the  given ID, then  sees if it is  a global variable.   A global\n variable must start with `$`.\n\n @param[in]  id  An id to classify.\n @retval     1   It is a global variable.\n @retval     0   It isn't."]
    pub fn rb_is_global_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies  the given  ID, then  sees  if it  is an  instance variable.   An\n instance variable must start with `@`, but not `@@`.\n\n @param[in]  id  An id to classify.\n @retval     1   It is an instance variable.\n @retval     0   It isn't."]
    pub fn rb_is_instance_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies  the given  ID,  then sees  if  it is  an  attribute writer.   An\n attribute writer is otherwise a local variable, except it ends with `=`.\n\n @param[in]  id  An id to classify.\n @retval     1   It is an attribute writer.\n @retval     0   It isn't."]
    pub fn rb_is_attrset_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies the  given ID,  then sees  if it  is a  class variable.   A class\n variable is must start with `@@`.\n\n @param[in]  id  An id to classify.\n @retval     1   It is a class variable.\n @retval     0   It isn't."]
    pub fn rb_is_class_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies the  given ID,  then sees  if it  is a  local variable.   A local\n variable starts  with a lowercase  character, followed by  some alphanumeric\n characters or `_`, then ends with anything other than `!`, `?`, or `=`.\n\n @param[in]  id  An id to classify.\n @retval     1   It is a local variable.\n @retval     0   It isn't."]
    pub fn rb_is_local_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Classifies the  given ID,  then sees  if it  is a  junk ID.   An ID  with no\n special syntactic structure is considered  junk.  This category includes for\n instance punctuation.\n\n @param[in]  id  An id to classify.\n @retval     1   It is a junk.\n @retval     0   It isn't."]
    pub fn rb_is_junk_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sees if  the passed C string  constructs a valid syntactic  symbol.  Invalid\n ones for instance includes whitespaces.\n\n @param[in]  str  A C string to check.\n @retval     1    It is a valid symbol name.\n @retval     0    It is invalid as a symbol name."]
    pub fn rb_symname_p(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the last match, or `Regexp.last_match`, or the `$~`.  You don't have\n to use it, because in reality you can get `$~` using rb_gv_get() as usual.\n\n @retval  RUBY_Qnil  The method has not ran a regular expression.\n @retval  otherwise  An instance of ::rb_cMatch."]
    pub fn rb_backref_get() -> VALUE;
}
extern "C" {
    #[doc = " Updates `$~`.  You don't have to use it, because in reality you can set `$~`\n using rb_gv_set() as usual.\n\n @param[in]  md  Arbitrary Ruby object.\n @post       The passed object is assigned to `$~`.\n\n @internal\n\n Yes, this  function bypasses  the Check_Type()  that would  normally prevent\n evil souls from assigning  evil objects to `$~`.  Use of  this function is a\n really bad smell."]
    pub fn rb_backref_set(md: VALUE);
}
extern "C" {
    #[doc = " Queries the last  line, or the `$_`.   You don't have to use  it, because in\n reality you can get `$_` using rb_gv_get() as usual.\n\n @retval  RUBY_Qnil  There has never been a \"line\" yet.\n @retval  otherwise  The last set `$_` value."]
    pub fn rb_lastline_get() -> VALUE;
}
extern "C" {
    #[doc = " Updates `$_`.  You don't have to use it, because in reality you can set `$_`\n using rb_gv_set() as usual.\n\n @param[in]  str  Arbitrary Ruby object.\n @post       The passed object is assigned to `$_`.\n\n @internal\n\n Unlike `$~`, you can assign non-strings to `$_`, even from ruby scripts."]
    pub fn rb_lastline_set(str_: VALUE);
}
extern "C" {
    #[doc = " Collects every single bits of symbols  that have ever interned in the entire\n history of the current process.\n\n @return  An array that contains all symbols that have ever existed."]
    pub fn rb_sym_all_symbols() -> VALUE;
}
extern "C" {
    #[doc = " Sets the \"last status\", or the `$?`.\n\n @param[in]  status  The termination status, as defined in `waitpid(3posix)`.\n @param[in]  pid     The last child of the current process.\n @post       `$?` is updated."]
    pub fn rb_last_status_set(status: ::std::os::raw::c_int, pid: pid_t);
}
extern "C" {
    #[doc = " Queries the \"last status\", or the `$?`.\n\n @retval  RUBY_Qnil  The current thread has no dead children.\n @retval  otherwise  An instance of Process::Status  describing the status of\n                     the child that was most recently `wait`-ed."]
    pub fn rb_last_status_get() -> VALUE;
}
extern "C" {
    #[doc = " Executes a shell command.\n\n @warning    THIS FUNCTION RETURNS on error!\n @param[in]  cmd  Passed to the shell.\n @retval     -1   Something prevented the command execution.\n @post       Upon successful execution this function doesn't return.\n @post       In case it returns the `errno` is set properly."]
    pub fn rb_proc_exec(cmd: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replaces the current process by running the given external command.  This is\n the implementation of `Kernel#exec`.\n\n @param[in]  argc                 Number of objects in `argv`.\n @param[in]  argv                 Command and its options to execute.\n @exception  rb_eTypeError        Invalid options e.g. non-String argv.\n @exception  rb_eArgError         Invalid options e.g. redirection cycle.\n @exception  rb_eNotImpError      Not implemented e.g. no `setuid(2)`.\n @exception  rb_eRuntimeError     `Process::UID.switch` in operation.\n @exception  rb_eSystemCallError  `execve(2)` failed.\n @warning    This function doesn't return.\n @warning    On failure it raises.  On success the process is replaced.\n\n @internal\n\n @shyouhei have to say that the  rdoc for `Kernel#exec` is fairly incomplete.\n AFAIK this function ultimately takes the following signature:\n\n ```rbs\n type boolx  = bool | nil                # !=  `boolish`\n\n type rlim_t = Integer                   # rlim_cur\n             | [ Integer, Integer ]      # rlim_cur, rlim_max\n\n type uid_t  = String                    # e.g. \"root\"\n             | Integer                   # e.g. 0\n\n type gid_t  = String                    # e.g. \"wheel\"\n             | Integer                   # e.g. 0\n\n type fmode  = String                    # e.g. \"rb\"\n             | Integer                   # e.g. O_RDONLY | O_BINARY\n\n type mode_t = Integer                   # e.g. 0644\n\n type pgrp   = true                      # Creates a dedicated pgroup\n             | 0                         # ditto\n             | nil                       # Uses the current one\n             | Integer                   # Uses this specific pgroup\n\n type fd     = :in                       # STDIN\n             | :out                      # STDOUT\n             | :err                      # STDERR\n             | IO                        # This specific IO\n             | Integer                   # A file descriptor of this #\n\n type src    = fd | [ fd ]\n type dst    = :close                    # Intuitive\n             | fd                        # Intuitive\n             | String                    # Open a file at this path\n             | [ String ]                # ... using O_RDONLY\n             | [ String, fmode ]         # ... using this mode\n             | [ String, fmode, mode_t ] # ... with a permission\n             | [ :child, fd ]            # fd of child side\n\n type redir  = Hash[ src, dst ]\n\n # ----\n\n # Key-value pair of environment variables\n type envp  = Hash[ String, String ]\n\n # Actual name (and the name passed to the subprocess if any)\n type arg0  = String | [ String, String ]\n\n # Arbitrary string parameters\n type argv  = String\n\n # Exec options:\n type argh  = redir | {\n   chdir:             String, # Working directory\n   close_others:      boolx,  # O_CLOEXEC like behaviour\n   gid:               gid_t,  # setegid(2)\n   pgrooup:           pgrp,   # setpgrp(2)\n   rlimit_as:         rlim_t, # setrlimit(2)\n   rlimit_core:       rlim_t, # ditto\n   rlimit_cpu:        rlim_t, # ditto\n   rlimit_data:       rlim_t, # ditto\n   rlimit_fsize:      rlim_t, # ditto\n   rlimit_memlock:    rlim_t, # ditto\n   rlimit_msgqueue:   rlim_t, # ditto\n   rlimit_nice:       rlim_t, # ditto\n   rlimit_nofile:     rlim_t, # ditto\n   rlimit_nproc:      rlim_t, # ditto\n   rlimit_rss:        rlim_t, # ditto\n   rlimit_rtprio:     rlim_t, # ditto\n   rlimit_rttime:     rlim_t, # ditto\n   rlimit_sbsize:     rlim_t, # ditto\n   rlimit_sigpending: rlim_t, # ditto\n   rlimit_stack:      rlim_t, # ditto\n   uid:               uid_t,  # seteuid(2)\n   umask:             mode_t, # umask(2)\n   unsetenv_others:   boolx   # Unset everything except the passed envp\n }\n\n # ====\n\n class Kernel\n   def self?.exec\n     : (          arg0 cmd, *argv args           ) -> void\n     | (          arg0 cmd, *argv args, argh opts) -> void\n     | (envp env, arg0 cmd, *argv args           ) -> void\n     | (envp env, arg0 cmd, *argv args, argh opts) -> void\n end\n ```"]
    pub fn rb_f_exec(argc: ::std::os::raw::c_int, argv: *const VALUE) -> !;
}
extern "C" {
    #[doc = " Waits for a process, with releasing GVL.\n\n @param[in]   pid        Process ID.\n @param[out]  status     The wait status is filled back.\n @param[in]   flags      Wait options.\n @retval      -1         System call failed, errno set.\n @retval      0          WNOHANG but no waitable children.\n @retval      otherwise  A process ID that was `wait()`-ed.\n @post        Upon successful return `status` is updated to have the process'\n              status.\n @note        `status` can be NULL.\n @note        The arguments are passed  through to underlying system call(s).\n              Can have special meanings.  For instance passing `(rb_pid_t)-1`\n              to   `pid`   means   it   waits  for   any   processes,   under\n              POSIX-compliant situations."]
    pub fn rb_waitpid(
        pid: pid_t,
        status: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    #[doc = " This is  a shorthand of  rb_waitpid without status  and flags.  It  has been\n like this  since the very beginning.   The initial revision already  did the\n same thing.  Not sure why, then, it has been named `syswait`.  AFAIK this is\n different from how `wait(3posix)` works.\n\n @param[in]  pid  Passed to rb_waitpid()."]
    pub fn rb_syswait(pid: pid_t);
}
extern "C" {
    #[doc = " Identical  to rb_f_exec(),  except  it  spawns a  child  process instead  of\n replacing the current one.\n\n @param[in]  argc              Number of objects in `argv`.\n @param[in]  argv              Command and its options to execute.\n @exception  rb_eTypeError     Invalid options e.g. non-String argv.\n @exception  rb_eArgError      Invalid options e.g. redirection cycle.\n @exception  rb_eNotImpError   Not implemented e.g. no `setuid(2)`.\n @exception  rb_eRuntimeError  `Process::UID.switch` in operation.\n @retval     -1                Child process died for some reason.\n @retval     otherwise         The ID of the born child.\n\n @internal\n\n This  is _really_  identical  to rb_f_exec()  until  ultimately calling  the\n system  call.    Almost  everything   are  shared   among  these   two  (and\n rb_f_system())."]
    pub fn rb_spawn(argc: ::std::os::raw::c_int, argv: *const VALUE) -> pid_t;
}
extern "C" {
    #[doc = " Identical  to rb_spawn(),  except  you can  additionally  know the  detailed\n situation in case of abnormal parturitions.\n\n @param[in]   argc              Number of objects in `argv`.\n @param[in]   argv              Command and its options to execute.\n @param[out]  errbuf            Error description write-back buffer.\n @param[in]   buflen            Number of bytes of `errbuf`, including NUL.\n @exception   rb_eTypeError     Invalid options e.g. non-String argv.\n @exception   rb_eArgError      Invalid options e.g. redirection cycle.\n @exception   rb_eNotImpError   Not implemented e.g. no `setuid(2)`.\n @exception   rb_eRuntimeError  `Process::UID.switch` in operation.\n @retval      -1                Child process died for some reason.\n @retval      otherwise         The ID of the born child.\n @post        In case  of `-1`, at most  `buflen` bytes of the  reason why is\n              written back to `errbuf`."]
    pub fn rb_spawn_err(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        errbuf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> pid_t;
}
extern "C" {
    #[doc = " Gathers info about resources consumed by the current process.\n\n @param[in]  _  Not used.  Pass anything.\n @return     An instance of `Process::Tms`.\n\n @internal\n\n This function  might or might  not exist depending on  `./confiugre` result.\n It must be a portability hell.  Better not use."]
    pub fn rb_proc_times(__: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " \"Detaches\"  a subprocess.   In POSIX  systems every  child processes  that a\n process creates must be `wait(2)`-ed.  A child process that died yet has not\n been  waited so  far  is called  a  \"zombie\", which  more  or less  consumes\n resources.   This function  automates reclamation  of such  processes.  Once\n after this function successfully returns  you can basically forget about the\n child process.\n\n @param[in]  pid  Process to wait.\n @return     An instance of ::rb_cThread which is `waitpid(2)`-ing `pid`.\n @post       You can just forget about the return value.  GC reclaims it.\n @post       You  can  know the  exit  status  by  querying `#value`  of  the\n             return value (which is a blocking operation)."]
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
}
extern "C" {
    #[doc = " Generates a 32 bit random number.\n\n @return  A random number.\n @note    Now  that  we  have  ractors,  the  RNG  behind  this  function  is\n          per-ractor."]
    pub fn rb_genrand_int32() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Generates a `double` random number.\n\n @return  A random number.\n @note    This function shares the RNG with rb_genrand_int32()."]
    pub fn rb_genrand_real() -> f64;
}
extern "C" {
    #[doc = " Resets the RNG behind rb_genrand_int32()/rb_genrand_real().\n\n @post  The (now per-ractor) default RNG's internal state is cleared."]
    pub fn rb_reset_random_seed();
}
extern "C" {
    #[doc = " Generates a String of random bytes.\n\n @param[in,out]  rnd  An instance of ::rb_cRandom.\n @param[in]      n    Requested number of bytes.\n @return         An instance of ::rb_cString, of binary, of `n` bytes length,\n                 whose contents are random bits.\n\n @internal\n\n @shyouhei doesn't know if this is an  Easter egg or an official feature, but\n this function can  take a wider range of objects,  such as `Socket::Ifaddr`.\n The arguments are just silently ignored and the default RNG is used instead,\n if they are non-RNG."]
    pub fn rb_random_bytes(rnd: VALUE, n: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_genrand_int32(), except it generates using the passed RNG.\n\n @param[in,out]  rnd  An instance of ::rb_cRandom.\n @return         A random number."]
    pub fn rb_random_int32(rnd: VALUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Identical to rb_genrand_real(), except it generates using the passed RNG.\n\n @param[in,out]  rnd  An instance of ::rb_cRandom.\n @return         A random number."]
    pub fn rb_random_real(rnd: VALUE) -> f64;
}
extern "C" {
    #[doc = " Identical  to  rb_genrand_ulong_limited(),  except it  generates  using  the\n passed RNG.\n\n @param[in,out]  rnd    An instance of ::rb_cRandom.\n @param[in]      limit  Max possible return value.\n @return         A random number, distributed in `[0, limit]` interval.\n @note           Note it can return `limit`.\n @note           Whether  the  return  value  distributes  uniformly  in  the\n                 interval or not depends on  how the argument RNG behaves; at\n                 least in case of MT19937 it does."]
    pub fn rb_random_ulong_limited(
        rnd: VALUE,
        limit: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Generates a random number whose upper limit is `i`.\n\n @param[in]  i  Max possible return value.\n @return     A random number, uniformly distributed in `[0, limit]` interval.\n @note       Note it can return `i`."]
    pub fn rb_genrand_ulong_limited(i: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Creates a new Range.\n\n @param[in]  beg           \"Left\" or \"lowest\" endpoint of the range.\n @param[in]  end           \"Right\" or \"highest\" endpoint of the range.\n @param[in]  excl          Whether the range is open-ended.\n @exception  rb_eArgError  `beg` and `end` are not comparable.\n @note       These days both  endpoints can be ::RUBY_Qnil,  which means that\n             endpoint is unbound."]
    pub fn rb_range_new(beg: VALUE, end: VALUE, excl: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Deconstructs  a numerical  range.  As  the  arguments are  `long` based,  it\n expects everything are in the `long` domain.\n\n @param[in]   range           A range of numerical endpoints.\n @param[out]  begp            Return value buffer.\n @param[out]  lenp            Return value buffer.\n @param[in]   len             Updated length.\n @param[in]   err             In case `len` is out of range...\n                                - `0`: returns ::RUBY_Qnil.\n                                - `1`: raises  ::rb_eRangeError.\n                                - `2`: `beg` and `len` expanded accordingly.\n @exception   rb_eTypeError   `range` is not a numerical range.\n @exception   rb_eRangeError  `range` cannot fit into `long`.\n @retval      RUBY_Qfalse     `range` is not an ::rb_cRange.\n @retval      RUBY_Qnil       `len` is out of `range` but `err` is zero.\n @retval      RUBY_Qtrue      Otherwise.\n @post        `beg` is the (possibly updated) left endpoint.\n @post        `len` is the (possibly updated) length of the range.\n\n @internal\n\n The complex  error handling  switch reflects the  fact that  `Array#[]=` and\n `String#[]=` behave differently when they take ranges."]
    pub fn rb_range_beg_len(
        range: VALUE,
        begp: *mut ::std::os::raw::c_long,
        lenp: *mut ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        err: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Deconstructs a range into its components.\n\n @param[in]   range        Range or range-ish object.\n @param[out]  begp         Return value buffer.\n @param[out]  endp         Return value buffer.\n @param[out]  exclp        Return value buffer.\n @retval      RUBY_Qfalse  `range` is not an instance of ::rb_cRange.\n @retval      RUBY_Qtrue   Argument pointers are updated.\n @post        `*begp` is the left endpoint of the range.\n @post        `*endp` is the right endpoint of the range.\n @post        `*exclp` is whether the range is open-ended or not."]
    pub fn rb_range_values(
        range: VALUE,
        begp: *mut VALUE,
        endp: *mut VALUE,
        exclp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_rational_new(), except it skips argument validations.  It is\n thus  dangerous  for extension  libraries.   For  instance `1/0r`  could  be\n constructed using this.\n\n @param[in]  num            Numerator, an instance of ::rb_cInteger.\n @param[in]  den            Denominator, an instance of ::rb_cInteger.\n @exception  rb_eTypeError  Either argument is not an Integer.\n @return     An instance of ::rb_cRational whose value is `(num/den)r`."]
    pub fn rb_rational_raw(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Constructs a Rational,  with reduction.  This returns  for instance `(2/3)r`\n for `rb_rational_new(INT2NUM(-384), INT2NUM(-576))`.\n\n @param[in]  num               Numerator, an instance of ::rb_cInteger.\n @param[in]  den               Denominator, an instance of ::rb_cInteger.\n @exception  rb_eZeroDivError  `den` is zero.\n @return     An instance of ::rb_cRational whose value is `(num/den)r`."]
    pub fn rb_rational_new(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Converts various values into a Rational.  This function accepts:\n\n - Instances of ::rb_cInteger (taken as-is),\n - Instances of ::rb_cRational (taken as-is),\n - Instances of ::rb_cFloat (applies `#to_r`),\n - Instances of ::rb_cComplex (applies `#to_r`),\n - Instances of ::rb_cString (applies `#to_r`),\n - Other objects that respond to `#to_r`.\n\n It (possibly  recursively) applies  `#to_r` until  both sides  become either\n Integer or Rational, then divides them.\n\n As a  special case, passing  ::RUBY_Qundef to `den`  is the same  as passing\n `RB_INT2NUM(1)`.\n\n @param[in]  num                   Numerator (see above).\n @param[in]  den                   Denominator (see above).\n @exception  rb_eTypeError         Passed something not described above.\n @exception  rb_eFloatDomainError  `#to_r` produced Nan/Inf.\n @exception  rb_eZeroDivError      `#to_r` produced zero for `den`.\n @return     An instance of ::rb_cRational whose value is `(num/den)r`.\n\n @internal\n\n This was the implementation of `Kernel#Rational` before, but they diverged."]
    pub fn rb_Rational(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the numerator of the passed Rational.\n\n @param[in]  rat  An instance of ::rb_cRational.\n @return     Its numerator part, which is an instance of ::rb_cInteger."]
    pub fn rb_rational_num(rat: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the denominator of the passed Rational.\n\n @param[in]  rat  An instance of ::rb_cRational.\n @return     Its  denominator part,  which  is an  instance of  ::rb_cInteger\n             greater than or equal to one.."]
    pub fn rb_rational_den(rat: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Simplified  approximation of  a float.   It returns  a rational  `rat` which\n satisfies:\n\n ```\n flt - |prec| <= rat <= flt + |prec|\n ```\n\n ```ruby\n 3.141592.rationalize(0.001) # => (201/64)r\n 3.141592.rationalize(0.01)' # => (22/7)r\n 3.141592.rationalize(0.1)'  # => (16/5)r\n 3.141592.rationalize(1)'    # => (3/1)r\n ```\n\n @param[in]  flt   An instance of ::rb_cFloat to rationalise.\n @param[in]  prec  Another ::rb_cFloat, which is the \"precision\".\n @return     Approximation of `flt`, in ::rb_cRational."]
    pub fn rb_flt_rationalize_with_prec(flt: VALUE, prec: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical   to   rb_flt_rationalize_with_prec(),  except   it   auto-detects\n appropriate precision depending on the passed value.\n\n @param[in]  flt   An instance of ::rb_cFloat to rationalise.\n @return     Approximation of `flt`, in ::rb_cRational."]
    pub fn rb_flt_rationalize(flt: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  st_locale_insensitive_strcasecmp(), except  it is  timing safe\n and returns something different.\n\n @param[in]  s1  Comparison LHS.\n @param[in]  s2  Comparison RHS.\n @param[in]  n   Comparison shall stop after first `n` bytes are scanned.\n @retval     <0  `s1` is \"less\" than `s2`.\n @retval      0  Both sides converted into lowercase would be identical.\n @retval     >0  `s1` is \"greater\" than `s2`.\n @note       The \"case\" here means that of the POSIX Locale.\n\n @internal\n\n Can accept NULLs as long as n is also 0, and returns 0."]
    pub fn rb_memcicmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Asserts  that  the given  MatchData  is  \"occupied\".  MatchData  shares  its\n backend storages  with its  Regexp object.   But programs  can destructively\n tamper its  contents.  Calling this  function beforehand shall  prevent such\n modifications to spill over into other objects.\n\n @param[out]  md  Target instance of ::rb_cMatch.\n @post        The object is \"busy\".\n\n @internal\n\n There is rb_match_unbusy internally, but extension libraries are left unable\n to do so."]
    pub fn rb_match_busy(md: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_reg_nth_match(), except it just returns Boolean.  This could\n skip allocating a  returning string, resulting in  reduced memory footprints\n if applicable.\n\n @param[in]  n              Match index.\n @param[in]  md             An instance of ::rb_cMatch.\n @exception  rb_eTypeError  `md` is not initialised.\n @retval     RUBY_Qnil      There is no `n`-th capture.\n @retval     RUBY_Qfalse    There is a `n`-th capture and is empty.\n @retval     RUBY_Qtrue     There is a `n`-th capture that has something.\n\n @internal\n\n @shyouhei   wonders:  why   there   are   both  rb_reg_match_defined()   and\n rb_match_nth_defined, which  are largely the  same things, but do  not share\n their implementations at all?"]
    pub fn rb_reg_nth_defined(n: ::std::os::raw::c_int, md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the nth captured substring.\n\n @param[in]  n              Match index.\n @param[in]  md             An instance of ::rb_cMatch.\n @exception  rb_eTypeError  `md` is not initialised.\n @retval     RUBY_Qnil      There is no `n`-th capture.\n @retval     otherwise      An allocated instance of  ::rb_cString containing\n                            the contents captured."]
    pub fn rb_reg_nth_match(n: ::std::os::raw::c_int, md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the index of the given named capture.  Captures could be named.  But\n that doesn't mean named ones are  not indexed.  A regular expression can mix\n named  and non-named  captures, and  they  are all  indexed.  This  function\n converts from a name to its index.\n\n @param[in]  match           An instance of ::rb_cMatch.\n @param[in]  backref         Capture name, in String, Symbol, or Numeric.\n @exception  rb_eIndexError  No such named capture.\n @return     The index of the given name."]
    pub fn rb_reg_backref_number(match_: VALUE, backref: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This just returns the argument, stringified.  What a poor name.\n\n @param[in]  md  An instance of ::rb_cMatch.\n @return     Its 0th capture (i.e. entire matched string)."]
    pub fn rb_reg_last_match(md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " The portion of the original string before the given match.\n\n @param[in]  md  An instance of ::rb_cMatch.\n @return     Its \"prematch\".  This is perl's ``$```."]
    pub fn rb_reg_match_pre(md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " The portion of the original string after the given match.\n\n @param[in]  md  An instance of ::rb_cMatch.\n @return     Its \"postmatch\".  This is perl's `$'`."]
    pub fn rb_reg_match_post(md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " The portion of the original string that captured at the very last.\n\n @param[in]  md  An instance of ::rb_cMatch.\n @return     Its \"lastmatch\".  This is perl's `$+`."]
    pub fn rb_reg_match_last(md: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_reg_new(),  except it takes the expression  in Ruby's string\n instead of C's.\n\n @param[in]  src              Source code in String.\n @param[in]  opts             Options e.g. ONIG_OPTION_MULTILINE.\n @exception  rb_eRegexpError  `src` and `opts` do not interface.\n @return     Allocated new instance of ::rb_cRegexp."]
    pub fn rb_reg_new_str(src: VALUE, opts: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Creates a new Regular expression.\n\n @param[in]  src              Source code.\n @param[in]  len              `strlen(src)`.\n @param[in]  opts             Options e.g. ONIG_OPTION_MULTILINE.\n @return     Allocated new instance of ::rb_cRegexp."]
    pub fn rb_reg_new(
        src: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        opts: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Allocates an instance of ::rb_cRegexp.\n\n @private\n\n Nobody  should  call  this  function.   Regular  expressions  that  are  not\n initialised must not exist in the wild."]
    pub fn rb_reg_alloc() -> VALUE;
}
extern "C" {
    #[doc = " Initialises an instance of ::rb_cRegexp.\n\n @private\n\n This just raises  for ordinal regexp objects.  Extension  libraries must not\n use."]
    pub fn rb_reg_init_str(re: VALUE, s: VALUE, options: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " This is the match operator.\n\n @param[in]  re               An instance of ::rb_cRegexp.\n @param[in]  str              An instance of ::rb_cString.\n @exception  rb_eTypeError    `str` is not a string.\n @exception  rb_eRegexpError  Error inside of Onigmo (unlikely).\n @retval     RUBY_Qnil        Match failed.\n @retval     otherwise        Matched  position  (character index  inside  of\n                              `str`).\n @post       `Regexp.last_match` is updated.\n @post       `$&`, `$~`, etc., are updated.\n @note       If you  do this in  ruby, named  captures are assigned  to local\n             variable of the local scope.  But that doesn't happen here.  The\n             assignment is done by the interpreter."]
    pub fn rb_reg_match(re: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_reg_match(),  except it  matches against  rb_lastline_get()\n (or, the `$_`).\n\n @param[in]  re               An instance of ::rb_cRegexp.\n @exception  rb_eRegexpError  Error inside of Onigmo (unlikely).\n @retval     RUBY_Qnil        Match failed or `$_` is absent.\n @retval     otherwise        Matched  position  (character index  inside  of\n                              `$_`).\n @post       `Regexp.last_match` is updated.\n @post       `$&`, `$~`, etc., are updated."]
    pub fn rb_reg_match2(re: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the options of the passed regular expression.\n\n @param[in]  re  An instance of ::rb_cRegexp.\n @return     Its options.\n @note       Possible return values are defined in Onigmo.h."]
    pub fn rb_reg_options(re: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The value of `$0` at process bootup.\n\n @note  This is just a snapshot of `$0`, not the backend storage of it.  `$0`\n        could  become something  different because  it is  a writable  global\n        variable.  Modifying  it for instance affects  `ps(1)` output.  Don't\n        assume they are synced."]
    pub static mut rb_argv0: VALUE;
}
extern "C" {
    #[doc = " Queries the arguments passed to the current process that you can access from\n Ruby as `ARGV`.\n\n @return  An array of strings containing arguments passed to the process."]
    pub fn rb_get_argv() -> VALUE;
}
extern "C" {
    #[doc = " Loads the given  file.  This function opens the given  pathname for reading,\n parses the contents as a Ruby  script, and returns an opaque \"node\" pointer.\n You can then pass it to ruby_run_node() for evaluation.\n\n @param[in]  file  File name, or \"-\" to read from stdin.\n @return     Opaque \"node\" pointer."]
    pub fn rb_load_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Identical to rb_load_file(), except it takes the argument as a Ruby's string\n instead of C's.\n\n @param[in]  file  File name, or \"-\" to read from stdin.\n @return     Opaque \"node\" pointer."]
    pub fn rb_load_file_str(file: VALUE) -> *mut ::std::os::raw::c_void;
}
#[doc = " The data structure which wraps the  fd_set bitmap used by `select(2)`.  This\n allows Ruby to use FD sets larger than what has been historically allowed on\n modern platforms.\n\n @internal\n\n ... but because  this header file is  included only when the  system is with\n that \"historic restrictions\", this is nothing more than an alias of fd_set."]
pub type rb_fdset_t = fd_set;
extern "C" {
    #[doc = " Waits for multiple file descriptors at once.  This is basically a wrapper of\n system-provided select() with releasing GVL, to allow other Ruby threads run\n in parallel.\n\n @param[in]      nfds       Max FD in everything passed, plus one.\n @param[in,out]  rfds       Set of FDs to wait for reads.\n @param[in,out]  wfds       Set of FDs to wait for writes.\n @param[in,out]  efds       Set of FDs to wait for OOBs.\n @param[in,out]  timeout    Max blocking duration.\n @retval         -1         Failed, errno set.\n @retval          0         Timeout exceeded.\n @retval         otherwise  Total number of file descriptors returned.\n @post           `rfds` contains readable FDs.\n @post           `wfds` contains writable FDs.\n @post           `efds` contains exceptional FDs.\n @post           `timeout` is the time left.\n @note           All pointers are allowed to be null pointers.\n\n Although backend  threads can run in  parallel of this function,  touching a\n file descriptor  from multiple threads  could be problematic.   For instance\n what happens  when a  thread closes  a file descriptor  that is  selected by\n someone else, vastly varies among operating systems.  You would better avoid\n touching an fd from more than one threads.\n\n @internal\n\n Although  any file  descriptors are  possible here,  it makes  completely no\n sense to pass  a descriptor that is  not `O_NONBLOCK`.  If you  want to know\n the reason for  this limitatuon in detail, you might  find this thread super\n interesting: https://lkml.org/lkml/2004/10/6/117"]
    pub fn rb_thread_fd_select(
        nfds: ::std::os::raw::c_int,
        rfds: *mut rb_fdset_t,
        wfds: *mut rb_fdset_t,
        efds: *mut rb_fdset_t,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a signal (\"kills\") to processes.\n\n The first argument is the signal, either in:\n\n   - Numerical representation (e.g. `9`), or\n   - Textual  representation   of  canonical   (e.g.   `:SIGKILL`)   name  or\n     abbreviated (e.g. `:KILL`) name, either in ::rb_cSymbol or ::rb_cString.\n\n All the  remaining arguments are  numerical representations of  process IDs.\n This function iterates over them to send the specified signal.\n\n You can specify both negative PIDs and negative signo to this function:\n\n   ```\n    sig \\ pid | >= 1 | == 0 | == -1 | <= -2\n   ===========+======+======+=======+=======\n        > 0   |  #1  |  #2  |  #3   |  #4\n       == 0   |  #5  |  #6  |  #7   |  #8\n        < 0   |  #9  |  #10 |      #11\n   ```\n\n   - Case #1: When  signo and PID are both positive,  this function sends the\n     specified signal to the specified process (intuitive).\n\n   - Case #2: When  signo is  positive and PID  is zero, this  function sends\n     that signal to the current process group.\n\n   - Case #3: When signo is positive and  PID is -1, this function sends that\n     signal to everything that the current process is allowed to kill.\n\n   - Case #4: When signo  is positive and PID is negative  (but not -1), this\n     function sends that signal to every  processes in a process group, whose\n     process group ID is the absolute value of the passed PID.\n\n   - Case #5: When  signo  is zero  and PID is  positive, this  function just\n     checks  for the  existence of  the  specified process  and doesn't  send\n     anything to  anyone.  In  case the process  is absent  `Errno::ESRCH` is\n     raised.\n\n   - Case #6: When signo and PID are  both zero, this function checks for the\n     existence of the current process group.   And it must do.  This function\n     is effectively a no-op then.\n\n   - Case #7: When signo is zero and PID is -1, this function checks if there\n     is any other  process that the current process can  kill.  At least init\n     (PID 1) must exist, so this must not fail.\n\n   - Case #8: When  signo is  zero and  PID is  negative (but  not -1),  this\n     function checks  if there is a  process group whose process  group ID is\n     the absolute  value of  the passed  PID.  In case  the process  group is\n     absent `Errno::ESRCH` is raised.\n\n   - Case #9: When signo is negative and PID is positive, this function sends\n     the absolute value of the passed signo to the process group specified as\n     the PID.\n\n   - Case #10: When signo is negative and  PID is zero, it is highly expected\n     that this function  sends the absolute value of the  passed signo to the\n     current  process   group.   Strictly  speaking,  IEEE   Std  1003.1-2017\n     specifies that  this (`killpg(3posix)` with  an argument of zero)  is an\n     undefined behaviour.  But no operating system  is known so far that does\n     things differently.\n\n   - Case #11: When  signo and PID  are both negative, the  behaviour of this\n     function  depends on  how `killpg(3)`  works.  On  Linux, it  seems such\n     attempt is  strictly prohibited and  `Errno::EINVAL` is raised.   But on\n     macOS, it seems it  tries to to send the signal  actually to the process\n     group.\n\n @note       Above description is in fact different from how `kill(2)` works.\n             We interpret the passed arguments before passing them through to\n             system calls.\n @param[in]  argc                 Number of objects in `argv`.\n @param[in]  argv                 Signal, followed by target PIDs.\n @exception  rb_eArgError         Unknown signal name.\n @exception  rb_eSystemCallError  Various errors sending signal to processes.\n @return     Something numeric.  The meaning of this return value is unclear.\n             It seems in case of #1 above, this could be the body count.  But\n             other cases remain mysterious."]
    pub fn rb_f_kill(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries  the name  of  the signal.   It returns  for  instance `\"KILL\"`  for\n SIGKILL.\n\n @param[in]  signo      Signal number to query.\n @retval     0          No such signal.\n @retval     otherwise  A pointer  to a static C  string that is the  name of\n                        the signal.\n @warning    Don't free the return value."]
    pub fn ruby_signal_name(signo: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Pretends as if  there was no custom signal handler.   This function sets the\n signal action to SIG_DFL, then kills itself.\n\n @param[in]  sig  The signal.\n @post       Previous signal handler is lost.\n @post       Passed signal is sent to the current process.\n\n @internal\n\n @shyouhei doesn't understand  the needs of this function  being visible from\n extension libraries."]
    pub fn ruby_default_signal(sig: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Identical to rb_str_format(), except how the arguments are arranged.\n\n @param[in]  argc  Number of objects of `argv`.\n @param[in]  argv  A format string, followed by its arguments.\n @return     A rendered new instance of ::rb_cString.\n\n @internal\n\n You can safely pass NULL to `argv`.  Doesn't make any sense though."]
    pub fn rb_f_sprintf(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Ruby's extended `sprintf(3)`.   We ended up reinventing  the entire `printf`\n business because we  don't want to depend on  locales.  OS-provided `printf`\n routines  might or  might  not,  which caused  instabilities  of the  result\n strings.\n\n The format  sequence is a  mixture of  format specifiers and  other verbatim\n contents.  Each  format specifier starts with  a `%`, and has  the following\n structure:\n\n ```\n %[flags][width][.precision][length]conversion\n ```\n\n This  function  supports  flags  of   ` `, `#`,  `+`,  `-`,  `0`,  width  of\n non-negative  decimal integer  and  `*`, precision  of non-negative  decimal\n integers and `*`, length of `L`,  `h`, `t`, `z`, `l`, `ll`, `q`, conversions\n of `A`,  `D`, `E`, `G`, `O`,  `U`, `X`, `a`,  `c`, `d`, `e`, `f`,  `g`, `i`,\n `n`, `o`, `p`, `s`, `u`, `x`, and `%`.  In case of `_WIN32` it also supports\n `I`.   And additionally,  it  supports magical  `PRIsVALUE`  macro that  can\n stringise arbitrary Ruby objects:\n\n ```CXX\n rb_sprintf(\"|%\"PRIsVALUE\"|\", RUBY_Qtrue); // => \"|true|\"\n rb_sprintf(\"%+\"PRIsVALUE, rb_stdin);      // => \"#<IO:<STDIN>>\"\n ```\n\n @param[in]  fmt  A `printf`-like format specifier.\n @param[in]  ...  Variadic number of contents to format.\n @return     A rendered new instance of ::rb_cString.\n\n @internal\n\n :FIXME:  We can improve this document."]
    pub fn rb_sprintf(fmt: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_sprintf(), except it takes a `va_list`.\n\n @param[in]  fmt  A `printf`-like format specifier.\n @param[in]  ap   Contents to format.\n @return     A rendered new instance of ::rb_cString."]
    pub fn rb_vsprintf(fmt: *const ::std::os::raw::c_char, ap: va_list) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_sprintf(), except  it renders the  output to  the specified\n object rather than creating a new one.\n\n @param[out]  dst            String to modify.\n @param[in]   fmt            A `printf`-like format specifier.\n @param[in]   ...            Variadic number of contents to format.\n @exception   rb_eTypeError  `dst` is not a String.\n @return      Passed `dst`.\n @post        `dst` has the rendered output appended to its end."]
    pub fn rb_str_catf(dst: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_catf(), except it  takes a  `va_list`.  It can  also be\n seen as a  routine identical to rb_vsprintf(), except it  renders the output\n to the specified object rather than creating a new one.\n\n @param[out]  dst            String to modify.\n @param[in]   fmt            A `printf`-like format specifier.\n @param[in]   ap             Contents to format.\n @exception   rb_eTypeError  `dst` is not a String.\n @return      Passed `dst`.\n @post        `dst` has the rendered output appended to its end."]
    pub fn rb_str_vcatf(dst: VALUE, fmt: *const ::std::os::raw::c_char, ap: va_list) -> VALUE;
}
extern "C" {
    #[doc = " Formats a string.\n\n Returns  the string  resulting from  applying `fmt`  to `argv`.   The format\n sequence  is a  mixture of  format specifiers  and other  verbatim contents.\n Each format specifier starts with a `%`, and has the following structure:\n\n ```\n %[flags][width][.precision]type\n ```\n\n ...  which is  different from  that of  rb_sprintf().  Because  ruby has  no\n `short` or `long`, there is no way to specify a \"length\" of an argument.\n\n This function  supports flags  of ` `,  `#`, `+`, `-`,  `<>`, `{}`,  with of\n non-negative decimal integer and `$`, `*`, precision of non-negative decimal\n integer and `$`, `*`,  type of `A`, `B`, `E`, `G`, `X`,  `a`, `b`, `c`, `d`,\n `e`,  `f`, `g`,  `i`, `o`,  `p`,  `s`, `u`,  `x`,  `%`.  This  list is  also\n (largely the same but) not identical to that of rb_sprintf().\n\n @param[in]  argc           Number of objects in `argv`.\n @param[in]  argv           Format arguments.\n @param[in]  fmt            A printf-like format specifier.\n @exception  rb_eTypeError  `fmt` is not a string.\n @exception  rb_eArgError   Failed to parse `fmt`.\n @return     A rendered new instance of ::rb_cString.\n @note       Everything it takes must be Ruby objects.\n"]
    pub fn rb_str_format(argc: ::std::os::raw::c_int, argv: *const VALUE, fmt: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Allocates an instance of ::rb_cString.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An  instance   of  ::rb_cString,  of  `len`   bytes  length,  of\n             \"binary\" encoding, whose contents are verbatim copy of `ptr`.\n @pre        At  least  `len` bytes  of  continuous  memory region  shall  be\n             accessible via `ptr`."]
    pub fn rb_str_new(ptr: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new(), except it assumes the passed pointer is a pointer\n to a C string.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @exception  rb_eArgError    `ptr` is a null pointer.\n @return     An  instance  of  ::rb_cString,   of  \"binary\"  encoding,  whose\n             contents are verbatim copy of `ptr`.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new_cstr(),  except it takes a Ruby's  string instead of\n C's.  Implementation wise it creates a string that shares the backend memory\n region with the receiver.   So the name.  But there is  no way for extension\n libraries to know if a string is of such variant.\n\n @param[in]  str  An object of ::RString.\n @return     An  allocated   instance  of  ::rb_cString,  which   shares  the\n             encoding, length, and contents with the passed string.\n @pre        `str` must not be any arbitrary object except ::RString.\n @note       Use #StringValue to enforce the precondition."]
    pub fn rb_str_new_shared(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates  a frozen  copy of  the string,  if necessary.   This function  does\n nothing when the passed string is already frozen.  Otherwise, it allocates a\n copy of it, which is frozen.  The passed string is untouched either ways.\n\n @param[in]  str  An object of ::RString.\n @return     Something frozen.\n @pre        `str` must not be any arbitrary object except ::RString.\n @note       Use #StringValue to enforce the precondition."]
    pub fn rb_str_new_frozen(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_str_new(),  except it  takes  the class  of the  allocating\n object.\n\n @param[in]  obj             A string-ish object.\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An instance  of the class  of `obj`,  of `len` bytes  length, of\n             \"binary\" encoding, whose contents are verbatim copy of `ptr`.\n @pre        At  least  `len` bytes  of  continuous  memory region  shall  be\n             accessible via `ptr`.\n\n @internal\n\n Why it doesn't take an instance of ::rb_cClass?"]
    pub fn rb_str_new_with_class(
        obj: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_str_new(),  except  it  generates  a  string  of  \"default\n external\" encoding.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default internal\"  to \"default external\" is  fully defined over\n             the  given  contents, then  the  return  value  is a  string  of\n             \"default external\"  encoding, whose  contents are  the converted\n             ones.  Otherwise the string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object."]
    pub fn rb_external_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_external_str_new(), except it  assumes the passed pointer is\n a pointer  to a C  string.  It can  also be seen  as a routine  identical to\n rb_str_new_cstr(),  except  it  generates  a string  of  \"default  external\"\n encoding.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default internal\"  to \"default external\" is  fully defined over\n             the  given  contents, then  the  return  value  is a  string  of\n             \"default external\"  encoding, whose  contents are  the converted\n             ones.  Otherwise the string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_external_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_str_new(),  except  it  generates  a  string  of  \"locale\"\n encoding.    It   can   also   be   seen   as   a   routine   identical   to\n rb_external_str_new(),  except it  generates a  string of  \"locale\" encoding\n instead of \"default external\" encoding.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default internal\" to  \"locale\" is fully defined  over the given\n             contents,  then  the  return  value  is  a  string  of  \"locale\"\n             encoding, whose contents are  the converted ones.  Otherwise the\n             string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object."]
    pub fn rb_locale_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_locale_str_new(), except it  assumes the passed pointer is a\n pointer  to a  C string.   It can  also be  seen as  a routine  identical to\n rb_external_str_new_cstr(),  except  it  generates   a  string  of  \"locale\"\n encoding instead of \"default external\".\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default internal\" to  \"locale\" is fully defined  over the given\n             contents,  then  the  return  value  is  a  string  of  \"locale\"\n             encoding, whose contents are  the converted ones.  Otherwise the\n             string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_locale_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_str_new(),  except it  generates a  string of  \"filesystem\"\n encoding.    It   can   also   be   seen   as   a   routine   identical   to\n rb_external_str_new(), except it generates a string of \"filesystem\" encoding\n instead of \"default external\" encoding.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default  internal\" to  \"filesystem\" is  fully defined  over the\n             given  contents,   then  the  return   value  is  a   string  of\n             \"filesystem\" encoding,  whose contents  are the  converted ones.\n             Otherwise the string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object."]
    pub fn rb_filesystem_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_filesystem_str_new(), except it assumes  the passed pointer\n is a pointer to  a C string.  It can also be seen  as a routine identical to\n rb_external_str_new_cstr(),  except it  generates a  string of  \"filesystem\"\n encoding instead of \"default external\".\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @return     An instance  of ::rb_cString.  In case  encoding conversion from\n             \"default  internal\" to  \"filesystem\" is  fully defined  over the\n             given  contents,   then  the  return   value  is  a   string  of\n             \"filesystem\" encoding,  whose contents  are the  converted ones.\n             Otherwise the string is a junk.\n @warning    It doesn't raise on a conversion failure and silently ends up in\n             a  corrupted  output.  You  can  know  the failure  by  querying\n             `valid_encoding?` of the result object.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_filesystem_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Allocates  a \"string  buffer\".   A  string buffer  here  is  an instance  of\n ::rb_cString, whose  capacity is bigger than  the length of it.   If you can\n say  that a  string grows  to  a specific  amount  of bytes,  this could  be\n effective than resizing a string over and over again and again.\n\n @param[in]  capa  Designed capacity of the generating string.\n @return     An empty string, of \"binary\" encoding, whose capacity is `capa`."]
    pub fn rb_str_buf_new(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " This is a rb_str_buf_new() + rb_str_buf_cat() combo.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @return     An  instance  of  ::rb_cString,   of  \"binary\"  encoding,  whose\n             contents are verbatim copy of `ptr`.\n @pre        `ptr` must not be a null pointer.\n\n @internal\n\n This must be identical to rb_str_new_cstr(), except done in inefficient way?\n @shyouhei doesn't understand why this is not a simple alias."]
    pub fn rb_str_buf_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Allocates a  \"temporary\" string.  This is  a hidden empty string.   Handy on\n occasions.\n\n @param[in]  len  Designed length of the string.\n @return     A hidden, empty string.\n @see        rb_obj_hide()"]
    pub fn rb_str_tmp_new(len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_str_new(),  except  it  generates a  string  of \"US  ASCII\"\n encoding.  This  is different from  rb_external_str_new(), not only  for the\n output encoding, but also it doesn't convert the contents.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An  instance   of  ::rb_cString,  of  `len`   bytes  length,  of\n             \"US ASCII\" encoding, whose contents are verbatim copy of `ptr`."]
    pub fn rb_usascii_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new_cstr(),  except it generates a string  of \"US ASCII\"\n encoding.   It   can   also   be    seen   as   a   routine   Identical   to\n rb_usascii_str_new(), except it assumes the passed pointer is a pointer to a\n C string.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @exception  rb_eArgError    `ptr` is a null pointer.\n @return     An  instance  of ::rb_cString,  of  \"US  ASCII\" encoding,  whose\n             contents are verbatim copy of `ptr`.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_usascii_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new(), except it generates a string of \"UTF-8\" encoding.\n\n @param[in]  ptr             A memory region of `len` bytes length.\n @param[in]  len             Length  of `ptr`,  in bytes,  not including  the\n                             terminating NUL character.\n @exception  rb_eNoMemError  Failed to allocate `len+1` bytes.\n @exception  rb_eArgError    `len` is negative.\n @return     An  instance   of  ::rb_cString,  of  `len`   bytes  length,  of\n             \"UTF-8\" encoding, whose contents are verbatim copy of `ptr`."]
    pub fn rb_utf8_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_str_new_cstr(),  except it  generates a  string of  \"UTF-8\"\n encoding.    It   can   also   be   seen   as   a   routine   Identical   to\n rb_usascii_str_new(), except it assumes the passed pointer is a pointer to a\n C string.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @exception  rb_eArgError    `ptr` is a null pointer.\n @return     An instance of ::rb_cString, of \"UTF-8\" encoding, whose contents\n             are verbatim copy of `ptr`.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_utf8_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new(), except it takes a C string literal.\n\n @param[in]  ptr           A C string literal.\n @param[in]  len           `strlen(ptr)`.\n @exception  rb_eArgError  `len` out of range of `size_t`.\n @pre        `ptr` must be a C string constant.\n @return     An instance of ::rb_cString, of \"binary\" encoding, whose backend\n             storage is the passed C string literal.\n @warning    It is  a very  bad idea to  write to a  C string  literal (often\n             immediate  SEGV shall  occur).  Consider  return values  of this\n             function be read-only.\n\n @internal\n\n Surprisingly it can take NULL, and generates an empty string."]
    pub fn rb_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new_static(), except it generates a string of \"US ASCII\"\n encoding instead of \"binary\".  It can also be seen as a routine identical to\n rb_usascii_str_new(), except it takes a C string literal.\n\n @param[in]  ptr           A C string literal.\n @param[in]  len           `strlen(ptr)`.\n @exception  rb_eArgError  `len` out of range of `size_t`.\n @pre        `ptr` must be a C string constant.\n @return     An  instance  of ::rb_cString,  of  \"US  ASCII\" encoding,  whose\n             backend storage is the passed C string literal.\n @warning    It is  a very  bad idea to  write to a  C string  literal (often\n             immediate  SEGV shall  occur).  Consider  return values  of this\n             function be read-only."]
    pub fn rb_usascii_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_new_static(), except it  generates a string  of \"UTF-8\"\n encoding instead of \"binary\".  It can also be seen as a routine identical to\n rb_utf8_str_new(), except it takes a C string literal.\n\n @param[in]  ptr           A C string literal.\n @param[in]  len           `strlen(ptr)`.\n @exception  rb_eArgError  `len` out of range of `size_t`.\n @pre        `ptr` must be a C string constant.\n @return     An instance of ::rb_cString,  of \"UTF-8\" encoding, whose backend\n             storage is the passed C string literal.\n @warning    It is  a very  bad idea to  write to a  C string  literal (often\n             immediate  SEGV shall  occur).  Consider  return values  of this\n             function be read-only."]
    pub fn rb_utf8_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_interned_str(),  except it takes a Ruby's  string instead of\n C's.  It can also be seen  as a routine identical to to rb_str_new_shared(),\n except it returns an infamous \"f\"string.\n\n @param[in]  str  An object of ::RString.\n @return     An instance  of ::rb_cString, either cached  or allocated, which\n             has the identical encoding, length, and contents with the passed\n             string.\n @pre        `str` must not be any arbitrary object except ::RString.\n @note       Use #StringValue to enforce the precondition.\n\n @internal\n\n It  actually  finds  or  creates  a fstring  of  the  needed  property,  and\n destructively modifies  the receiver behind-the-scene  so that it  becomes a\n shared string whose parent is the returning fstring."]
    pub fn rb_str_to_interned_str(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_new(), except it returns an infamous \"f\"string.  What is\n a  fstring?  Well  it is  a special  subkind of  strings that  is immutable,\n deduped globally, and managed by our GC.   It is much like a Symbol (in fact\n Symbols  are dynamic  these days  and are  backended using  fstrings).  This\n concept has been  silently introduced at some point in  2.x era.  Since then\n it  gained  wider acceptance  in  the  core.   Starting from  3.x  extension\n libraries can also generate ones.\n\n @param[in]  ptr           A memory region of `len` bytes length.\n @param[in]  len           Length  of  `ptr`,  in bytes,  not  including  the\n                           terminating NUL character.\n @exception  rb_eArgError  `len` is negative.\n @return     A  found or  created instance  of ::rb_cString,  of `len`  bytes\n             length, of  \"binary\" encoding,  whose contents are  identical to\n             that of `ptr`.\n @pre        At  least  `len` bytes  of  continuous  memory region  shall  be\n             accessible via `ptr`."]
    pub fn rb_interned_str(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_interned_str(), except it  assumes the passed pointer  is a\n pointer to a C's  string.  It can also be seen as a  routine identical to to\n rb_str_to_interned_str(), except  it takes a  C's string instead  of Ruby's.\n Or it can  also be seen as a routine  identical to rb_str_new_cstr(), except\n it returns an infamous \"f\"string.\n\n @param[in]  ptr             A C string.\n @exception  rb_eNoMemError  Failed to allocate memory.\n @return     An  instance  of  ::rb_cString,   of  \"binary\"  encoding,  whose\n             contents are verbatim copy of `ptr`.\n @pre        `ptr` must not be a null pointer."]
    pub fn rb_interned_str_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Destroys the given string for no reason.\n\n @warning  DO NOT USE IT.\n @warning  Leave this task to our GC.\n @warning  It was a bad idea at the first place to let you know about it.\n\n @param[out]  str  The string to be executed.\n @post        The given string no longer exists.\n @note        Maybe `String#clear` could be what you want.\n\n @internal\n\n Should have moved this to `internal/string.h`."]
    pub fn rb_str_free(str_: VALUE);
}
extern "C" {
    #[doc = " Replaces the contents of the former with the latter.\n\n @param[out]  dst  Destination object.\n @param[in]   src  Source object.\n @pre         Both  objects   must  not  be  any   arbitrary  objects  except\n              ::RString.\n @post        `dst`'s  former  components  are  abandoned.  It  now  has  the\n              identical encoding, length, and contents to `src`.\n @see         rb_str_replace()\n\n @internal\n\n @shyouhei  doesn't understand  why this  is useful  to extension  libraries.\n Just use rb_str_replace().  What's wrong with that?"]
    pub fn rb_str_shared_replace(dst: VALUE, src: VALUE);
}
extern "C" {
    #[doc = " Identical to  rb_str_cat_cstr(), except  it takes  Ruby's string  instead of\n C's.  It can also be seen as a routine identical to rb_str_shared_replace(),\n except it appends instead of replaces.\n\n @param[out]  dst                 Destination object.\n @param[in]   src                 Source object.\n @exception   rb_eEncCompatError  Can't mix the encodings.\n @exception   rb_eArgError        Result string too big.\n @return      The passed `dst`.\n @pre         Both  objects   must  not  be  any   arbitrary  objects  except\n              ::RString.\n @post        `dst`  has  the  contents  of  `src`  appended,  with  encoding\n              converted into `dst`'s one, into the end of `dst`."]
    pub fn rb_str_buf_append(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_str_cat}"]
    pub fn rb_str_buf_cat(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_str_cat_cstr}"]
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_cat_cstr(), except  it additionally assumes  the source\n string be a NUL terminated ASCII string.\n\n @param[out]  dst           Destination object.\n @param[in]   src           Source string.\n @exception   rb_eArgError  Result string too big.\n @return      The passed `dst`.\n @pre         `dst` must not be any arbitrary object except ::RString.\n @pre         `src` must be a NUL terminated ASCII string.\n @post        `dst`  has  the  contents  of  `src`  appended,  with  encoding\n              converted into `dst`'s one, into the end of `dst`."]
    pub fn rb_str_buf_cat_ascii(dst: VALUE, src: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Try converting an  object to its stringised representation  using its `to_s`\n method, if  any.  If  there is  no such thing,  it resorts  to rb_any_to_s()\n output.\n\n @param[in]  obj  Arbitrary ruby object to stringise.\n @return     An instance of ::rb_cString."]
    pub fn rb_obj_as_string(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Try converting an object to its stringised representation using its `to_str`\n method, if any.  If there is no such thing, returns ::RUBY_Qnil.\n\n @param[in]  obj            Arbitrary ruby object to stringise.\n @exception  rb_eTypeError  `obj.to_str` returned something non-String.\n @retval     RUBY_Qnil      No conversion from obj to String defined.\n @return     otherwise      Stringised representation of `obj`.\n @see        rb_io_check_io\n @see        rb_check_array_type\n @see        rb_check_hash_type"]
    pub fn rb_check_string_type(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Asserts that  the given  string's encoding is  (Ruby's definition  of) ASCII\n compatible.\n\n @param[in]  obj                 An instance of ::rb_cString.\n @exception  rb_eEncCompatError  `obj` is ASCII incompatible.\n\n @internal\n\n @shyouhei doesn't know if this is an  Easter egg or an official feature, but\n this function  can in fact take  non-strings such as Symbols,  Regexps, IOs,\n etc.  However if something unsupported is  passed, it causes SEGV.  It seems\n the feature is kind of untested."]
    pub fn rb_must_asciicompat(obj: VALUE);
}
extern "C" {
    #[doc = " Duplicates a string.\n\n @param[in]  str  String in question to duplicate.\n @return     A duplicated new instance.\n @pre        `str` must be of ::RString."]
    pub fn rb_str_dup(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " I guess there  is no use case  of this function in  extension libraries, but\n this is  a routine identical  to rb_str_dup(),  except it always  creates an\n instance of ::rb_cString regardless of the given object's class.  This makes\n the most sense when the passed string is formerly hidden by rb_obj_hide().\n\n @param[in]  str  A string, possibly hidden.\n @return     A duplicated new instance of ::rb_cString."]
    pub fn rb_str_resurrect(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Obtains a \"temporary  lock\" of the string.  This  advisory locking mechanism\n prevents other  cooperating threads from  tampering the receiver.   The same\n thing could be done via freeze mechanism,  but this one can also be unlocked\n using rb_str_unlocktmp().\n\n @param[out]  str               String to lock.\n @exception   rb_eRuntimeError  `str` already locked.\n @return      The given string.\n @post        The string is locked."]
    pub fn rb_str_locktmp(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Releases a lock formerly obtained by rb_str_locktmp().\n\n @param[out]  str               String to unlock.\n @exception   rb_eRuntimeError  `str` already unlocked.\n @return      The given string.\n @post        The string is locked."]
    pub fn rb_str_unlocktmp(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_str_new_frozen}"]
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Generates a new string, concatenating the former to the latter.  It can also\n be seen as a routine identical  to rb_str_append(), except it doesn't tamper\n the passed strings to create a new one instead.\n\n @param[in]  lhs                 Source string #1.\n @param[in]  rhs                 Source string #2.\n @exception  rb_eEncCompatError  Can't mix the encodings.\n @exception  rb_eArgError        Result string too big.\n @return     A new string containing `rhs` concatenated to `lhs`.\n @pre        Both objects must not be any arbitrary objects except ::RString.\n @note       This  operation  doesn't commute.   Don't  get  confused by  the\n             \"plus\"  terminology.   For  historical reasons  there  are  some\n             noncommutative `+`s in Ruby.  This is one of such things.  There\n             has been a long discussion around `+`s in programming languages."]
    pub fn rb_str_plus(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Repetition of a string.\n\n @param[in]  str           String to repeat.\n @param[in]  num           Count, something numeric.\n @exception  rb_eArgError  `num` is negative.\n @return     A new string repeating `num` times of `str`."]
    pub fn rb_str_times(str_: VALUE, num: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Byte  offset to  character offset  conversion.   This makes  sense when  the\n receiver is in  a multibyte encoding.  The string's i-th  character does not\n always sit at its  i-th byte.  This function scans the  contents to find the\n character index that matches the byte  index.  Generally speaking this is an\n `O(n)` operation.  Could be slow.\n\n @param[in]  str  The string to scan.\n @param[in]  pos  Offset, in bytes.\n @return     Offset, in characters."]
    pub fn rb_str_sublen(str_: VALUE, pos: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " This is the implementation of two-argumented `String#slice`.\n\n - Returns the substring of the given `len` found in `str` at offset `beg`:\n\n   ```ruby\n   'foo'[0, 2] # => \"fo\"\n   'foo'[0, 0] # => \"\"\n   ```\n\n - Counts backward from the end of `str` if `beg` is negative:\n\n   ```ruby\n   'foo'[-2, 2] # => \"oo\"\n   ```\n\n - Special case: returns a  new empty string if `beg` is  equal to the length\n   of `str`:\n\n   ```ruby\n   'foo'[3, 2] # => \"\"\n   ```\n\n - Returns a null pointer if `beg` is out of range:\n\n   ```ruby\n   'foo'[4, 2] # => nil\n   'foo'[-4, 2] # => nil\n   ```\n\n - Returns the trailing substring of `str` if `len` is large:\n\n   ```ruby\n   'foo'[1, 50] # => \"oo\"\n   ```\n\n - Returns a null pointer if `len` is negative:\n\n   ```ruby\n   'foo'[0, -1] # => nil\n   ```\n\n @param[in]  str        The string to slice.\n @param[in]  beg        Requested offset of the substring.\n @param[in]  len        Requested length of the substring.\n @retval     RUBY_Qnil  Parameters out of range.\n @retval     otherwise  A  new   string  whose  contents  is   the  specified\n                        substring of `str`.\n @pre        `str` must not be any arbitrary objects except ::RString."]
    pub fn rb_str_substr(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_substr(), except  the numbers  are interpreted  as byte\n offsets instead of character offsets.\n\n @param[in]  str  The string to slice.\n @param[in]  beg  Requested offset of the substring.\n @param[in]  len  Requested length of the substring.\n @return     A new string whose contents is the specified substring of `str`.\n @pre        `str` must not be any arbitrary objects except ::RString.\n @pre        `beg` and `len` must not point to OOB contents."]
    pub fn rb_str_subseq(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_str_substr(),  except it  returns a  C's string  instead of\n Ruby's.\n\n @param[in]      str        The string to slice.\n @param[in]      beg        Requested offset of the substring.\n @param[in,out]  len        Requested length of the substring.\n @retval         NULL       Parameters out of range.\n @retval         otherwise  A pointer inside of `str`'s backend storage where\n                            the specified substring exist.\n @pre            `str` must not be any arbitrary objects except ::RString.\n @post           `len` is updated to have the length of the return value."]
    pub fn rb_str_subpos(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Declares that the string is about to be modified.  This for instance let the\n string have a dedicated backend storage.\n\n @param[out]  str               String about to be modified.\n @exception   rb_eRuntimeError  `str` is `locktmp`-ed.\n @exception   rb_eFrozenError   `str` is frozen.\n @pre         `str` must not be any arbitrary objects except ::RString.\n @post        Upon  successful return  the passed  string is  eligible to  be\n              modified."]
    pub fn rb_str_modify(str_: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_str_modify(), except it additionally expands the capacity of\n the receiver.\n\n @param[out]  str               Target string to modify.\n @param[in]   capa              Additional capacity to add.\n @exception   rb_eArgError      `capa` is negative.\n @exception   rb_eRuntimeError  `str` is `locktmp`-ed.\n @exception   rb_eFrozenError   `str` is frozen.\n @pre         `str` must not be any arbitrary objects except ::RString.\n @post        Upon successful  return the passed  string is modified  so that\n              its capacity is increased for `capa` bytes."]
    pub fn rb_str_modify_expand(str_: VALUE, capa: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " This is the implementation of `String#freeze`.\n\n @param[out]  str  Target string to freeze.\n @return      The passed string.\n @post        Upon successful return the passed string is frozen."]
    pub fn rb_str_freeze(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Overwrites the  length of the  string.  Typically this  is used to  shrink a\n string that was formerly expanded.\n\n ```CXX\n extern int fd;\n auto str = rb_eval_string(\"'...'\");\n rb_str_modify_expand(str, BUFSIZ);\n if (auto len = recv(fd, RSTRING_PTR(str), BUFSIZ, 0); len >= 0) {\n     rb_str_set_len(str, len);\n }\n else {\n     rb_sys_fail(\"recv(2)\");\n }\n ```\n\n @param[out]  str               String to shrink.\n @param[in]   len               New length of the string.\n @exception   rb_eRuntimeError  `str` is `locktmp`-ed.\n @exception   rb_eFrozenError   `str` is frozen.\n @pre         `str` must not be any arbitrary objects except ::RString.\n @post        Upon successful return `str`'s length is set to `len`."]
    pub fn rb_str_set_len(str_: VALUE, len: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " Overwrites the length of the  string.  In contrast to rb_str_set_len(), this\n function can also expand a string.\n\n @param[out]  str               String to shrink.\n @param[in]   len               New length of the string.\n @exception   rb_eArgError      `len` is negative.\n @exception   rb_eRuntimeError  `str` is `locktmp`-ed.\n @exception   rb_eFrozenError   `str` is frozen.\n @return      The passed `str`.\n @pre         `str` must not be any arbitrary objects except ::RString.\n @post        Upon successful return `str` is  either expanded or shrunken to\n              have its length be `len`."]
    pub fn rb_str_resize(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Destructively appends the passed contents to the string.\n\n @param[out]  dst           Destination object.\n @param[in]   src           Contents to append.\n @param[in]   srclen        Length of `src`.\n @exception   rb_eArgError  `srclen` is negative.\n @return      The passed `dst`.\n @pre         `dst` must not be any arbitrary objects except ::RString.\n @post        `dst` has the contents of `ptr` appended."]
    pub fn rb_str_cat(
        dst: VALUE,
        src: *const ::std::os::raw::c_char,
        srclen: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_str_cat(), except it assumes the passed pointer is a pointer\n to a C string.\n\n @param[out]  dst           Destination object.\n @param[in]   src           Contents to append.\n @exception   rb_eArgError  Result string too big.\n @exception   rb_eArgError  `src` is a null pointer.\n @return      The passed `dst`.\n @pre         `dst` must not be any arbitrary objects except ::RString.\n @pre         `src` must not be a null pointer.\n @post        `dst` has the contents of `src` appended."]
    pub fn rb_str_cat_cstr(dst: VALUE, src: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_str_cat_cstr}"]
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_str_buf_append(), except  it converts  the right  hand side\n before concatenating.\n\n @param[out]  dst                 Destination object.\n @param[in]   src                 Source object.\n @exception   rb_eEncCompatError  Can't mix the encodings.\n @exception   rb_eArgError        Result string too big.\n @return      The passed `dst`.\n @pre         `dst` must not be any arbitrary objects except ::RString.\n @post        `dst`  has  the  contents  of  `src`  appended,  with  encoding\n              converted into `dst`'s one, into the end of `dst`."]
    pub fn rb_str_append(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_str_append(), except  it  also  accepts  an integer  as  a\n codepoint.  This resembles `String#<<`.\n\n @param[out]  dst                 Destination object.\n @param[in]   src                 Source object, String or Numeric.\n @exception   rb_eRangeError      Source numeric is out of range.\n @exception   rb_eEncCompatError  Source string too long.\n @exception   rb_eArgError        Result string too big.\n @return      The passed `dst`.\n @pre         `dst` must not be any arbitrary objects except ::RString.\n @post        `dst`  has  the  contents  of  `src`  appended,  with  encoding\n              converted into `dst`'s one, into the end of `dst`."]
    pub fn rb_str_concat(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is a universal hash function.\n\n @warning    This function changes its value per process.\n @param[in]  ptr  Target message.\n @param[in]  len  Length of `ptr` in bytes.\n @return     A pseudorandom number suitable for Hash's hash value.\n @see        Aumasson,  JP., Bernstein,  D.J., \"SipHash:  A Fast  Short-Input\n             PRF\",  In  proceedings  of   13th  International  Conference  on\n             Cryptology in  India (INDOCRYPT 2012), LNCS  7668, pp.  489-508,\n             2012.  http://doi.org/10.1007/978-3-642-34931-7_28"]
    pub fn rb_memhash(
        ptr: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_long,
    ) -> st_index_t;
}
extern "C" {
    #[doc = " Starts a series of hashing.  Suppose you have a struct:\n\n ```CXX\n struct foo_tag {\n     unsigned char bar;\n     uint32_t baz;\n };\n ```\n\n It is not a  wise idea to call rb_memhash() over it,  because there could be\n padding bits.  Instead you should explicitly iterate over each fields:\n\n ```CXX\n foo_tag foo = { 0, 0, };\n st_index_t hash = 0;\n\n hash = rb_hash_start(0);\n hash = rb_hash_uint(hash, foo.bar);\n hash = rb_hash_uint32(hash, foo.baz);\n hash = rb_hash_end(hash);\n ```\n\n @param[in]  i  Initial value.\n @return     A hash value."]
    pub fn rb_hash_start(i: st_index_t) -> st_index_t;
}
extern "C" {
    #[doc = " Calculates a hash value of a string.   This is one of the two functions that\n constructs struct ::st_hash_type.\n\n @param[in]  str  An object of ::RString.\n @return     A hash value.\n @pre        `str` must not be any arbitrary object except ::RString.\n\n @internal\n\n Although safe to call, there must be no particular use case of this function\n for extension libraries.  Only ruby internals must know about it.\n\n This is not a simple alias  of rb_memhash(), because it considers the passed\n string's encoding as well as its contents."]
    pub fn rb_str_hash(str_: VALUE) -> st_index_t;
}
extern "C" {
    #[doc = " Compares two  strings.  This  is one  of the  two functions  that constructs\n struct ::st_hash_type.\n\n @param[in]  str1  A string.\n @param[in]  str2  Another string.\n @retval     1     They have identical contents, length, and encodings.\n @retval     0     Otherwise.\n @pre        Both   objects   must  not  be  any   arbitrary  objects  except\n             ::RString.\n\n @internal\n\n In contrast to  rb_str_hash(), this could be handy for  comparison that only\n concerns equality.  rb_str_cmp() returns 1, 0, -1."]
    pub fn rb_str_hash_cmp(str1: VALUE, str2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks  if  two   strings  are  comparable  each  other   or  not.   Because\n rb_str_cmp()  must  return  \"lesser  than\" or  \"greater  than\"  information,\n comparing two strings needs a stricter restriction.  Both sides must be in a\n same set of strings which have total order.  This is to check that property.\n Intuitive it  sounds?  But they  can have different encodings.   A character\n and another might or might not appear in the same order in their codepoints.\n It is complicated than you think.\n\n @param[in]  str1  A string.\n @param[in]  str2  Another string.\n @retval     1     They agree on a total order.\n @retval     0     Otherwise.\n @pre        Both   objects   must  not  be  any   arbitrary  objects  except\n             ::RString."]
    pub fn rb_str_comparable(str1: VALUE, str2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two strings, as in `strcmp(3)`.  This does not consider the current\n locale, but considers the encodings of both sides instead.\n\n @param[in]  lhs  A string.\n @param[in]  rhs  Another string.\n @retval     -1   `lhs` is \"bigger than\" `rhs`.\n @retval      1   `rhs` is \"bigger than\" `lhs`.\n @retval      0    Otherwise, e.g. not comparable.\n @pre        Both   objects   must  not  be  any   arbitrary  objects  except\n             ::RString."]
    pub fn rb_str_cmp(lhs: VALUE, rhs: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Equality of two strings.\n\n If `str2` is not a String, it  resorts to `str2 == str1`.  Otherwise if they\n are not comparable, returns ::RUBY_Qfalse.   Otherwise if they have the same\n contents  and   the  length,   returns  ::RUBY_Qtrue.    Otherwise,  returns\n ::RUBY_Qfalse.\n\n @param[in]  str1         A string.\n @param[in]  str2         Another string.\n @retval     RUBY_Qtrue   They are equal.\n @retval     RUBY_Qfalse  They are either different, or not comparable."]
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Shrinks the given string for the given number of bytes.\n\n @param[out]  str               String to squash.\n @param[in]   len               Number of bytes to reduce.\n @exception   rb_eRuntimeError  `str` is `locktmp`-ed.\n @exception   rb_eFrozenError   `str` is frozen.\n @return      The passed `str`.\n @pre         `str` must not be any arbitrary objects except ::RString.\n @post        `str` is shrunken.\n @warning     Can break a multibyte character in middle.\n\n @internal\n\n What if `len` is negative?"]
    pub fn rb_str_drop_bytes(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Replaces some  (or all) of  the contents of the  given string.  This  is the\n implementation of three-argumented `String#[]=`.\n\n @param[out]  dst               Target string to update.\n @param[in]   beg               Offset of the affected portion.\n @param[in]   len               Length of the affected portion.\n @param[in]   src               Object to be assigned.\n @exception   rb_eTypeError     `src` has no implicit conversion to String.\n @exception   rb_eIndexError    `len` is negative, or `beg` is OOB.\n @exception   rb_eRuntimeError  `dst` is `locktmp`-ed.\n @exception   rb_eFrozenError   `dst` is frozen.\n @note        Unlike rb_str_substr(), this function raises.\n @post        A  portion of  `dst`  from  `beg` to  `len`  is the  stringised\n              representation of `src`.  If that replacement string is not the\n              same  length as  the portion  it  is replacing,  `dst` will  be\n              resized accordingly."]
    pub fn rb_str_update(
        dst: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        src: VALUE,
    );
}
extern "C" {
    #[doc = " Replaces the contents  of the former object with the  stringised contents of\n the latter.\n\n @param[out]  dst               Destination object.\n @param[in]   src               Source object.\n @exception   rb_eTypeError     `src` has no implicit conversion to String.\n @exception   rb_eRuntimeError  `dst` is `locktmp`-ed.\n @exception   rb_eFrozenError   `dst` is frozen.\n @return      The passed `dst`.\n @pre        `dst` must not be any arbitrary object except ::RString.\n @post        `dst`'s  former  components  are  abandoned.  It  now  has  the\n              identical encoding, length, and contents to `src`."]
    pub fn rb_str_replace(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Generates a \"readable\" version of the receiver.\n\n @warning    The output is _insecure_.  Never feed one to `eval`.\n @warning    The output is not always in the same encoding as the given one.\n @warning    A  character might  or might  not be  escaped, depending  on the\n             result encoding.\n @param[in]  str  String to inspect.\n @return     Its inspection, either  in default internal encoding  if any, or\n             in default external encoding otherwise.\n @see        rb_str_dump()\n\n @internal\n\n This is a  (silent) fix of an actual vulnerability  feeding `inspect` output\n strings to `eval`:\n https://github.com/hiki/hiki/commit/8771a6e25198e264a2bf9dc1c102fea2cc8ff975\n\n ... and its advisory:\n http://hikiwiki.org/en/advisory20040712.html"]
    pub fn rb_str_inspect(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " \"Inverse\" of rb_eval_string().  Returns a quoted version of the string.  All\n non-printing characters are replaced by  `\\uNNNN` or `\\xHH` notation and all\n special characters are escaped.  The result string is guaranteed to render a\n string of the same contents when passed to `eval` and friends.\n\n @param[in]  str               String to dump.\n @exception  rb_eRuntimeError  Too  many  escape   sequences  causes  integer\n                               overflow on the length of the string.\n @return     An  US-ASCII string  that  includes all  the  necessary info  to\n             reconstruct the original string."]
    pub fn rb_str_dump(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Divides  the  given string  based  on  the  given  delimiter.  This  is  the\n 1-argument 0-block version of `String#split`.\n\n @param[in]  str            Object in question to split.\n @param[in]  delim          Delimiter, in C string.\n @exception  rb_eTypeError  `str` has no implicit conversion to String.\n @exception  rb_eArgError   `delim` is a null pointer.\n @return     An array of  strings, which are substrings of  the passed `str`.\n             If `delim` is an empty C string (i.e. `\"\"`), `str` is split into\n             each characters.  If `delim` is a C string whose sole content is\n             a whitespace (i.e.  `\" \"`), `str` is split  on whitespaces, with\n             leading  and   trailing  whitespace   and  runs   of  contiguous\n             whitespace  characters  ignored.    Otherwise,  `str`  is  split\n             according to `delim`."]
    pub fn rb_str_split(str_: VALUE, delim: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " This is a ::rb_gvar_setter_t that refutes non-string assignments.\n\n @exception  rb_eTypeError  Passed something non-string."]
    pub fn rb_str_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    #[doc = " Identical  to  rb_to_symbol(),  except  it assumes  the  receiver  being  an\n instance of ::RString.\n\n @param[in]  str               The name of the id.\n @exception  rb_eRuntimeError  Too many symbols.\n @return     A (possibly new) id whose value is the given `str`.\n @pre        `str` must not be any arbitrary object except ::RString.\n @note       These   days  Ruby   internally   has  two   kinds  of   symbols\n             (static/dynamic).   Symbols created  using  this function  would\n             become dynamic ones; i.e. would  be garbage collected.  It could\n             be safer for you to use it than alternatives, when applicable."]
    pub fn rb_str_intern(str_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is an rb_sym2str() + rb_str_dup() combo.\n\n @param[in]  sym  A symbol to query.\n @return     A string duplicating the symbol's backend storage.\n\n @internal\n\n This function  causes SEGV  when the  passed value is  a static  symbol that\n doesn't exist."]
    pub fn rb_sym_to_s(sym: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Counts the  number of characters (not  bytes) that are stored  inside of the\n given string.  This  of course depends on its encoding.   Also this function\n generally runs  in O(n), because  for instance you  have to scan  the entire\n string to know how many characters are there in a UTF-8 string.\n\n @param[in]  str  Target string to query.\n @return     Its number of characters."]
    pub fn rb_str_strlen(str_: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Identical to rb_str_strlen(), except it returns the value in ::rb_cInteger.\n\n @param[in]  str  Target string to query.\n @return     Its number of characters."]
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " \"Inverse\" of rb_str_sublen().  This function  scans the contents to find the\n byte index that matches the character  index.  Generally speaking this is an\n `O(n)` operation.  Could be slow.\n\n @param[in]  str  The string to scan.\n @param[in]  pos  Offset, in characters.\n @return     Offset, in bytes."]
    pub fn rb_str_offset(str_: VALUE, pos: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Queries the capacity of the given string.\n\n @see        ::RString::capa\n @param[in]  str  String in question.\n @return     Its capacity."]
    pub fn rb_str_capacity(str_: VALUE) -> usize;
}
extern "C" {
    #[doc = " Shortens `str` and adds three dots, an  ellipsis, if it is longer than `len`\n characters.  The length of the returned string in characters is less than or\n equal to `len`.  If the length of `str` is less than or equal `len`, returns\n `str` itself.   The encoding of returned  string is equal to  that of passed\n one.  The class of returned string is equal to that of passed one.\n\n @param[in]  str             The string to shorten.\n @param[in]  len             The maximum string length.\n @exception  rb_eIndexError  `len` is negative.\n @retval     str             No need to add ellipsis.\n @retval     otherwise       A new, shortened string.\n @note       The length is counted in characters."]
    pub fn rb_str_ellipsize(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " \"Cleanses\" the string.   A string has its encoding and  its contents.  They,\n in practice,  do not  always fit.  There  are strings in  the wild  that are\n \"broken\"; include bit  patterns that are not allowed by  its encoding.  That\n can  happen  when  a  user  copy&pasted something  bad,  network  input  got\n clobbered by a middleman, cosmic rays hit the physical memory, and many more\n occasions.  This function takes such strings, and fills the \"broken\" portion\n with the passed replacement bit pattern.\n\n This function also takes a ruby block.  That is a neat way to do things, but\n can be  annoying when the  caller function want to  use a block  for another\n purpose.\n\n @param[in]  str                 Target string to scrub.\n @param[in]  repl                Replacement  string.  When  it is  a string,\n                                 this function  takes that as  a replacement.\n                                 When it is  ::RUBY_Qnil, this function tries\n                                 to  yield a  block  (if any)  and takes  its\n                                 evaluated value  as a replacement.   In case\n                                 of   ::RUBY_Qnil  without   a  block,   this\n                                 function takes  an encoding-specific default\n                                 character (`U+FFFD`, for instance) as a last\n                                 resort.\n @exception  rb_eTypeError       `repl` is neither string nor nil.\n @exception  rb_eArgError        `repl` itself is broken.\n @exception  rb_eEncCompatError  `repl` and `str` are incompatible.\n @retval     RUBY_Qnil           `str` is already clean.\n @retval     otherwise           A new, clean string."]
    pub fn rb_str_scrub(str_: VALUE, repl: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Searches for  the \"successor\"  of a string.   This function  is complicated!\n This is  the only function in  the entire ruby  API (either C or  Ruby) that\n generates a string out of thin air.  First, the successor to an empty string\n is a new empty string:\n\n ```ruby\n ''.succ # => \"\"\n ```\n\n Otherwise  the successor  is  calculated by  \"incrementing\" characters.  The\n first character to  be incremented is the rightmost alphanumeric:  or, if no\n alphanumerics, the rightmost character:\n\n ```ruby\n 'THX1138'.succ # => \"THX1139\"\n '<<koala>>'.succ # => \"<<koalb>>\"\n '***'.succ # => '**+'\n ```\n\n The  successor to  a digit  is another  digit, \"carrying\"  to the  next-left\n character for  a \"rollover\"  from 9  to 0, and  prepending another  digit if\n necessary:\n\n ```ruby\n '00'.succ # => \"01\"\n '09'.succ # => \"10\"\n '99'.succ # => \"100\"\n '-9'.succ # => \"-10\"\n ```\n\n The successor to  a letter is another  letter of the same  case, carrying to\n the next-left  character for  a rollover,  and prepending  another same-case\n letter if necessary:\n\n ```ruby\n 'aa'.succ # => \"ab\"\n 'az'.succ # => \"ba\"\n 'zz'.succ # => \"aaa\"\n 'AA'.succ # => \"AB\"\n 'AZ'.succ # => \"BA\"\n 'ZZ'.succ # => \"AAA\"\n ```\n\n The successor to  a non-alphanumeric character is the next  character in the\n underlying  character set's  collating sequence,  carrying to  the next-left\n character for a rollover, and prepending another character if necessary:\n\n ```ruby\n s = \"\\u03A1\"\n s.succ # => \"\\u03A3\"  # There is no such thing like \\u03A2.\n s = 255.chr * 3\n s # => \"\\xFF\\xFF\\xFF\"\n s.succ # => \"\\x01\\x00\\x00\\x00\"\n ```\n\n Carrying can occur between and among mixtures of alphanumeric characters:\n\n ```ruby\n s = 'zz99zz99'\n s.succ # => \"aaa00aa00\"\n s = '99zz99zz'\n s.succ # => \"100aa00aa\"\n s = '1.9.9'\n s.succ # => \"2.0.0\"\n ```\n\n @param[in]  orig  Predecessor string.\n @return     Successor string."]
    pub fn rb_str_succ(orig: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates an instance of the given struct.\n\n @param[in]  klass  The class of the instance to allocate.\n @param[in]  ...    The fields.\n @return     Allocated instance of `klass`.\n @pre        `klass` must be a subclass of ::rb_cStruct.\n @note       Number of variadic arguments must much that of the passed klass'\n             fields."]
    pub fn rb_struct_new(klass: VALUE, ...) -> VALUE;
}
extern "C" {
    #[doc = " Defines a struct class.\n\n @param[in]  name           Name of the class.\n @param[in]  ...            Arbitrary number of  `const char*`, terminated by\n                            zero.  Each of which are the name of fields.\n @exception  rb_eNameError  `name` is not a constant name.\n @exception  rb_eTypeError  `name` is already taken.\n @exception  rb_eArgError    Duplicated field name.\n @return     The defined class.\n @post       Global toplevel constant `name` is defined.\n @note       `name` is allowed  to be a null pointer.   This function creates\n             an anonymous struct class then.\n\n @internal\n\n Not  seriously  checked but  it  seems  this  function  does not  share  its\n implementation with how `Struct.new` is implemented...?"]
    pub fn rb_struct_define(name: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_struct_define(),  except  it defines  the  class under  the\n specified namespace instead of global toplevel.\n\n @param[out]  space          Namespace that the defining class shall reside.\n @param[in]   name           Name of the class.\n @param[in]   ...            Arbitrary number of `const char*`, terminated by\n                             zero.  Each of which are the name of fields.\n @exception   rb_eNameError  `name` is not a constant name.\n @exception   rb_eTypeError  `name` is already taken.\n @exception   rb_eArgError    Duplicated field name.\n @return      The defined class.\n @post        `name` is a constant under `space`.\n @note        In contrast to rb_struct_define(), it doesn't make any sense to\n              pass  a null pointer to this function."]
    pub fn rb_struct_define_under(space: VALUE, name: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_struct_new(), except it  takes the  field values as  a Ruby\n array.\n\n @param[in]  klass   The class of the instance to allocate.\n @param[in]  values  Field values.\n @return     Allocated instance of `klass`.\n @pre        `klass` must be a subclass of ::rb_cStruct.\n @pre        `values` must be an instance of struct ::RArray."]
    pub fn rb_struct_alloc(klass: VALUE, values: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Mass-assigns a struct's fields.\n\n @param[out]  self    An instance of a struct class to squash.\n @param[in]   values  New values.\n @return      ::RUBY_Qnil."]
    pub fn rb_struct_initialize(self_: VALUE, values: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_struct_aref(), except it takes ::ID instead of ::VALUE.\n\n @param[in]  self           An instance of a struct class.\n @param[in]  key            Key to query.\n @exception  rb_eTypeError  `self` is not a struct.\n @exception  rb_eNameError  No such field.\n @return     The value stored at `key` in `self`."]
    pub fn rb_struct_getmember(self_: VALUE, key: ID) -> VALUE;
}
extern "C" {
    #[doc = " Queries the list of the names of the fields of the given struct class.\n\n @param[in]  klass  A subclass of ::rb_cStruct.\n @return     The list of the names of the fields of `klass`."]
    pub fn rb_struct_s_members(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the list of the names of the fields of the class of the given struct\n object.  This is  almost the same as calling  rb_struct_s_members() over the\n class of the receiver.\n\n @internal\n\n \"Almost\"?  What exactly is the difference?\n\n @endinternal\n\n @param[in]  self  An instance of a subclass of ::rb_cStruct.\n @return     The list of the names of the fields."]
    pub fn rb_struct_members(self_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Allocates an  instance of the  given class.   This consequential name  is of\n course because rb_struct_alloc() not only  allocates but also initialises an\n instance.  The API design is broken.\n\n @param[in]  klass  A subclass of ::rb_cStruct.\n @return     An allocated instance of `klass`, not initialised."]
    pub fn rb_struct_alloc_noinit(klass: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_struct_define(), except it does not define accessor methods.\n You  have to  define them  yourself.   Forget about  the allocator  function\n parameter; it is  for internal use only.  Extension libraries  are unable to\n properly allocate a ruby struct, because `RStruct` is opaque.\n\n @internal\n\n Several flags must be set up properly for ::RUBY_T_STRUCT objects, which are\n also missing for extension libraries.\n\n @endinternal\n\n @param[in]  name           Name of the class.\n @param[in]  super          Superclass of the defining class.\n @param[in]  func           Must be 0 for extension libraries.\n @param[in]  ...            Arbitrary number of  `const char*`, terminated by\n                            zero.  Each of which are the name of fields.\n @exception  rb_eNameError  `name` is not a constant name.\n @exception  rb_eTypeError  `name` is already taken.\n @exception  rb_eArgError    Duplicated field name.\n @return     The defined class.\n @post       Global toplevel constant `name` is defined.\n @note       `name` is allowed  to be a null pointer.   This function creates\n             an anonymous struct class then."]
    pub fn rb_struct_define_without_accessor(
        name: *const ::std::os::raw::c_char,
        super_: VALUE,
        func: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_struct_define_without_accessor(),  except it  defines  the\n class under the specified namespace instead of global toplevel.  It can also\n be seen as  a routine identical to rb_struct_define_under(),  except it does\n not define accessor methods.\n\n @param[out]  outer          Namespace that the defining class shall reside.\n @param[in]   class_name     Name of the class.\n @param[in]   super          Superclass of the defining class.\n @param[in]   alloc          Must be 0 for extension libraries.\n @param[in]   ...            Arbitrary number of `const char*`, terminated by\n                             zero.  Each of which are the name of fields.\n @exception   rb_eNameError  `class_name` is not a constant name.\n @exception   rb_eTypeError  `class_name` is already taken.\n @exception   rb_eArgError    Duplicated field name.\n @return      The defined class.\n @post        `class_name` is a constant under `outer`.\n @note        In contrast to  rb_struct_define_without_accessor(), it doesn't\n              make any sense to pass a null name."]
    pub fn rb_struct_define_without_accessor_under(
        outer: VALUE,
        class_name: *const ::std::os::raw::c_char,
        super_: VALUE,
        alloc: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    #[doc = " Tries to switch  to another thread.  This function blocks  until the current\n thread re-acquires the GVL.\n\n @exception  rb_eInterrupt  Operation interrupted."]
    pub fn rb_thread_schedule();
}
extern "C" {
    #[doc = " Blocks the  current thread until  the given file  descriptor is ready  to be\n read.\n\n @param[in]  fd                    A file descriptor.\n @exception  rb_eIOError           Closed stream.\n @exception  rb_eSystemCallError   Situations like EBADF."]
    pub fn rb_thread_wait_fd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_thread_wait_fd(), except it  blocks the current thread until\n the given file descriptor is ready to be written.\n\n @param[in]  fd                    A file descriptor.\n @exception  rb_eIOError           Closed stream.\n @exception  rb_eSystemCallError   Situations like EBADF."]
    pub fn rb_thread_fd_writable(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Notifies a closing of a file  descriptor to other threads.  Multiple threads\n can wait for the given file descriptor  at once.  If such file descriptor is\n closed, threads need to start propagating their exceptions.  This is the API\n to kick that process.\n\n @param[in]  fd  A file descriptor.\n @note       This function blocks  until all the threads waiting  for such fd\n             have woken up."]
    pub fn rb_thread_fd_close(fd: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Checks if  the thread this  function is running is  the only thread  that is\n currently alive.\n\n @retval  1  Yes it is.\n @retval  0  No it isn't.\n\n @internal\n\n Above description is in fact inaccurate.  There are Ractors these days."]
    pub fn rb_thread_alone() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Blocks for the given period of time.\n\n @warning    This function can be interrupted by signals.\n @param[in]  sec            Duration in seconds.\n @exception  rb_eInterrupt  Interrupted."]
    pub fn rb_thread_sleep(sec: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Blocks indefinitely.\n\n @exception  rb_eInterrupt  Interrupted."]
    pub fn rb_thread_sleep_forever();
}
extern "C" {
    #[doc = " Identical  to  rb_thread_sleep_forever(),  except the  thread  calling  this\n function is considered \"dead\" when our deadlock checker is triggered.\n\n @exception  rb_eInterrupt  Interrupted."]
    pub fn rb_thread_sleep_deadly();
}
extern "C" {
    #[doc = " Stops the current thread.  This is not the end of the thread's lifecycle.  A\n stopped thread can later be woken up.\n\n @exception  rb_eThreadError  Stopping this thread would deadlock.\n @retval     ::RUBY_Qnil      Always.\n\n @internal\n\n The return value makes no sense at all."]
    pub fn rb_thread_stop() -> VALUE;
}
extern "C" {
    #[doc = " Marks a given thread as eligible for scheduling.\n\n @note  It may still remain blocked on I/O.\n @note  This does not invoke the scheduler itself.\n\n @param[out]  thread           Thread in question to wake up.\n @exception   rb_eThreadError  Stop flogging a dead horse.\n @return      The passed thread.\n @post        The passed thread is made runnable."]
    pub fn rb_thread_wakeup(thread: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_thread_wakeup(),  except  it doesn't  raise  on an  already\n killed thread.\n\n @param[out]  thread     A thread to wake up.\n @retval      RUBY_Qnil  `thread` is already killed.\n @retval      otherwise  `thread` is alive.\n @post        The passed thread is made runnable, unless killed."]
    pub fn rb_thread_wakeup_alive(thread: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This is a rb_thread_wakeup() + rb_thread_schedule() combo.\n\n @note        There is no  guarantee that this function yields  to the passed\n              thread.  It may still remain blocked on I/O.\n @param[out]  thread           Thread in question to wake up.\n @exception   rb_eThreadError  Stop flogging a dead horse.\n @return      The passed thread."]
    pub fn rb_thread_run(thread: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Terminates the given thread.  Unlike a stopped thread, a killed thread could\n never be revived.   This function does return, when passed  e.g.  an already\n killed thread.   But if  the passed  thread is  the only  one, or  a special\n thread called \"main\", then it also terminates the entire process.\n\n @param[out]  thread          The thread to terminate.\n @exception   rb_eFatal       The passed thread is the running thread.\n @exception   rb_eSystemExit  The passed thread is the last thread.\n @return      The passed thread.\n @post        Either the passed thread, or the process entirely, is killed.\n\n @internal\n\n It seems killing the main thread also kills the entire process even if there\n are multiple running ractors.  No idea why."]
    pub fn rb_thread_kill(thread: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates a Ruby thread that is backended by a C function.\n\n @param[in]      f                    The function to run on a thread.\n @param[in,out]  g                    Passed through to `f`.\n @exception      rb_eThreadError      Could not create a ruby thread.\n @exception      rb_eSystemCallError  Situations like `EPERM`.\n @return         Allocated instance of ::rb_cThread.\n @note           This doesn't wait for anything."]
    pub fn rb_thread_create(
        f: ::std::option::Option<unsafe extern "C" fn(g: *mut ::std::os::raw::c_void) -> VALUE>,
        g: *mut ::std::os::raw::c_void,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_thread_sleep(), except it takes struct `timeval` instead.\n\n @warning    This function can be interrupted by signals.\n @param[in]  time           Duration.\n @exception  rb_eInterrupt  Interrupted."]
    pub fn rb_thread_wait_for(time: timeval);
}
extern "C" {
    #[doc = " Obtains the \"current\" thread.\n\n @return  The current thread  of the current ractor of  the current execution\n          context.\n @pre     This function must be called from a thread controlled by ruby."]
    pub fn rb_thread_current() -> VALUE;
}
extern "C" {
    #[doc = " Obtains the \"main\" thread.  There are threads called main.  Historically the\n (only) main thread was the one which  runs when the process boots.  Now that\n we have Ractor, there are more than one main threads.\n\n @return  The  main thread  of the  current ractor  of the  current execution\n          context.\n @pre     This function must be called from a thread controlled by ruby."]
    pub fn rb_thread_main() -> VALUE;
}
extern "C" {
    #[doc = " This  badly named  function reads  from a  Fiber local  storage.  When  this\n function was  born there  was no  such thing  like a  Fiber.  The  world was\n innocent.  But now...  This is a Fiber local storage.  Sorry.\n\n @param[in]  thread     Thread that the target Fiber is running.\n @param[in]  key        The name of the Fiber local storage to read.\n @retval     RUBY_Qnil  No such storage.\n @retval     otherwise  The value stored at `key`.\n @note       There in fact are \"true\"  thread local storage, but Ruby doesn't\n             provide any interface of them to you, C programmers."]
    pub fn rb_thread_local_aref(thread: VALUE, key: ID) -> VALUE;
}
extern "C" {
    #[doc = " This  badly named  function  writes to  a Fiber  local  storage.  When  this\n function was  born there  was no  such thing  like a  Fiber.  The  world was\n innocent.  But now...  This is a Fiber local storage.  Sorry.\n\n @param[in]  thread           Thread that the target Fiber is running.\n @param[in]  key              The name of the Fiber local storage to write.\n @param[in]  val              The new value of the storage.\n @exception  rb_eFrozenError  `thread` is frozen.\n @return     The passed `val` as-is.\n @post       Fiber local storage `key` has value of `val`.\n @note       There in fact are \"true\"  thread local storage, but Ruby doesn't\n             provide any interface of them to you, C programmers."]
    pub fn rb_thread_local_aset(thread: VALUE, key: ID, val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " A `pthread_atfork(3posix)`-like  API.  Ruby  expects its child  processes to\n call this function at the very beginning of their processes.  If you plan to\n fork a process don't forget to call it."]
    pub fn rb_thread_atfork();
}
extern "C" {
    #[doc = " :FIXME: situation  of this function  is unclear.   It seems nobody  uses it.\n Maybe a good idea to KonMari."]
    pub fn rb_thread_atfork_before_exec();
}
extern "C" {
    #[doc = " \"Recursion\" API entry  point.  This basically calls the  given function with\n the given arguments, but additionally with  recursion flag.  The flag is set\n to 1  if the  execution have  already experienced  the passed  `g` parameter\n before.\n\n @param[in]      f  The function that possibly recurs.\n @param[in,out]  g  Passed as-is to `f`.\n @param[in,out]  h  Passed as-is to `f`.\n @return         The return value of f."]
    pub fn rb_exec_recursive(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_exec_recursive(), except it  checks for the recursion on the\n ordered pair of `{ g, p }` instead of just `g`.\n\n @param[in]      f  The function that possibly recurs.\n @param[in,out]  g  Passed as-is to `f`.\n @param[in]      p  Paired object for recursion detection.\n @param[in,out]  h  Passed as-is to `f`."]
    pub fn rb_exec_recursive_paired(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        p: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_exec_recursive(),  except   it  calls  `f`  for  outermost\n recursion only.  Inner recursions yield calls to rb_throw_obj().\n\n @param[in]      f  The function that possibly recurs.\n @param[in,out]  g  Passed as-is to `f`.\n @param[in,out]  h  Passed as-is to `f`.\n @return         The return value of f.\n\n @internal\n\n It seems  nobody uses the \"it  calls rb_throw_obj()\" part of  this function.\n @shyouhei doesn't understand the needs."]
    pub fn rb_exec_recursive_outer(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Identical to  rb_exec_recursive_outer(), except it checks  for the recursion\n on the ordered pair of `{ g, p }`  instead of just `g`.  It can also be seen\n as a  routine identical to  rb_exec_recursive_paired(), except it  calls `f`\n for   outermost   recursion  only.    Inner   recursions   yield  calls   to\n rb_throw_obj().\n\n @param[in]      f  The function that possibly recurs.\n @param[in,out]  g  Passed as-is to `f`.\n @param[in]      p  Paired object for recursion detection.\n @param[in,out]  h  Passed as-is to `f`.\n\n @internal\n\n It seems  nobody uses the \"it  calls rb_throw_obj()\" part of  this function.\n @shyouhei doesn't understand the needs."]
    pub fn rb_exec_recursive_paired_outer(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        p: VALUE,
        h: VALUE,
    ) -> VALUE;
}
#[doc = " This is  the type of UBFs.   An UBF is  a function that unblocks  a blocking\n region.  For instance when a thread is blocking due to `pselect(3posix)`, it\n is highly expected that `pthread_kill(3posix)` can interrupt the system call\n and  the  thread  could  revive.   Or  when a  thread  is  blocking  due  to\n `waitpid(3posix)`, it  is highly  expected that  killing the  waited process\n should suffice.  An UBF is a function that does such things.  Designing your\n own UBF  needs deep understanding  of why  your blocking region  blocks, how\n threads work in ruby, and a matter of luck.  It often is the case you simply\n cannot cancel something that had already begun.\n\n @see rb_thread_call_without_gvl()"]
pub type rb_unblock_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " @private\n\n This is an implementation detail.  Must be a mistake to be here.\n\n @internal\n\n Why is  this function type different  from what rb_thread_call_without_gvl()\n takes?"]
pub type rb_blocking_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> VALUE>;
extern "C" {
    #[doc = " Checks for  interrupts.  In ruby,  signals are  masked by default.   You can\n call this function at  will to check if there are  pending signals.  In case\n there are, they would be handled in this function.\n\n If your  extension library has a  function that takes a  long time, consider\n calling it periodically.\n\n @note  It might switch to another thread."]
    pub fn rb_thread_check_ints();
}
extern "C" {
    #[doc = " Checks if the  thread's execution was recently interrupted.   If called from\n that thread, this function can be used to detect spurious wake-ups.\n\n @param[in]  thval      Thread in question.\n @retval     0          The thread was not interrupted.\n @retval     otherwise  The thread was interrupted recently.\n\n @internal\n\n Above description is not a lie.  But  actually the return value is an opaque\n trap vector.  If you know which bit means which, you can know what happened."]
    pub fn rb_thread_interrupted(thval: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a mutex.\n\n @return An allocated instance of rb_cMutex."]
    pub fn rb_mutex_new() -> VALUE;
}
extern "C" {
    #[doc = " Queries if there are any threads that holds the lock.\n\n @param[in]  mutex  The mutex in question.\n @retval     RUBY_Qtrue  The mutex is locked by someone.\n @retval     RUBY_Qfalse The mutex is not locked by anyone."]
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Attempts to lock the mutex, without  waiting for other threads to unlock it.\n Failure in locking the mutex can be detected by the return value.\n\n @param[out]  mutex        The mutex to lock.\n @retval      RUBY_Qtrue   Successfully locked by the current thread.\n @retval      RUBY_Qfalse  Otherwise.\n @note        This  function also  returns  ::RUBY_Qfalse when  the mutex  is\n              already owned by the calling thread itself."]
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Attempts to lock the mutex.  It waits until the mutex gets available.\n\n @param[out]  mutex            The mutex to lock.\n @exception   rb_eThreadError  Recursive deadlock situation.\n @return      The passed mutex.\n @post        The mutex is owned by the current thread."]
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Releases the mutex.\n\n @param[out]  mutex            The mutex to unlock.\n @exception   rb_eThreadError  The mutex is not owned by the current thread.\n @return      The passed mutex.\n @post        Upon successful return  the passed mutex is no  longer owned by\n              the current thread."]
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Releases  the lock  held in  the mutex  and waits  for the  period of  time;\n reacquires the lock on wakeup.\n\n @pre         The lock has to be owned by the current thread beforehand.\n @param[out]  self             The target mutex.\n @param[in]   timeout          Duration, in seconds, in ::rb_cNumeric.\n @exception   rb_eArgError     `timeout` is negative.\n @exception   rb_eRangeError   `timeout` is out of range of `time_t`.\n @exception   rb_eThreadError  The mutex is not owned by the current thread.\n @return      Number of seconds it actually slept.\n @warning     It is a  failure not to check the return  value.  This function\n              can return spuriously for various reasons.  Maybe other threads\n              can  rb_thread_wakeup().   Maybe  an  end user  can  press  the\n              Control and C  key from the interactive console.   On the other\n              hand it  can also  take longer than  the specified.   The mutex\n              could be locked by someone else.  It waits then.\n @post        Upon successful return the passed mutex is owned by the current\n              thread.\n\n @internal\n\n This  function is  called from  `ConditionVariable#wait`.   So it  is not  a\n deprecated feature.   However @shyouhei  have never  seen any  similar mutex\n primitive available in any other languages than Ruby.\n\n EDIT: In 2021,  @shyouhei asked @ko1 in person about  this API.  He answered\n that it is his invention.  The  motivation behind its design is to eliminate\n needs of condition variables as  primitives.  Unlike other languages, Ruby's\n `ConditionVariable` class was written in pure-Ruby initially.  We don't have\n to implement  machine-native condition  variables in  assembly each  time we\n port Ruby to a new architecture.  This function made it possible.  \"I felt I\n was a genius when this idea came to me\", said @ko1.\n\n `rb_cConditionVariable` is now written in C for speed, though."]
    pub fn rb_mutex_sleep(self_: VALUE, timeout: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Obtains the  lock, runs the passed  function, and releases the  lock when it\n completes.\n\n @param[out]     mutex  The mutex to lock.\n @param[in]      func   What to do during the mutex is locked.\n @param[in,out]  arg    Passed as-is to `func`."]
    pub fn rb_mutex_synchronize(
        mutex: VALUE,
        func: ::std::option::Option<unsafe extern "C" fn(arg: VALUE) -> VALUE>,
        arg: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Fills the current time into the given struct.\n\n @param[out]  ts                   Return buffer.\n @exception   rb_eSystemCallError  Access denied for hardware clock.\n @post        Current time is stored in `*ts`."]
    pub fn rb_timespec_now(ts: *mut timespec);
}
extern "C" {
    #[doc = " Creates  an  instance of  ::rb_cTime  with  the  given  time and  the  local\n timezone.\n\n @param[in]  sec             Seconds since the UNIX epoch.\n @param[in]  usec            Subsecond part, in microseconds resolution.\n @exception  rb_eRangeError  Cannot express the time.\n @return     An allocated instance of ::rb_cTime."]
    pub fn rb_time_new(sec: time_t, usec: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_time_new(), except  it  accepts  the time  in  nanoseconds\n resolution.\n\n @param[in]  sec             Seconds since the UNIX epoch.\n @param[in]  nsec            Subsecond part, in nanoseconds resolution.\n @exception  rb_eRangeError  Cannot express the time.\n @return     An allocated instance of ::rb_cTime."]
    pub fn rb_time_nano_new(sec: time_t, nsec: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    #[doc = " Creates an instance of ::rb_cTime, with given time and offset.\n\n @param[in]  ts            Time specifier.\n @param[in]  offset        Offset specifier, can take following values:\n                           - `INT_MAX`: `ts` is in local time.\n                           - `INT_MAX - 1`: `ts` is in UTC.\n                           - `-86400` to `86400`: fixed timezone.\n @exception  rb_eArgError  Malformed `offset`.\n @return     An allocated instance of ::rb_cTime."]
    pub fn rb_time_timespec_new(ts: *const timespec, offset: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_time_timespec_new(), except it  takes Ruby values instead of\n C structs.\n\n @param[in]  timev         Something numeric.  Currently Integers, Rationals,\n                           and Floats are accepted.\n @param[in]  off           Offset  specifier.  As  of  2.7  this argument  is\n                           heavily  extended  to   take  following  kinds  of\n                           objects:\n                             - ::RUBY_Qundef ... means UTC.\n                             - ::rb_cString ... \"+12:34\" etc.\n                             - A mysterious  \"zone\" object.  This  is largely\n                               undocumented.  However the  initial intent was\n                               that       we       want       to       accept\n                               `ActiveSupport::TimeZone`  here.   Other  gems\n                               could also be possible...   But how to make an\n                               acceptable class is beyond this document.\n @exception  rb_eArgError  Malformed `off`.\n @return     An allocated instance of ::rb_cTime."]
    pub fn rb_time_num_new(timev: VALUE, off: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Creates  a  \"time  interval\".   This   basically  converts  an  instance  of\n ::rb_cNumeric  into  a struct  `timeval`,  but  for instance  negative  time\n interval must not exist.\n\n @param[in]  num             An instance of ::rb_cNumeric.\n @exception  rb_eArgError    `num` is negative.\n @exception  rb_eRangeError  `num` is out of range of `timeval::tv_sec`.\n @return     A struct that represents the identical time to `num`."]
    pub fn rb_time_interval(num: VALUE) -> timeval;
}
extern "C" {
    #[doc = " Converts an  instance of rb_cTime  to a  struct timeval that  represents the\n identical point of time.  It can also take something numeric; would consider\n it as a UNIX time then.\n\n @param[in]  time            Instance of either ::rb_cTime or ::rb_cNumeric.\n @exception  rb_eRangeError  `time` is out of range of `timeval::tv_sec`.\n @return     A struct that represents the identical time to `num`."]
    pub fn rb_time_timeval(time: VALUE) -> timeval;
}
extern "C" {
    #[doc = " Identical to rb_time_timeval(), except for return type.\n\n @param[in]  time            Instance of either ::rb_cTime or ::rb_cNumeric.\n @exception  rb_eRangeError  `time` is out of range of `timeval::tv_sec`.\n @return     A struct that represents the identical time to `num`."]
    pub fn rb_time_timespec(time: VALUE) -> timespec;
}
extern "C" {
    #[doc = " Identical to rb_time_interval(), except for return type.\n\n @param[in]  num             An instance of ::rb_cNumeric.\n @exception  rb_eArgError    `num` is negative.\n @exception  rb_eRangeError  `num` is out of range of `timespec::tv_sec`.\n @return     A struct that represents the identical time to `num`."]
    pub fn rb_time_timespec_interval(num: VALUE) -> timespec;
}
extern "C" {
    #[doc = " Queries the  offset, in seconds  between the time zone  of the time  and the\n UTC.\n\n @param[in]  time  An instance of ::rb_cTime.\n @return     Numeric offset."]
    pub fn rb_time_utc_offset(time: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the name of a module.\n\n @param[in]  mod        An instance of ::rb_cModule.\n @retval     RUBY_Qnil  `mod` is anonymous.\n @retval     otherwise  `mod` is onymous."]
    pub fn rb_mod_name(mod_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to  rb_mod_name(),  except   it  returns  `#<Class:  ...>`  style\n inspection for anonymous modules.\n\n @param[in]  mod        An instance of ::rb_cModule.\n @return     An instance of ::rb_cString representing `mod`'s path."]
    pub fn rb_class_path(mod_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_mod_name}\n\n @internal\n\n Am I missing something?  Why we have the same thing in different names?"]
    pub fn rb_class_path_cached(mod_: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Names a class.\n\n @param[out]  klass  Target module to name.\n @param[out]  space  Namespace that `klass` shall reside.\n @param[in]   name   Name of `klass`.\n @post        `klass` has `space::klass` name."]
    pub fn rb_set_class_path(klass: VALUE, space: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Identical  to rb_set_class_path(),  except  it accepts  the  name as  Ruby's\n string instead of C's.\n\n @param[out]  klass  Target module to name.\n @param[out]  space  Namespace that `klass` shall reside.\n @param[in]   name   Name of `klass`.\n @post        `klass` has `space::klass` name."]
    pub fn rb_set_class_path_string(klass: VALUE, space: VALUE, name: VALUE);
}
extern "C" {
    #[doc = " Identical to  rb_path2class(), except it  accepts the path as  Ruby's string\n instead of C's.\n\n @param[in]  path           Path to query.\n @exception  rb_eArgError   No such constant.\n @exception  rb_eTypeError  The path resolved to a non-module.\n @return     Resolved class."]
    pub fn rb_path_to_class(path: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resolves a `Q::W::E::R`-style path string to the actual class it points.\n\n @param[in]  path           Path to query.\n @exception  rb_eArgError   No such constant.\n @exception  rb_eTypeError  The path resolved to a non-module.\n @return     Resolved class."]
    pub fn rb_path2class(path: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " Queries the name of the given object's class.\n\n @param[in]  obj  Arbitrary object.\n @return     An instance of ::rb_cString representing `obj`'s class' path."]
    pub fn rb_class_name(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Kicks the autoload procedure as if it was \"touched\".\n\n @param[out]  space        Namespace where autoload is defined.\n @param[in]   name         Name of the autoloaded constant.\n @retval      RUBY_Qfalse  No such autoload.\n @retval      RUBY_Qtrue   Autoload successfully initiated.\n @note        As an  autoloaded library is expected  to define `space::name`,\n              it is  a nature  of this function  to have  process-global side\n              effects.\n @note        Multiple threads  can simultaneously call this  API.  It blocks\n              then.  That must not last indefinitely but can take longer than\n              you expect.\n\n @internal\n\n @shyouhei has no idea why extension libraries should use this API."]
    pub fn rb_autoload_load(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Queries if an autoload is defined at a point.\n\n @param[in]  space      Namespace where autoload is defined.\n @param[in]  name       Name of the autoloaded constant.\n @retval     RUBY_Qnil  No such autoload.\n @retval     otherwise  The feature (path) registered at `space::name`."]
    pub fn rb_autoload_p(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Traces a global variable.\n\n @param[in]  argc        Either 1 or 2.\n @param[in]  argv        Variable name, optionally a Proc.\n @retval     RUBY_Qnil   No previous tracers.\n @retval     otherwise   Previous tracers.\n\n @internal\n\n @shyouhei has no idea why extension libraries should use this API."]
    pub fn rb_f_trace_var(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Deletes the  passed tracer from the  passed global variable, or  if omitted,\n deletes everything.\n\n @param[in]  argc        Either 1 or 2.\n @param[in]  argv        Variable name, optionally a Proc.\n @retval     RUBY_Qnil   No previous tracers.\n @retval     otherwise   Deleted tracers.\n\n @internal\n\n @shyouhei has no idea why extension libraries should use this API."]
    pub fn rb_f_untrace_var(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries the list of global variables.\n\n @return  The list of the name of the global variables.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_f_global_variables() -> VALUE;
}
extern "C" {
    #[doc = " Aliases  a global  variable.   Did you  know  that you  can  alias a  global\n variable?  It is like aliasing methods:\n\n ```ruby\n alias $dst $src\n ```\n\n This C function does the same thing.\n\n @param[in]  dst  Destination name.\n @param[in]  src  Source name.\n @post       A global  variable named `dst`  is defined to  be an alias  of a\n             global variable named `src`.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_alias_variable(dst: ID, src: ID);
}
extern "C" {
    #[doc = " Frees the list of instance variables.   3rd parties need not know, but there\n are several ways  to store an object's instance variables,  depending on its\n internal structure.   This function makes  sense when the passed  objects is\n using so-called \"generic\" backend storage.  People need not be aware of this\n working behind-the-scenes.\n\n @param[out]  obj  The object in question.\n\n @internal\n\n This just  destroys the given object.   @shyouhei has no idea  why extension\n libraries should use this API."]
    pub fn rb_free_generic_ivar(obj: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_iv_get(), except it accepts the name as an ::ID instead of a\n C string.\n\n @param[in]  obj        Target object.\n @param[in]  name       Target instance variable to query.\n @retval     RUBY_nil   No such instance variable.\n @retval     otherwise  The value assigned to the instance variable."]
    pub fn rb_ivar_get(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_iv_set(), except it accepts the name as an ::ID instead of a\n C string.\n\n @param[out]  obj              Target object.\n @param[in]   name             Target instance variable.\n @param[in]   val              Value to assign.\n @exception   rb_eFrozenError  Can't modify `obj`.\n @exception   rb_eArgError     `obj` has too many instance variables.\n @return      Passed value.\n @post        An  instance variable  named  `name` is  defined  if absent  on\n              `obj`, whose value is set to `val`."]
    pub fn rb_ivar_set(obj: VALUE, name: ID, val: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if  the instance variable  is defined  at the object.   This roughly\n resembles `defined?(@name)` in `obj`'s context.\n\n @param[in]  obj          Target object.\n @param[in]  name         Target instance variable to query.\n @retval     RUBY_Qtrue   There is an instance variable.\n @retval     RUBY_Qfalse  No such instance variable."]
    pub fn rb_ivar_defined(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Iterates over an object's instance variables.\n\n @param[in]  obj   Target object.\n @param[in]  func  Callback function.\n @param[in]  arg   Passed as-is to the last argument of `func`."]
    pub fn rb_ivar_foreach(
        obj: VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(name: ID, val: VALUE, arg: st_data_t) -> ::std::os::raw::c_int,
        >,
        arg: st_data_t,
    );
}
extern "C" {
    #[doc = " Number of instance variables defined on an object.\n\n @param[in]  obj   Target object.\n @return     Number of instance variables defined on `obj`."]
    pub fn rb_ivar_count(obj: VALUE) -> st_index_t;
}
extern "C" {
    #[doc = " Identical to rb_ivar_get()\n\n @param[in]  obj        Target object.\n @param[in]  name       Target instance variable to query.\n @retval     RUBY_nil   No such instance variable.\n @retval     otherwise  The value assigned to the instance variable.\n\n @internal\n\n Am I missing something?  Why we have the same thing in different names?"]
    pub fn rb_attr_get(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Object#instance_variables`.\n\n @param[in]  obj  Target object to query.\n @return     An array of instance variable names for the receiver.\n @note       Simply defining  an accessor  does not create  the corresponding\n             instance variable."]
    pub fn rb_obj_instance_variables(obj: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Object#remove_instance_variable`.\n\n @param[out]  obj   Target object.\n @param[in]   name  Variable name to remove, either in Symbol or String.\n @return      What was removed.\n @pre         Instance variable named `name` is deleted from `obj`."]
    pub fn rb_obj_remove_instance_variable(obj: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " This API is  mysterious.  It has been there since  the initial revision.  No\n single bits of  documents has ever been written.  The  function name doesn't\n describe anything.  What should be passed to the argument, or what should be\n the  return value,  are not  obvious.  Yet  it has  evolved over  time.  The\n source code is written in counter-intuitive way (as of 3.0).\n\n Simply put, don't try to understand this API."]
    pub fn rb_mod_const_at(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This is a variant of rb_mod_const_at().  As a result, it is also mysterious.\n It _seems_ it iterates over the ancestry  tree of the module.  But what that\n means is beyond a human brain."]
    pub fn rb_mod_const_of(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This is  another mysterious  API that  comes with no  documents at  all.  It\n seems it expects  some specific data structure for the  passed pointer.  But\n the details has  never been made explicit.  It seems  nobody should use this\n API."]
    pub fn rb_const_list(arg1: *mut ::std::os::raw::c_void) -> VALUE;
}
extern "C" {
    #[doc = " Resembles  `Module#constants`.   List  up   the  constants  defined  at  the\n receiver.  This  includes the  names of constants  in any  included modules,\n unless `argv[0]` is ::RUBY_Qfalse.\n\n The  implementation  makes  no  guarantees  about the  order  in  which  the\n constants are yielded.\n\n @param[in]  argc  Either 0 or 1.\n @param[in]  argv  Pointer to ::RUBY_Qfalse, if `argc == 1`.\n @param[in]  recv  Target namespace.\n @return     An array of symbols, which are constant names under `recv`."]
    pub fn rb_mod_constants(argc: ::std::os::raw::c_int, argv: *const VALUE, recv: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Module#remove_const`.\n\n @param[out]  space  Target namespace.\n @param[in]   name   Variable name to remove, either in Symbol or String.\n @return      What was removed.\n @pre         Constant named `space::name` is deleted.\n @note        In case what was removed was in  fact a module or a class, this\n              operation does  not affect its  name.  Which means  when people\n              for instance  look at  it using `p`  etc., it  still introduces\n              itself using the deleted name.  Can confuse people."]
    pub fn rb_mod_remove_const(space: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the constant is defined at the namespace.\n\n @param[in]  space        Target namespace.\n @param[in]  name         Target name to query.\n @retval     RUBY_Qtrue   There is a constant.\n @retval     RUBY_Qfalse  No such constant.\n\n @internal\n\n The return values are not typo!  This function returns ruby values casted to\n `int`.  Completely brain-damaged design."]
    pub fn rb_const_defined(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_const_defined(), except it  doesn't look for parent classes.\n For  instance  `Array`  is  a  toplevel  constant,  which  is  visible  from\n everywhere.  But this  function does not take such things  into account.  It\n concerns only what is directly defined inside of the given namespace.\n\n @param[in]  space        Target namespace.\n @param[in]  name         Target name to query.\n @retval     RUBY_Qtrue   There is a constant.\n @retval     RUBY_Qfalse  No such constant.\n\n @internal\n\n The return values are not typo!  This function returns ruby values casted to\n `int`.  Completely brain-damaged design."]
    pub fn rb_const_defined_at(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical  to  rb_const_defined(),  except  it  returns  false  for  private\n constants.\n\n @param[in]  space        Target namespace.\n @param[in]  name         Target name to query.\n @retval     RUBY_Qtrue   There is a constant.\n @retval     RUBY_Qfalse  No such constant.\n\n @internal\n\n What does \"from\" mean?  The name sounds quite cryptic.\n\n The return values are not typo!  This function returns ruby values casted to\n `int`.  Completely brain-damaged design."]
    pub fn rb_const_defined_from(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to rb_const_defined(), except it returns the actual defined value.\n\n @param[in]  space          Target namespace.\n @param[in]  name           Target name to query.\n @exception  rb_eNameError  No such constant.\n @return     The defined constant.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_const_get(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_const_defined_at(),  except it  returns the  actual defined\n value.  It can also be seen as a routine identical to rb_const_get(), except\n it doesn't look for parent classes.\n\n @param[in]  space          Target namespace.\n @param[in]  name           Target name to query.\n @exception  rb_eNameError  No such constant.\n @return     The defined constant.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_const_get_at(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_const_defined_at(),  except it  returns the  actual defined\n value.  It can also be seen as a routine identical to rb_const_get(), except\n it doesn't return a private constant.\n\n @param[in]  space          Target namespace.\n @param[in]  name           Target name to query.\n @exception  rb_eNameError  No such constant.\n @return     The defined constant.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_const_get_from(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Names a constant.\n\n @param[out]  space          Target namespace.\n @param[in]   name           Target name to query.\n @param[in]   val            Value to define.\n @exception   rb_eTypeError  `space` is not a module.\n @post        `name` is a constant under `space`, whose value is `val`.\n @note        You can reassign.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_const_set(space: VALUE, name: ID, val: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_mod_remove_const(), except it takes the name as ::ID instead\n of ::VALUE.\n\n @param[out]  space  Target namespace.\n @param[in]   name   Variable name to remove, either in Symbol or String.\n @return      What was removed.\n @pre         Constant named `space::name` is deleted.\n @note        In case what was removed was in  fact a module or a class, this\n              operation does  not affect its  name.  Which means  when people\n              for instance  look at  it using `p`  etc., it  still introduces\n              itself using the deleted name.  Can confuse people."]
    pub fn rb_const_remove(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Queries if the given class has the given class variable.\n\n @param[in]  klass        Target class.\n @param[in]  name         Name to query.\n @return     RUBY_Qtrue   Yes there is.\n @return     RUBY_Qfalse  No there isn't.\n @pre        `klass` must be an instance of rb_cModule.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_cvar_defined(klass: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Assigns a value to a class variable.\n\n @param[out]  klass  Target class.\n @param[in]   name   Variable name.\n @param[in]   val    Value to be assigned.\n @post        `klass` has a class variable named `name` whose value is `val`.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_cvar_set(klass: VALUE, name: ID, val: VALUE);
}
extern "C" {
    #[doc = " Obtains a value from a class variable.\n\n @param[in]  klass             Target class.\n @param[in]  name              Variable name.\n @exception  rb_eNameError     Uninitialised class variable.\n @exception  rb_eRuntimeError  `[Bug#14541]` situation.\n @return     Class variable named `name` under `klass`.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_cvar_get(klass: VALUE, name: ID) -> VALUE;
}
extern "C" {
    #[doc = " Identical  to rb_cvar_get(),  except  it takes  additional \"front\"  pointer.\n This  extra parameter  is a  buffer,  which will  have the  class where  the\n queried class variable actually resides.\n\n @param[in]   klass             Target class.\n @param[in]   name              Variable name.\n @param[out]  front             Return buffer.\n @exception   rb_eNameError     Uninitialised class variable.\n @exception   rb_eRuntimeError  `[Bug#14541]` situation.\n @return      Class variable named `name` under `klass`.\n @post        `front` has the class object,  which is an ancestor of `klass`,\n              where the queried class variable actually resides.\n\n @internal\n\n Above description is in fact inaccurate.  This API interfaces with Ractors."]
    pub fn rb_cvar_find(klass: VALUE, name: ID, front: *mut VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Identical to rb_cvar_set(), except it accepts C's string instead of ::ID.\n\n @param[out]  klass  Target class.\n @param[in]   name   Variable name.\n @param[in]   val    Value to be assigned.\n @post        `klass` has a class variable named `name` whose value is `val`."]
    pub fn rb_cv_set(klass: VALUE, name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    #[doc = " Identical to rb_cvar_get(), except it accepts C's string instead of ::ID.\n\n @param[in]  klass             Target class.\n @param[in]  name              Variable name.\n @exception  rb_eNameError     Uninitialised class variable.\n @exception  rb_eRuntimeError  `[Bug#14541]` situation.\n @return     Class variable named `name` under `klass`."]
    pub fn rb_cv_get(klass: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    #[doc = " @alias{rb_cv_set}\n\n @internal\n\n Am I missing something?  Why we have the same thing in different names?"]
    pub fn rb_define_class_variable(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE);
}
extern "C" {
    #[doc = " Resembles `Module#class_variables`.   List up  the variables defined  at the\n receiver.  This  includes the  names of constants  in any  included modules,\n unless `argv[0]` is ::RUBY_Qfalse.\n\n The  implementation  makes  no  guarantees  about the  order  in  which  the\n constants are yielded.\n\n @param[in]  argc  Either 0 or 1.\n @param[in]  argv  Pointer to ::RUBY_Qfalse, if `argc == 1`.\n @param[in]  recv  Target class.\n @return     An  array  of symbols,  which  are  class variable  names  under\n             `recv`."]
    pub fn rb_mod_class_variables(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    #[doc = " Resembles `Module#remove_class_variable`.\n\n @param[out]  mod   Target class.\n @param[in]   name  Variable name to remove, either in Symbol or String.\n @return      What was removed.\n @pre         Instance variable named `name` is deleted from `obj`."]
    pub fn rb_mod_remove_cvar(mod_: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    #[doc = " Queries  if  the thread  which  calls  this  function  is a  ruby's  thread.\n \"Ruby's\" in  this context  is a thread  created using one  of our  APIs like\n rb_thread_create().   There  are  distinctions   between  ruby's  and  other\n threads.  For instance calling ruby methods  are allowed only from inside of\n a ruby's thread.\n\n @retval  1  The current thread is a Ruby's thread.\n @retval  0  The current thread is a random thread from outside of Ruby."]
    pub fn ruby_native_thread_p() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Our own locale-insensitive version of `snprintf(3)`.  It can also be seen as\n a routine  identical to rb_sprintf(),  except it  writes back to  the passed\n buffer instead of allocating a new Ruby object.\n\n @param[out]  str  Return buffer\n @param[in]   n    Number of bytes of `str`.\n @param[in]   fmt  A `printf`-like format specifier.\n @param[in]   ...  Variadic number of contents to format.\n @return      Number of bytes  that would have been written to  `str`, if `n`\n              was large enough.  Comparing this  to `n` can give you insights\n              that the buffer is too small  or too big.  Especially passing 0\n              to `n`  gives you the exact  number of bytes necessary  to hold\n              the result string without writing anything to anywhere.\n @post        `str` holds  up to `n-1`  bytes of formatted contents  (and the\n              terminating NUL character.)"]
    pub fn ruby_snprintf(
        str_: *mut ::std::os::raw::c_char,
        n: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Identical to ruby_snprintf(),  except it takes a `va_list`.  It  can also be\n seen as a  routine identical to rb_vsprintf(), except it  writes back to the\n passed buffer instead of allocating a new Ruby object.\n\n @param[out]  str  Return buffer\n @param[in]   n    Number of bytes of `str`.\n @param[in]   fmt  A `printf`-like format specifier.\n @param[in]   ap   Contents  to format.\n @return      Number of bytes  that would have been written to  `str`, if `n`\n              was large enough.  Comparing this  to `n` can give you insights\n              that the buffer is too small  or too big.  Especially passing 0\n              to `n`  gives you the exact  number of bytes necessary  to hold\n              the result string without writing anything to anywhere.\n @post        `str` holds  up to `n-1`  bytes of formatted contents  (and the\n              terminating NUL character.)"]
    pub fn ruby_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        n: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
#[doc = " This  is a  table that  holds  instance variable  name to  index\n mapping.  Used when accessing instance variables using names.\n\n @internal\n\n This is a shortcut for `RCLASS_IV_INDEX_TBL(rb_obj_class(obj))`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_id_table {
    pub _address: u8,
}
#[doc = " The pattern buffer.   This is a quasi-opaque struct  that holds compiled\n intermediate representation of the regular expression.\n\n @note  Compilation of a regexp could be delayed until actual match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_pattern_buffer {
    pub _address: u8,
}
